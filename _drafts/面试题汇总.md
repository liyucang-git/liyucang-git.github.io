# 面试题汇总

## HTML

HTML 语义化，HTML 语义化的优点很多，比如清晰的页面结构、有利于 SEO、便于团队开发和维护
本地存储（ localStorage、sessionStorage、cookie 的理解 ）

## CSS

**CSS选择器的优先级**

* !important
* 内联样式（1000）
* ID选择器（0100）
* 类选择器/属性选择器/伪类选择器（0010）
* 元素选择器/关系选择器/伪元素选择器（0001）
* 通配符选择器（0000）

伪类选择器：
* :link 未访问
* :visited 已访问
* :hover 鼠标悬停
* :active 鼠标按下
* :not(s) 匹配不含s选择器的元素
* :frist-child 父元素的第一个元素
* :last-child 父元素的最后一个元素
* :only-child 父元素的唯一一个元素
* :checked 选中 :checked+伪元素

关系选择器包含：
* 包含选择器（A B）：如ul li{}
* 子选择器（A>B）
* 相邻选择器（A+B）
* 兄弟选择器（A~B）：注意对它后面的元素起作用

伪元素选择器(content属性)：
* ::before
* ::after

**盒模型**

页面渲染时，dom 元素所采用的布局模型。可通过box-sizing进行设置。根据计算宽高的区域可分为：

* content-box (W3C 标准盒模型)
* border-box (IE 盒模型)
* padding-box
* margin-box

![](/img/localBlog/1584951498782.jpg)

box-sizing: content-box（W3C盒子模型）：元素的宽高大小表现为内容的大小。
box-sizing: border-box（IE盒子模型）：元素的宽高表现为内容 + 内边距 + 边框的大小。背景会延伸到边框的外沿。

IE5.x和IE6在怪异模式中使用非标准的盒子模型，这些浏览器的width属性不是内容的宽度，而是内容、内边距和边框的宽度的总和。

**BFC - 块级格式化上下文**

BFC 全称为块级格式化上下文 (Block Formatting Context) 。BFC是 W3C CSS 2.1 规范中的一个概念，它决定了元素如何对其内容进行定位以及与其他元素的关系和相互作用，当涉及到可视化布局的时候，Block Formatting Context提供了一个环境，HTML元素在这个环境中按照一定规则进行布局。一个环境中的元素不会影响到其它环境中的布局。比如浮动元素会形成BFC，浮动元素内部子元素的主要受该浮动元素影响，两个浮动元素之间是互不影响的。这里有点类似一个BFC就是一个独立的行政单位的意思。可以说**BFC就是一个作用范围，把它理解成是一个独立的容器，并且这个容器里box的布局与这个容器外的box毫不相干**。

触发BFC的条件：

* 根元素或其它包含它的元素
* 浮动元素 (元素的 float 不是 none)
* 绝对定位元素 (元素具有 position 为 absolute 或 fixed)
* 内联块 (元素具有 display: inline-block)
* 表格单元格 (元素具有 display: table-cell，HTML表格单元格默认属性)
* 表格标题 (元素具有 display: table-caption, HTML表格标题默认属性)
* 具有overflow 且值不是 visible 的块元素
* 弹性盒（flex或inline-flex）
* display: flow-root
* column-span: all

BFC的约束规则：

* 内部的盒会在垂直方向一个接一个排列（可以看作BFC中有一个的常规流）
* 处于同一个BFC中的元素相互影响，可能会发生外边距重叠
* 每个元素的margin box的左边，与容器块border box的左边相接触(对于从左往右的格式化，否则相反)，即使存在浮动也是如此
* BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素，反之亦然
* 计算BFC的高度时，考虑BFC所包含的所有元素，连浮动元素也参与计算
* 浮动盒区域不叠加到BFC上

BFC可以解决的问题：

清除浮动

在 flex 布局还没流行的时候，我们常常会用到浮动 float ，浮动元素脱离的文档流，带来直接的一个问题就是父级高度塌陷。

清除浮动常用的方法有， clear 属性，还有就是构建 BFC ，看个小栗子

```
.con{
    border: 1px solid;
    width: 300px;
}
.float{
    float: left;
    height: 100px;
    background-color: sandybrown;
}
<div class="con">
    <div class="float">xxxxxxxx</div>
    <p>dsfsdfwefesfhjkhjkhuhjk</p>
</div>
```

黄色 div 是个浮动元素，定了 100px 高度，父级不定高，很明显父级高度没有被撑开。

![](/img/localBlog/1585065940214.jpg)

给父级 con 加上 overflow: auto; 效果如下

![](/img/localBlog/1585065968679.jpg)

这时候父级div就是一个 BFC

外边距折叠

在CSS中，两个或多个毗邻的普通流中的盒子（可能是父子元素，也可能是兄弟元素）在垂直方向上的外边距会发生叠加，这种形成的外边距称之为外边距叠加。

形成外边距折叠有几个关键要素：毗邻、两个及以上、垂直方向、正常流

毗邻：对于父子元素，他们自己是紧挨着的，子元素没有被父元素 border padding 给隔开，这样他们就是毗邻的；对于兄弟元素，他们的盒模型是挨着一起的就是毗邻的。

正常流：除去浮动定位、绝对定位，也就是正常的文档流。

这是个非常常见的问题。解决方案也挺多的，无外乎打破三要素中的一个即可，比如采用浮动、绝对定位、inline-block、添加空白的flex元素、还有就是我们接下来要说的构建 BFC

```
.con {
    width: 300px;
    background-color: antiquewhite;
}

.one {
    height: 100px;
    margin-top: 10px;
    margin-bottom: 20px;
    background-color: seagreen;
}

.two {
    height: 100px;
    margin-top: 10px;
    background-color: slateblue;
}
<div class="con">
    <div class="one"></div>
    <div class="two"></div>
</div>
```

![](/img/localBlog/1585066178986.jpg)

div one 的 margin-top: 10px; 导致父级向下移动 10px，这是父子元素的外边距折叠，我们用构建 BFC 的方式解决。

```
.con {
    width: 300px;
    background-color: antiquewhite;
    overflow: auto; /* 构建BFC */
}
```

效果如下：

![](/img/localBlog/1585066232153.jpg)


**absolute 是相对哪个元素定位的**

position 属性取值有 relative, absolute, fixed 或 sticky，元素设置了其中之一的就是定位元素。（换句话说，除static以外的任何东西）。
目前定位类型有四类：

* 相对定位元素（relatively positioned element）是计算后位置属性为 relative 的元素。
* 绝对定位元素（absolutely positioned element）是计算后位置属性为 absolute 或 fixed 的元素。
* 粘性定位元素（stickily positioned element）是计算后位置属性为 sticky 的元素。用于滑动中固定某一元素，这个目前有些兼容性问题。

相对定位
position: relative;  元素按照文档流的布局放置元素，它的用处是可以在不改变布局方式的前提下调整元素位置，使用 top bottom left right

绝对定位
position: absolute;  绝对定位的元素脱离了文档流，不会占据文档流的空间，感觉就像在文档流的上一层。

绝对定位的元素可以使用 top bottom left right 调整布局位置，在没有设置这几个值的时候，绝对定位元素显示还是保持在当前的位置。如果设置了值，那么这个元素就需要找到一个锚点，因为已经脱离文档流，所以需要找到一个参考点，这参考点就是 最近的非 static 祖先元素 ，可以是 relative, absolute, fixed，一直往上到 body 元素。

所以常常会采用 relative + absolute 的组合布局方式，当然也可以利用绝对定位元素在当前位置显示的特性结合 margin 来使用。

绝对定位还有个用处，就是避免触发回流，因为脱离正常的文档流，因此对于频繁回流的元素可以采用绝对定位。


**1px 问题了解么？有什么解决方案？**

在高清屏中 DPR 可能会是 2 或者 3 ，那么原先 1px 像素的线在高清屏下就占了2个或者3个物理像素，导致线看着比较粗。

解决：

* 使用伪元素，设置 border 1px scale(0.5)
* 设置 meta initial-scale 根据DPR设置初始值
* 伪元素 + transform: scaleY(0.5);

```
/* 伪元素 + transform: scaleY(0.5); */
.px1 {
    position: relative;
}

.px1:before {
    content: " ";
    position: absolute;
    left: 0;
    top: 0;
    width: 200%;
    border: 1px solid black;
    color: black;
    height: 200%;
    transform-origin: left top;
    transform: scale(0.5);
}
```

**层叠上下文**

元素提升为一个比较特殊的图层，在三维空间中 (z轴) 高出普通元素一等。

触发条件

* 根层叠上下文(html)
* position
* css3属性
  flex
  transform
  opacity
  filter
  will-change
  -webkit-overflow-scrolling

层叠等级：层叠上下文在z轴上的排序

![](/img/localBlog/1584965585320.jpg)

* 在同一层叠上下文中，层叠等级才有意义
* z-index的优先级最高

**居中布局**

水平居中

* 行内元素: text-align: center
* 块级元素: margin: 0 auto
* absolute + transform
* flex + justify-content: center

垂直居中

* line-height: height
* absolute + transform
* flex + align-items: center
* table

水平垂直居中

* absolute + transform
* flex + justify-content + align-items

**伪类和伪元素的区别**

伪类用于当已有元素处于的某个状态时，为其添加对应的样式，这个状态是根据用户行为而动态变化的。比如说，当用户悬停在指定的元素时，我们可以通过:hover来描述这个元素的状态。虽然它和普通的css类相似，可以为已有的元素添加样式，但是它只有处于dom树无法描述的状态下才能为元素添加样式，所以将其称为伪类。

伪元素用于创建一些不在文档树中的元素，并为其添加样式。比如说，我们可以通过:before来在一个元素前增加一些文本，并为这些文本添加样式。虽然用户可以看到这些文本，但是这些文本实际上不在文档树中。
区别

伪类的操作对象是文档树中已有的元素，而伪元素则创建了一个文档树外的元素。因此，**伪类与伪元素的区别在于：有没有创建一个文档树之外的元素**。

CSS3规范中的要求使用双冒号`(::)`表示伪元素，以此来区分伪元素和伪类，比如::before和::after等伪元素使用双冒号`(::)`，:hover和:active等伪类使用单冒号`(:)`。除了一些低于IE8版本的浏览器外，大部分浏览器都支持伪元素的双冒号`(::)`表示方法。

**Flex 布局**

布局的传统解决方案，基于盒状模型，依赖 display 属性 + position属性 + float属性。它对于那些特殊布局非常不方便，比如，垂直居中就不容易实现。

Flex 是 Flexible Box 的缩写，意为"**弹性布局**"，用来为盒状模型提供最大的灵活性。

**采用 Flex 布局的元素，称为 Flex 容器（flex container），简称"容器"。它的所有子元素自动成为容器成员，称为 Flex 项目（flex item），简称"项目"**。

容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis）。主轴的开始位置（与边框的交叉点）叫做main start，结束位置叫做main end；交叉轴的开始位置叫做cross start，结束位置叫做cross end。

项目默认沿主轴排列。单个项目占据的主轴空间叫做main size，占据的交叉轴空间叫做cross size。

以下6个属性设置在容器上：

* flex-direction
* flex-wrap
* flex-flow
* justify-content
* align-items
* align-content

以下6个属性设置在项目上：

* order
* flex-grow
* flex-shrink
* flex-basis
* flex
* align-self

**CSS 中解决浮动中高度塌陷的方案有哪些？**

* 通过增加尾元素清除浮动
`:after / <br> : clear: both`
* 创建父级 BFC
* 父级设置高度

**Flex 如何实现上下两行，上行高度自适应，下行高度 200px？**

flex-direction: column
flex: 1

**link 与 @import 的区别**

* link功能较多，可以定义 RSS，定义 Rel 等作用，而@import只能用于加载 css
* 当解析到link时，页面会同步加载所引的 css，而@import所引用的 css 会等到页面加载完才被加载
* @import需要 IE5 以上才能使用
* link可以使用 js 动态引入，@import不行

**inline-block block 的区别**

块级元素
块级元素的特点：元素总是在新的一行开始，盒模型的属性均可以控制，div p ul ol ... 等元素默认就是块级元素，也可以通过 display: block; 设置为块级元素。

行内元素
行内元素的特点：和其他元素在同一行，元素不可以设置高度和宽度，取决于内容的宽高度，默认的行内元素有 span a lable input img ...，也可通过 display: inline; 设置为行内元素。

行内块级元素
名字看上去就是上面两者的结合，同时具备了两个的特性。通过 display: inline-block; 设置。
但是两个相邻的 inline-block 元素中间有空格就会出现间隙，解决办法可以粗暴的移除空格和换行，还有设置字体大小为 0 ， 因空格也是字符，所以可给父级设置 font-size:0、letter-spacing:-3px


**rem em vh vw 的区别**

这几个单位常用于自适应布局

rem em

rem : css3 新增，相对于根节点的字体大小的一个单位，eg: 1rem * font-size:20px = 20px

在开发前先制定好一个基准，比如说以 375 宽的设计稿作为规范，设定这个宽度下的字体大小为 375/10 = 37.5 ,那设计稿下 60px 的宽对应的 rem 就是：60px = (60/37.5)rem
若使用css预处理，可以写一个转换函数

```
@function px2rem($px) {
    @return ($px/37.5) + rem;
}
```

复制代码em : 与rem类似，但是相对于父级元素的字体大小。

vw vh

相对于视口宽高的百分比值

vw : 1vw 等于视口宽度的1%
vh : 1vh 等于视口高度的1%
vmin : 选取 vw 和 vh 中最小的那个
vmax : 选取 vw 和 vh 中最大的那个

```
//iPhone 6尺寸作为设计稿基准
$vm_base: 375; 
@function vw($px) {
    @return ($px / $vm_base) * 100vw;
}
```

**英文换行**

word-break: break-all 对字符起作用，断开单词，下个字母自动到下一行。主要解决了长串英文的问题。
word-wrap:break-word  只对英文起作用，以单词作为换行依据

**哪些属性可以继承**

元素外观相关的属性可以继承，比如字体相关的属性、文本系列的属性。布局相关的属性不可以继承，具体属性名就不列举了。

## JavaScript

**for...in**

主要用于遍历对象的可枚举属性，包括自有属性、继承自原型的属性。

通常，在迭代过程中最好不要在对象上进行添加、修改或者删除属性的操作，除非是对当前正在被访问的属性。这里并不保证是否一个被添加的属性在迭代过程中会被访问到，不保证一个修改后的属性（除非是正在被访问的）会在修改前或者修改后被访问，不保证一个被删除的属性将会在它被删除之前被访问。

for...in 不应该用于迭代一个 Array，其中索引顺序很重要。数组索引只是具有整数名称的枚举属性，并且与通用对象属性相同。不能保证 for ... in 将以任何特定的顺序返回索引。for ... in 循环语句将返回所有可枚举属性，包括非整数类型的名称和继承的那些。

```
for (var prop in obj) {
  if (obj.hasOwnProperty(prop)) {
    console.log(`obj.${prop} = ${obj[prop]}`);
  }
}
```

in 操作符和 for...in 类似，检查属性是否存在是对象及其原型上的可枚举属性。

**Object.keys()**

Object.keys() 方法会返回一个由一个给定对象的自身可枚举属性组成的数组，数组中属性名的排列顺序和使用 for...in 循环遍历该对象时返回的顺序一致 。如果对象的键-值都不可枚举，那么将返回由键组成的数组。

Polyfill：

```
if (!Object.keys) {
  Object.keys = function (obj) {
    var hasOwnProperty = Object.prototype.hasOwnProperty;

    if (typeof obj !== 'object' && typeof obj !== 'function' || obj === null) throw new TypeError('Object.keys called on non-object');

    var result = [];

    for (var prop in obj) {
      if (hasOwnProperty.call(obj, prop)) result.push(prop);
    }

    return result;
  }
};
```

Object.values、Object.entries 与 Object.keys 类似，都是遍历对象的自身可枚举属性。

**Object.getOwnPropertyNames()**

Object.getOwnPropertyNames() 返回一个数组，该数组对元素是 obj 自身拥有的枚举或不可枚举属性名称字符串(但不包括 Symbol 值作为名称的属性)。数组中枚举属性的顺序与通过 for...in 循环（或 Object.keys）迭代该对象属性时一致。数组中不可枚举属性的顺序未定义。

下面的例子使用了 Array.prototype.filter() 方法，从所有的属性名数组（使用 Object.getOwnPropertyNames()方法获得）中去除可枚举的属性（使用 Object.keys()方法获得），剩余的属性便是不可枚举的属性了：

```
var target = myObject;
var enum_and_nonenum = Object.getOwnPropertyNames(target);
var enum_only = Object.keys(target);
var nonenum_only = enum_and_nonenum.filter(function(key) {
    var indexInEnum = enum_only.indexOf(key);
    if (indexInEnum == -1) {
        // 没有发现在enum_only健集中意味着这个健是不可枚举的,
        // 因此返回true 以便让它保持在过滤结果中
        return true;
    } else {
        return false;
    }
});

console.log(nonenum_only);
```

**for...of**

for...of 语句在可迭代对象（包括 Array，Map，Set，String，TypedArray，arguments 对象等等）上创建一个迭代循环，调用自定义迭代钩子，并为每个不同属性的值执行语句。

普通对象本身不存在迭代器，我们可以显式实现可迭代协议的对象。

```
var iterable = {
  [Symbol.iterator]() {
    return {
      i: 0,
      next() {
        if (this.i < 3) {
          return { value: this.i++, done: false };
        }
        return { value: undefined, done: true };
      }
    };
  }
};

for (var value of iterable) {
  console.log(value);
}
// 0
// 1
// 2
```

无论是 for...in 还是 for...of 语句都是迭代一些东西。它们之间的主要区别在于它们的迭代方式。

for...in 语句以原始插入顺序迭代对象的可枚举属性。

for...of 语句遍历可迭代对象定义要迭代的数据。

以下示例显示了与 Array 一起使用时，for...of 循环和 for...in 循环之间的区别。

```
Object.prototype.objCustom = function() {};
Array.prototype.arrCustom = function() {};

let iterable = [3, 5, 7];
iterable.foo = 'hello';

for (let i in iterable) {
  console.log(i); // logs 0, 1, 2, "foo", "arrCustom", "objCustom"
}

for (let i in iterable) {
  if (iterable.hasOwnProperty(i)) {
    console.log(i); // logs 0, 1, 2, "foo"
  }
}

for (let i of iterable) {
  console.log(i); // logs 3, 5, 7
}
```

**Array.prototype.forEach()**

forEach 方法按升序为数组中含有效值的每一项执行一次 callback 函数，那些已删除或者未初始化的项将被跳过（例如在稀疏数组上）。

forEach 遍历的范围在第一次调用 callback 前就会确定。调用 forEach 后添加到数组中的项不会被 callback 访问到。如果已经存在的值被改变，则传递给 callback 的值是 forEach 遍历到他们那一刻的值。已删除的项不会被遍历到。如果已访问的元素在迭代时被删除了（例如使用 shift()），之后的元素将被跳过。

下面的例子会输出"one", "two", "four"。当到达包含值"two"的项时，整个数组的第一个项被移除了，这导致所有剩下的项上移一个位置。因为元素 "four"现在在数组更前的位置，"three"会被跳过。 forEach()不会在迭代之前创建数组的副本。

```
var words = ['one', 'two', 'three', 'four'];
words.forEach(function(word) {
  console.log(word);
  if (word === 'two') {
    words.shift();
  }
});
// one
// two
// four
```

**Reflect.ownKeys()**

Reflect.ownKeys 方法返回一个由目标对象自身的属性键组成的数组。它的返回值等同于 Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target))。

```
Reflect.ownKeys({z: 3, y: 2, x: 1}); // [ "z", "y", "x" ]
Reflect.ownKeys([]); // ["length"]

var sym = Symbol.for("comet");
var sym2 = Symbol.for("meteor");
var obj = {[sym]: 0, "str": 0, "773": 0, "0": 0,
           [sym2]: 0, "-1": 0, "8": 0, "second str": 0};
Reflect.ownKeys(obj);
// [ "0", "8", "773", "str", "-1", "second str", Symbol(comet), Symbol(meteor) ]
```

**稀疏数组**

我们来看看对于稀疏数组，上面的几个 api 是什么结果：

```
var x= [1,,2];

for (let i in x) {
  console.log(i); // 0 2
}

Object.keys(x); // ['0', '2']

Object.getOwnPropertyNames(x); // ['0', '2', 'length']

for (let i of x) {
  console.log(i); // 1 undefined 2
}

x.forEach(o => console.log(o)) // 1 2

Reflect.ownKeys([1,,2]) // ['0', '2', 'length']
```

**深拷贝**

使用下面这个例子来演示：

```
let test = {
    num: 0,
    str: '',
    boolean: true,
    unf: undefined,
    nul: null,
    obj: {
        name: '我是一个对象',
        id: 1
    },
    arr: [0, 1, 2],
    func: function() {
        console.log('我是一个函数')
    },
    date: new Date(0),
    reg: new RegExp('/我是一个正则/ig'),
    err: new Error('我是一个错误')
}

// 判断是否为对象
function isObject(value) {
  const type = typeof value
  return value !== null && (type == 'object' || type == 'function')
}

// 判断特殊对象类型
const toString = Object.prototype.toString
function getTag(value) {
  if (value == null) {
    return value === undefined ? '[object Undefined]' : '[object Null]'
  }
  return toString.call(value)
}
```

**序列化反序列化**

这个方法非常有趣，它先把代码序列化成数据，再反序列化回对象：

```
// 序列化反序列化法
function deepClone(obj) {
    return JSON.parse(JSON.stringify(obj))
}
```

它有这些问题：

1. 对象循环引用的时候会出问题
2. 键值是 Symbol 的时候无法拷贝
3. 原型上的属性(可枚举、不可枚举、Symbol)未拷贝
4. func、date、reg 和 err 等特殊对象并没有拷贝成功
5. 不可枚举属性无法拷贝

这种方法比较适合平常开发中使用，主要用来拷贝 JSON 格式的对象，不需要考虑对象和数组之外的类型。

**递归遍历**

先看一个简单版的实现：

```
function deepClone(obj) {
    if (!isObject(obj)) {
        return obj;
    }

    let isArray = Array.isArray(obj)
    let cloneObj = isArray ? [] : {}

    Object.entries(obj).forEach([key, val] =>
        cloneObj[key] = deepClone(val)
    )

    return cloneObj
}
```

用这种方法 arr 和 obj 都深拷贝成功了，它们的内存引用已经不同了。但和 JSON 格式化一样，依旧存在这些问题：

1. 对象循环引用的时候会出问题
2. 键值是 Symbol 的时候无法拷贝
3. 原型上的属性(可枚举、不可枚举、Symbol)未拷贝
4. func、date、reg 和 err 等特殊对象并没有拷贝成功
5. 不可枚举属性无法拷贝

接下来我们来一个个解决问题。

首先，使用 Reflect.ownKeys 可以获得对象的所有属性(可枚举、不可枚举、Symbol)，因此可以解决 2、5 的问题。

```
function deepClone(obj) {
    if (!isObject(obj)) {
        return obj;
    }

    let isArray = Array.isArray(obj)
    let cloneObj = isArray ? [] : {}
    Reflect.ownKeys(cloneObj).forEach(key => {
        cloneObj[key] = deepClone(obj[key])
    })

    return cloneObj
}
```

当然，如果你只需要拷贝对象的可枚举属性和 Symbol 键值的属性时，一般也不需要拷贝不可枚举属性，可以这样：

```
function deepClone(obj) {
    if (!isObject(obj)) {
        return obj;
    }

    let isArray = Array.isArray(obj)
    let cloneObj = isArray ? [] : {}
    let symKeys = Object.getOwnPropertySymbols(obj)
    if (symKeys.length > 0) {
        symKeys.forEach(symKey => {
            cloneObj[symKey] = deepClone(obj[symKey])
        })
    }

    Object.entries(obj).forEach([key, val] =>
        cloneObj[key] = deepClone(val)
    )

    return cloneObj
}
```

接着，对象成环怎么办？

我们给 test 加一个 loopObj 键，值指向自身：

```
test.loopObj = test
```

这时我们使用上面的递归方法都会栈溢出，而使用 jSON 格式化也会报错。

我们可以设置一个哈希表存储已拷贝过的对象，来解决循环引用问题：

```
function deepClone(obj, hash = new WeakMap()) {
    if (!isObject(obj)) {
        return obj
    }
    // 查表
    if (hash.has(obj)) return hash.get(obj)

    let isArray = Array.isArray(obj)
    let cloneObj = isArray ? [] : {}
    // 哈希表设值
    hash.set(obj, cloneObj)

    let symKeys = Object.getOwnPropertySymbols(obj)
    if (symKeys.length > 0) {
        symKeys.forEach(symKey => {
            cloneObj[symKey] = deepClone(obj[symKey])
        })
    }

    Object.entries(obj).forEach([key, val] =>
        cloneObj[key] = deepClone(val)
    )

    return cloneObj
}
```

这里我们使用 WeakMap 作为哈希表，因为它的键是弱引用的，而我们这个场景里键恰好是对象，需要弱引用。

最后，怎么拷贝原型上的属性？

众所周知，JS 对象是基于原型链设计的，所以当一个对象的属性查找不到时会沿着它的原型链向上查找，也就是一个非构造函数对象的 `__proto__` 属性。

我们可以使用 for...in 追踪原型链上的属性，而其它三种方法(Object.keys、Reflect.ownKeys 和 JSON 方法)都不会追踪原型链上的属性：

```
function deepClone(obj, hash = new WeakMap()) {
    if (!isObject(obj)) {
        return obj
    }
    // 查表
    if (hash.has(obj)) return hash.get(obj)

    let isArray = Array.isArray(obj)
    let cloneObj = isArray ? [] : {}
    // 哈希表设值
    hash.set(obj, cloneObj)

    let symKeys = Object.getOwnPropertySymbols(obj)
    if (symKeys.length > 0) {
        symKeys.forEach(symKey => {
            cloneObj[symKey] = deepClone(obj[symKey])
        })
    }

    // 拷贝可枚举属性（包括原型链上的）
    for (let key in obj) {
        cloneObj[key] = deepClone(obj[key], hash);
    }

    return cloneObj
}
```

至于要拷贝 js 中的特殊对象，则需要判断对象对具体类型，并做相应的处理。而要拷贝原型链上的不可枚举属性就需要一层层递归调用`Object.getPrototypeOf`来获取对象原型。

**数组扁平化**

**flat**

```
var arr1 = [1, 2, [3, 4]];
arr1.flat();
// [1, 2, 3, 4]

var arr2 = [1, 2, [3, 4, [5, 6]]];
arr2.flat();
// [1, 2, 3, 4, [5, 6]]

var arr3 = [1, 2, [3, 4, [5, 6]]];
arr3.flat(2);
// [1, 2, 3, 4, 5, 6]

//使用 Infinity 作为深度，展开任意深度的嵌套数组
arr3.flat(Infinity);
// [1, 2, 3, 4, 5, 6]
```

**递归**

```
// 使用 reduce、concat 和递归无限反嵌套多层嵌套的数组
var arr1 = [1,2,3,[1,2,3,4, [2,3,4]]];

function flattenDeep(arr1) {
   return arr1.reduce((acc, val) => Array.isArray(val) ? acc.concat(flattenDeep(val)) : acc.concat(val), []);
}
flattenDeep(arr1);
// [1, 2, 3, 1, 2, 3, 4, 2, 3, 4]

or

function fn(arr){
  let arr1 = []
  arr.forEach((val)=>{
      if(val instanceof Array){
        arr1 = arr1.concat(fn(val));
      }else{
        arr1.push(val);
      }
  })
  return arr1
}
```

**循环**

```
更优：
function flatten(arr){
  while(arr.some(item => Array.isArray(item))){
    arr = [].concat.apply([],arr);
  }
  return arr;
}

or

function flatten(arr){
  while(arr.some(item => Array.isArray(item))){
    arr = arr.reduce((prev,cur)=>{
      return prev.concat(cur);
    },[]);
  }
  return arr;
}
```

**stack**

```
// 不使用递归，使用 stack 无限反嵌套多层嵌套数组
var arr1 = [1,2,3,[1,2,3,4, [2,3,4]]];
function flatten(input) {
  const stack = [...input];
  const res = [];
  while (stack.length) {
    // 使用 pop 从 stack 中取出并移除值
    const next = stack.pop();
    if (Array.isArray(next)) {
      // 使用 push 送回内层数组中的元素，不会改动原始输入 original input
      stack.push(...next);
    } else {
      res.push(next);
    }
  }
  // 使用 reverse 恢复原数组的顺序
  return res.reverse();
}
flatten(arr1);// [1, 2, 3, 1, 2, 3, 4, 2, 3, 4]
```

**toString**

针对数字类型的字符串

```
let arr1 = arr.toString().split(',').map((val)=>{
  return parseInt(val)
})
console.log(arr1)
```

**数组去重**

**Set**

严格相等比较，且可以去重 NaN。对于对象，引用相同也可去重。

```
function unique (arr) {
  return Array.from(new Set(arr))
}
var arr = [1,1,'true','true',true,true,15,15,false,false, undefined,undefined, null,null, NaN, NaN,'NaN', 0, 0, 'a', 'a',{},{}];
console.log(unique(arr))
 //[1, "true", true, 15, false, undefined, null, NaN, "NaN", 0, "a", {}, {}]
```

**遍历**

这些方法都只能去重引用相同的对象，对于引用不同的对象需要更加准确的处理。

```
function unique(arr) {
  if (!Array.isArray(arr)) {
    console.log('type error!')
    return
  }
  var array = [];
  for (var i = 0; i < arr.length; i++) {
    if (array .indexOf(arr[i]) === -1) {
      array .push(arr[i])
    }
  }
  return array;
}
var arr = [1,1,'true','true',true,true,15,15,false,false, undefined,undefined, null,null, NaN, NaN,'NaN', 0, 0, 'a', 'a',{},{}];
console.log(unique(arr))
   // [1, "true", true, 15, false, undefined, null, NaN, NaN, "NaN", 0, "a", {…}, {…}]  //NaN、{}没有去重
```

```
function unique(arr) {
  if (!Array.isArray(arr)) {
      console.log('type error!')
      return
  }
  var array =[];
  for(var i = 0; i < arr.length; i++) {
    if( !array.includes( arr[i]) ) {//includes 检测数组是否有某个值
        array.push(arr[i]);
      }
  }
  return array
}
var arr = [1,1,'true','true',true,true,15,15,false,false, undefined,undefined, null,null, NaN, NaN,'NaN', 0, 0, 'a', 'a',{},{}];
    console.log(unique(arr))
    //[1, "true", true, 15, false, undefined, null, NaN, "NaN", 0, "a", {…}, {…}]     //{}没有去重
```

```
function arrayNonRepeatfy(arr) {
  let map = new Map();
  let array = new Array();  // 数组用于返回结果
  for (let i = 0; i < arr.length; i++) {
    if(map.has(arr[i])) {  // 如果有该key值
      map.set(arr[i], true);
    } else {
      map.set(arr[i], false);   // 如果没有该key值
      array.push(arr[i]);
    }
  }
  return array ;
}
 var arr = [1,1,'true','true',true,true,15,15,false,false, undefined,undefined, null,null, NaN, NaN,'NaN', 0, 0, 'a', 'a',{},{}];
    console.log(unique(arr))
//[1, "a", "true", true, 15, false, 1, {…}, null, NaN, NaN, "NaN", 0, "a", {…}, undefined]
```

**对象数组**

针对对象数组，我们来实现去重。

```
var arr=[{id:1,name:'bob'},{id:1,name:'bob'},{id:1,name:'bob'},{id:1,name:'lucy'},{id:1,name:'lucy'},{id:2,name:'lucy'},{id:2,name:'张三'}]
//去掉相同id的项目
var arr1=arr.filter(function(element,index,self){
  return self.findIndex(el=>el.id==element.id)===index
})
//封装成方法，通过某个属性去重
function filterRepeat(arr,prop){
  return arr.filter(function(element,index,self){
    return self.findIndex(el=>el[prop]==element[prop])===index
  })
}
//自定义去重方法
function filterRepeat2(arr,compareFn){
  return arr.filter(function(element,index,self){
    return self.findIndex(el=>compareFn(el,element))===index
  })
}
//加载到数组原型上
Array.prototype.filterRepeat=function(){
      if(typeof arguments[0]=='string')  return filterRepeat(this,arguments[0])
      return filterRepeat2(this,arguments[0])
}
//test 通过name属性去重
var newArr=arr.filterRepeat('name')
console.log(newArr)
var newArr2=arr.filterRepeat(function(a,b){return a.id==b.id&&a.name==b.name})
console.log(newArr2)

or

var arr=[{id:1,name:'bob'},{id:1,name:'bob'},{id:1,name:'bob'},{id:1,name:'lucy'},{id:1,name:'lucy'},{id:2,name:'lucy'},{id:2,name:'张三'}]
var arr1=arr.reduce(function(prev,element){
  if(!prev.find(el=>el.id==element.id)) {
    prev.push(element)
  }
  return prev
},[])
```

**大数相加**

使用字符串处理两个相加会大于 Number.MAX_SAFE_INTEGER (2^52 - 1) 的数字相加。

```
function add(a, b) {
  const arr_a = [...a].reverse().map(value => +value); // [个位,十位...]
  const arr_b = [...b].reverse().map(value => +value);
  const result = [];

  let carry = 0, // 进位
    i = 0,
    value_a = 0,
    value_b = 0;

  // 可能a, b在i位都没有数值，但存在进位
  while (arr_a[i] || arr_b[i] || carry) {
    let sum = 0,
      value = 0;
    value_a = arr_a[i] || 0;
    value_b = arr_b[i] || 0;
    sum = value_a + value_b + carry;
    carry = Math.floor(sum / 10);
    value = carry ? sum - 10 : sum;
    result.push(value);
    i++;
  }

  return result.reverse().join("");
}
```

**Javascript 的作用域链？**

作用域链的作用是保证对执行环境有权访问的所有变量和函数的有序访问，通过作用域链，我们可以访问到外层环境的变量和
函数。

作用域链的本质上是一个指向变量对象的指针列表。变量对象是一个包含了执行环境中所有变量和函数的对象。作用域链的前端始终都是当前执行上下文的变量对象。全局执行上下文的变量对象（也就是全局对象）始终是作用域链的最后一个对象。

当我们查找一个变量时，如果当前执行环境中没有找到，我们可以沿着作用域链向后查找。

作用域链的创建过程跟执行上下文的建立有关....

**谈谈 This 对象的理解**

this 是执行上下文中的一个属性，它指向最后一次调用这个方法的对象。在实际开发中，this 的指向可以通过四种调用模式来判断。

（1）第一种是函数调用模式，当一个函数不是一个对象的属性时，直接作为函数来调用时，this 指向全局对象。

（2）第二种是方法调用模式，如果一个函数作为一个对象的方法来调用时，this 指向这个对象。

（3）第三种是构造器调用模式，如果一个函数用 new 调用时，函数执行前会新创建一个对象，this 指向这个新创建的对象。

（4）第四种是 apply 、 call 和 bind 调用模式，这三个方法都可以显示的指定调用函数的 this 指向。其中 apply方法接收两个参数：一个是 this 绑定的对象，一个是参数数组。call 方法接收的参数，第一个是 this 绑定的对象，后面的其余参数是传入函数执行的参数。也就是说，在使用 call() 方法时，传递给函数的参数必须逐个列举出来。bind 方法通过传入一个对象，返回一个 this 绑定了传入对象的新函数。这个函数的 this 指向除了使用 new 时会被改变，其他情况下都不会改变。

这四种方式，使用构造器调用模式的优先级最高，然后是 apply 、 call 和 bind 调用模式，然后是方法调用模式，然后是函数调用模式。

**寄生式组合继承的实现**

```
 function Person(name) {
   this.name = name;
 }

 Person.prototype.sayName = function () {
   console.log("My name is " + this.name + ".");
 }

 function Student(name, grade) {
   Person.call(this, name);
   this.grade = grade;
 }

 Student.prototype = Object.create(Person.prototype);
 Student.prototype.constructor = Student;

 Student.prototype.sayMyGrade = function () {
   console.log("My grade is " + this.grade + ".");
 } 
```
**打乱数组**

```
function shuffle(arr) {
  let i = arr.length;
  while (i) {
    let j = Math.floor(Math.random() * i--);
    [arr[j], arr[i]] = [arr[i], arr[j]];
  }
}
```
**深拷贝**

```
 function deepCopy(object) {

   if (object === null || typeof object !== "object") return object;

   let newObject = Array.isArray(object) ? [] : {};

   for (let key in object) {
     if (object.hasOwnProperty(key)) {
       newObject[key] = deepCopy(object[key]);
     }
   }

   return newObject;
 }
```

**ajax**

```
//步骤一:创建异步对象
var ajax = new XMLHttpRequest();

//步骤二:设置请求的url参数,参数一是请求的类型,参数二是请求的url,可以带参数,动态的传递参数starName到服务端
ajax.open('get','getStar.php?starName='+name);

//步骤三:发送请求
ajax.send();

//步骤四:注册事件 onreadystatechange 状态改变就会调用
ajax.onreadystatechange = function () {
  if (ajax.readyState==4 && ajax.status==200) {
    //步骤五 如果能够进到这个判断说明数据完美的回来了,并且请求的页面是存在的
    console.log(ajax.responseText);
  }
}
```

**bind 实现**

```
if (!Function.prototype.bind) {
  Function.prototype.bind = function (...args) {
    const self = this;
    const context = args.shift();
    return function (...curArgs) {
      return self.apply(context, [...args, ...curArgs]);
    }
  }
}
```

**eventBus实现**

```
class EventBus {
  constructor() {
    this.event = Object.create(null);
  };
  on(name, fn) {
    if(!this.event[name]) {
      this.event[name] = [];
    };
    this.event[name].push(fn);
  };
  emit(name, ...args) {
    this.event[name] && this.event[name].forEach(fn => {
      fn(...args)
    });
  };
  once(name, fn) {
    const cb = (...args) => {
      fn.apply(this, args);
      this.off(name, fn);
    };
    this.on(name, cb);
  };
  off(name, offcb) {
    if(this.event[name]){
      let index = this.event[name].findIndex((fn) => {
        return offcb === fn;
      })
      if (index >= 0) {
        this.event[name].splice(index, 1);
      }
    }
  }
}
```

**JSONP**

```
var script = document.createElement('script');
script.type = 'text/javascript';

// 传参并指定回调执行函数为onBack
script.src = 'http://www.domain-com:8080/login?user=admin&callback=onBack';
document.head.appendChild(script);

// 回调执行函数
function onBack(res) {
  alert(JSON.stringify(res));
}
```

**ES5 和 ES6 继承的区别**

* ES5 的继承使用借助构造函数实现，实质是先创造子类的实例对象this，然后再将父类的方法添加到this上面。ES6 的继承机制完全不同，实质是先创造父类的实例对象this（所以必须先调用super方法），然后再用子类的构造函数修改this。

* ES6 在继承的语法上不仅继承了类的原型对象，还继承了类的静态属性和静态方法

**执行上下文(EC)**

执行上下文可以简单理解为一个对象:

它包含三个部分:

* 变量对象(VO)
* 作用域链(词法作用域)
* this指向

它的类型:

* 全局执行上下文
* 函数执行上下文
* eval执行上下文

代码执行过程:

* 创建 全局上下文 (global EC)
* 全局执行上下文 (caller) 逐行 自上而下 执行。遇到函数时，函数执行上下文 (callee) 被push到执行栈顶层
* 函数执行上下文被激活，成为 active EC, 开始执行函数中的代码，caller 被挂起
* 函数执行完后，callee 被pop移除出执行栈，控制权交还全局上下文 (caller)，继续执行

**变量对象**

变量对象，是执行上下文中的一部分，可以抽象为一种 数据作用域，其实也可以理解为就是一个简单的对象，它存储着**该执行上下文中的所有 变量和函数声明**(不包含函数表达式)。

活动对象 (AO): 当变量对象所处的上下文为 active EC 时，称为活动对象。

**作用域链**

我们知道，我们可以在执行上下文中访问到父级甚至全局的变量，这便是作用域链的功劳。作用域链可以理解为一组对象列表，包含 父级和自身的变量对象，因此我们便能通过作用域链访问到父级里声明的变量或者函数。

由两部分组成:

* `[[scope]]`属性: 指向父级变量对象和作用域链，也就是包含了父级的`[[scope]]`和AO
* AO: 自身活动对象

如此 `[[scope]]`包含`[[scope]]`，便自上而下形成一条 链式作用域。

**闭包**

闭包属于一种特殊的作用域，称为 静态作用域。它的定义可以理解为: 父函数被销毁 的情况下，返回出的子函数的`[[scope]]`中仍然保留着父级的变量对象和作用域链，因此可以继续访问到父级的变量对象，这样的函数称为闭包。

闭包会产生一个很经典的问题:

多个子函数的`[[scope]]`都是同时指向父级，是完全共享的。因此当父级的变量对象被修改时，所有子函数都受到影响。

解决:

* 变量可以通过 函数参数的形式 传入，避免使用默认的`[[scope]]`向上查找
* 使用setTimeout包裹，通过第三个参数传入
* 使用 块级作用域，让变量成为自己上下文的属性，避免共享

**script 引入方式**

* html 静态`<script>`引入
* js 动态插入`<script>`
* `<script defer>`: 异步加载，元素解析完成后执行
* `<script async>`: 异步加载，与元素渲染并行执行

**new运算符的执行过程**

新生成一个对象
链接到原型: `obj.__proto__ = Con.prototype`
绑定this: apply
返回新对象

**instanceof原理**

能在实例的 原型对象链 中找到该构造函数的prototype属性所指向的 原型对象，就返回true。即:

```
// __proto__: 代表原型对象链
instance.[__proto__...] === instance.constructor.prototype

// return true
```

**类型转换**

大家都知道 JS 中在使用运算符号或者对比符时，会自带隐式转换，规则如下:

* -、*、/、% ：一律转换成数值后计算
+：
  * 数字 + 字符串 = 字符串， 运算顺序是从左到右
  * 数字 + 对象， 优先调用对象的valueOf -> toString
  * 数字 + boolean/null = 数字
  * 数字 + undefined == NaN
* [1].toString() === '1'
* {}.toString() === '[object object]'
* NaN !== NaN 、+undefined === NaN

**类型判断**

判断 Target 的类型，单单用 typeof 并无法完全满足，这其实并不是 bug，本质原因是 JS 的万物皆对象的理论。因此要真正完美判断时，我们需要区分对待:

* 基本类型(null): 使用 String(null)
* 基本类型(string / number / boolean / undefined) + function: 直接使用 typeof即可
* 其余引用类型(Array / Date / RegExp Error): 调用toString后根据[object XXX]进行判断

很稳的判断封装:

```
let class2type = {}
'Array Date RegExp Object Error'.split(' ').forEach(e => class2type[ '[object ' + e + ']' ] = e.toLowerCase()) 

function type(obj) {
    if (obj == null) return String(obj)
    return typeof obj === 'object' ? class2type[ Object.prototype.toString.call(obj) ] || 'object' : typeof obj
}
```

**防抖 (debounce)**

将多次高频操作优化为只在最后一次执行，通常使用的场景是：用户输入，只需再输入完成后做一次输入校验即可。

```
function debounce(fn, wait, immediate) {
    let timer = null

    return function(...args) {
        let context = this
        if (immediate && !timer) {
          fn.apply(context, args);
        }

        if (timer) clearTimeout(timer)
        timer = setTimeout(() => {
            fn.apply(context, args);
            timer = null;
        }, wait)
    }
}
```

**节流(throttle)**

每隔一段时间后执行一次，也就是降低频率，将高频操作优化成低频操作，通常使用场景: 滚动条事件 或者 resize 事件，通常每隔 100~500 ms执行一次即可。

```
function throttle(fn, wait) {
    let timer = null
    
    return function(...args) {
        let context = this;
        if (!timer) {
            timer = setTimeout(() => {
                fn.apply(context, args)
                timer = null
            }, wait)
        }
    }
}
```

**函数执行改变this**

由于 JS 的设计原理: 在函数中，可以引用运行环境中的变量。因此就需要一个机制来让我们可以在函数体内部获取当前的运行环境，这便是this。

因此要明白 this 指向，其实就是要搞清楚 函数的运行环境，说人话就是，谁调用了函数。例如:

* obj.fn()，便是 obj 调用了函数，既函数中的 this === obj
* fn()，这里可以看成 window.fn()，因此 this === window

但这种机制并不完全能满足我们的业务需求，因此提供了三种方式可以手动修改 this 的指向:

* call: fn.call(target, 1, 2)
* apply: fn.apply(target, [1, 2])
* bind: fn.bind(target)(1,2)

**babel编译原理**

babylon 将 ES6/ES7 代码解析成 AST
babel-traverse 对 AST 进行遍历转译，得到新的 AST
新 AST 通过 babel-generator 转换成 ES5


**观察者模式  发布-订阅模式 的区别**

两者都是订阅-通知的模式，区别在于：
* 观察者模式：观察者和订阅者是互相知道彼此的，是一个紧耦合的设计
* 发布-订阅：观察者和订阅者是不知道彼此的，因为他们中间是通过一个订阅中心来交互的，订阅中心存储了多个订阅者，当有新的发布的时候，就会告知订阅者

设计模式的名词实在有点多且绕，我画个简单的图：

![](/img/localBlog/1585058756549.jpg)

**函数柯里化**

在一个函数中，首先填充几个参数，然后再**返回一个新的函数的技术**，称为函数的柯里化。**通常可用于在不侵入函数的前提下，为函数 预置通用参数，供多次重复调用**。

```
const add = function add(x) {
    return function (y) {
        return x + y
    }
}

const add1 = add(1)

add1(2) === 3
add1(20) === 21
```

**target与currentTarget区别**

currentTarget指的是事件触发后，冒泡到绑定处理程序的元素，就是绑定事件处理程序的元素，target指的是触发事件的元素。

**数组乱序**

```
var arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
arr.sort(function () {
    return Math.random() - 0.5;
});
```

**数组拆解**

```
flat: [1,[2,3]] --> [1, 2, 3]
arr.prototype.flat = function() {
    this.toString().split(',').map(item => +item )
}
```

**什么是尾递归？**

先给面试官简单说下什么是递归函数：函数内部循环调用自身的就是递归函数，若函数没有执行完毕，执行栈中会一直保持函数相关的变量，一直占用内存，当递归次数过大的时候，就可能会出现内存溢出，也叫爆栈，页面可能会卡死。

所以为了避免出现这种情况，可以采用尾递归。

尾递归：在函数的最后一步是调用函数，进入下一个函数不在需要上一个函数的环境了，内存空间 O(n) 到 O(1) 的优化 ，这就是尾递归。

尾递归的好处：可以释放外层函数的调用栈，较少栈层级，节省内存开销，避免内存溢出。

网上很多用斐波那契数列作为栗子，但我偏不，我用个数组累加的栗子

```
function add1(arr) {
    if (arr.length === 0) {
        return 0
    }
    return add1(arr.slice(1)) + arr[0] // 还有父级函数中 arr[0] 的引用
}

function add(arr, re) {
    if (arr.length === 0) {
        return re + 0
    } else {
        return add(arr.slice(1), arr[0] + re) // 仅仅是函数调用
    }
}

console.log(add([1, 2, 3, 4], 0))  // 10
console.log(add1([1, 2, 3, 4])) // 10
```

**接口怎么防刷？**

被人通过工具在短时间内恶意大量请求服务端。常用优化方式如下

* referer 校验 UA 校验
* 客户端和服务端约定签名算法，由服务端校验签名
* 服务端对请求 ip 单位时间内请求数量限制
* 通过前置交互式验证手段，先验证通过在接收请求

**事件委托是什么**

事件委托本质上是利用了浏览器事件冒泡的机制。因为事件在冒泡过程中会上传到父节点，并且父节点可以通过事件对象获取到目标节点，因此可以把子节点的监听函数定义在父节点上，由父节点的监听函数统一处理多个子元素的事件，这种方式称为事件代理。

* 使用事件代理我们可以不必要为每一个子元素都绑定一个监听事件，这样减少了内存上的消耗。
* 并且使用事件代理我们还可以实现事件的动态绑定，比如说新增了一个子节点，我们并不需要单独地为它添加一个监听事件，它所发生的事件会交给父元素中的监听函数来处理。

**谈一谈你理解的函数式编程？**

简单说，"函数式编程"是一种"编程范式"（programming paradigm），也就是如何编写程序的方法论。

它具有以下特性：闭包和高阶函数、惰性计算、递归、函数是"第一等公民"、只用"表达式"。

## 前端框架（ MVVM ）

**computed 为什么比 watch method 性能要好**

从编码上 computed 实现的功能也可以通过普通 method 实现，但与函数相比，计算属性是基于响应式依赖进行缓存的，只有在依赖的数据发生改变是，才重新进行计算，只要依赖项没有发生变化，多次访问都只是从缓存中获取。

computed 和 watch 主要区别在于使用场景，计算属性更适用于模板渲染，依赖其他对象值的变化，做重新计算在渲染，监听多个值来改变一个值。而监听属性 watch ，是用于监听某一个值的变化，进行一系列复杂的操作。监听属性可以支持异步，计算属性只能是同步。

**如何比较两个 DOM 树的差异？**

两个树的完全 diff 算法的时间复杂度为 O(n^3) ，但是在前端中，我们很少会跨层级的移动元素，所以我们只需要比较同一层级的元素进行比较，这样就可以将算法的时间复杂度降低为 O(n)。

算法首先会对新旧两棵树进行一个深度优先的遍历，这样每个节点都会有一个序号。在深度遍历的时候，每遍历到一个节点，我们就将这个节点和新的树中的节点进行比较，如果有差异，则将这个差异记录到一个对象中。

在对列表元素进行对比的时候，由于 TagName 是重复的，所以我们不能使用这个来对比。我们需要给每一个子节点加上一个 key，列表对比的时候使用 key 来进行比较，这样我们才能够复用老的 DOM 树上的节点。

**vue 中 key 的作用**

有两点用处：快速节点比对和节点唯一标识

* 利用快速节点比对

用作于 vnode 的唯一标识，便于更快更准确的在旧节点列表中查找节点。

在内部对两个节点进行比较的时候，会优先判断 key 是否一致，如下，如果 key 不一致，立马就可以得出结果。

* 列表节点唯一标识

列表循环 v-for="i in dataList" 会有提示我们需要加上 key ，因为循环后的 dom 节点的结构没特殊处理的话是相同的， key 的默认值是 undefined ，那么按照上面 sameVnode 的算法，新生成的 Vnode 与 旧的节点的比较结果就是相同的，vue会对这些节点尝试就地修改/复用相同类型元素的，这种模式是高效，但是这种模式会有副作用，比如节点是带有状态的，那么就会出现异常的bug，所以这种不写 key 的默认处理只适用于不依赖其他状态的列表。

* 利于节点高效查找

同一层vnode节点是以数组的方式存储，那么如果节点非常多，通过遍历查找就稍微有点慢，因此，内部将 vnode 列表转换成对象。这样一来，就可以直接通过 key 查找到数组下标，利于加快查找时间。

**虚拟dom 与直接操作 dom 相比哪个更快？**

以下是根据尤大在知乎的回答，做的总结：

* 首先是没有任何一个框架可以比纯手动优化操作 dom 快，因为框架的 dom 操作层需要应对上层API可能发生的操作，所以它的实现是普适性的，所以不可能对每个场景做优化，这就是个性能和可维护性的取舍。各大框架可以给到即使不需要手动优化，也可以提供较优秀的性能。

* 我们看看两者的重绘性能消耗：
  * innerHTML:  render html string O(template size) + 重新创建所有 DOM 元素 O(DOM size)
  * Virtual DOM: render Virtual DOM + diff O(template size) + 必要的 DOM 更新 O(DOM change) 
  render Virtual DOM + diff O 显然比渲染 html string 要慢，但我们知道，这是纯 js层面的计算相比， 与 DOM 层面的操作的开销相比要小很多。
所以直接操作dom的开销就和整个页面相关，而虚拟dom的开销就是 js层面的计算和计算后的 dom 的开销，所以虚拟dom就可以保证，不管页面数据变化多少，每次计算后的重绘的性能都在可接受范围内。


* 因为机制不一样，那么比较的时候就要看场合，比如是大量数据的更新还是小量数据的更新。举个例子，如果一个非常大的列表，数据全都发生了变化，那么直接操作dom肯定是更快的，那如果只是其中的几行发生了变化，直接全量替换dom的开销可就大了，而虚拟dom在计算后，只需要替换个别dom即可

* 虚拟dom提供给开发者的价值不是性能，而是 1.为函数式的UI编程打开大门 2.扩展性强，可以渲染到 DOM 意外的其他平台

* 那如果开发中遇到特殊的情况导致虚拟dom的更新效率不满足，那么可以牺牲一定的维护性来自己手动进行优化

**vue 可以定义函数式组件么**

函数式组件：没有状态(data)，没有生命周期，只接受传递的 props ,常用于纯 UI 组件，定义：

* 通过 Vue.component 构建组件时，添加 functional: true; 需要通过调用 render 函数来渲染，常用包裹组建或者构建高阶组件
* 对于单文件组件，在 template 上添加 `functional <template functional>`

**v-model 的实现**

常用于输入框的双向数据绑定，但我知道 vue 是单向数据流的，所以 v-model 其实是个封装的指令，本质是对 input 的 @input 事件做了封装，如下代码：

```
<input @input="change" :obj="obj">
change(e) {
    this.obj = e.target.value;
}
```

复制代码也可以在自定义组件上使用，简化编码，逻辑更加清晰

**vue 有几种构建版本**

* 有生成版本和开发版本的区分；
* 完整版和运行时版本的区分，完整版包含编译器（用于生成渲染函数）；
* 构建环境的区分，支持 UMD(AMD和commonjs)、commonjs、ES Module(用于构建工具的)、ES Module(用于浏览器的)

**vuex中为什么把把异步操作封装在action，把同步操作放在mutations？**

mutations 同步主要是为了能用 devtools 跟踪状态的变化，每次执行完后，就可以立即得到下一个状态，这样在devtools调试工具中，就可以跟踪到状态的每一次变化，可以做时间旅行 time-travel ，那么如果是异步的话，就没法知道状态什么时候被更新，所以就有了一个 actions 用来专门处理异步函数，但要求状态的需要触发 mutations ,这样一来对于异步的更新也可以清晰看到状态的流转。

**vuex getter方法跟直接 state 中获取有什么区别**

getter 类似于计算属性，带有缓存；当只有响应的属性发生变化才会更新缓存，相比直接获取效率更好，在设计上可以便于抽象逻辑。

**vue-router 中的 link 跳转和 a 链接跳转的区别**

* 判断是否有 onclick 事件，有就执行
阻止默认事件
* 使用 history.replace 或 history.push 修改地址栏，同时不触发页面刷新

**webpack 中的 loader 和 plugin 是干什么的**

* loader：对文件进行转换，比如说将 ts 编译成 js ,css预处理等等
* plugin：通过监听 webpack 运行中的广播事件，从而进行自己的操作，如常用的 HtmlWebpackPlugin：创建html文件、webpack.optimize.UglifyJsPlugin：混淆压缩

**webpack 的 externals**

防止将外部引用的包打包到 bundle 中，而是在运行时通过模块化的方式从外部引用。
比如我们通过cdn引用 jquery ，我们不希望jq打包到 bundle 中，而且在使用时希望能通过模块化的方式引用，那么可以如下配置

```
module.exports = {
  //...
  externals: {
    jquery: 'jQuery'
  }
};
```

前端路由的实现原理
nextTick / setState 的实现原理
diff 算法
单页面应用（SPA）的原理和优缺点
Vue 组件间通信性能优化

## 浏览器 & 网络

**从输入 url 到展示的过程**

* DNS 解析
* TCP 三次握手
* 发送请求，分析 url，设置请求报文(头，主体)
* 服务器返回请求的文件 (html)
* 浏览器渲染
  * HTML parser --> DOM Tree
  标记化算法，进行元素状态的标记
  dom 树构建
  * CSS parser --> Style Tree
  解析 css 代码，生成样式树
  * attachment --> Render Tree
  结合 dom树 与 style树，生成渲染树
  * layout: 布局
  * GPU painting: 像素绘制页面

**Web Worker**

现代浏览器为JavaScript创造的 多线程环境。可以新建并将部分任务分配到worker线程并行运行，两个线程可 独立运行，互不干扰，可通过自带的 消息机制 相互通信。

基本用法:

```
// 创建 worker
const worker = new Worker('work.js');

// 向主进程推送消息
worker.postMessage('Hello World');

// 监听主进程来的消息
worker.onmessage = function (event) {
  console.log('Received message ' + event.data);
}
```

限制:

* 同源限制
* 无法使用 document / window / alert / confirm
* 无法加载本地资源


**V8垃圾回收机制**

垃圾回收: 将内存中不再使用的数据进行清理，释放出内存空间。V8 将内存分成 新生代空间 和 老生代空间。

新生代空间: 用于存活较短的对象
* 又分成两个空间: from 空间 与 to 空间
* Scavenge GC算法: 当 from 空间被占满时，启动 GC 算法
* 存活的对象从 from space 转移到 to space
* 清空 from space
* from space 与 to space 互换
* 完成一次新生代GC

老生代空间: 用于存活时间较长的对象
* 从 新生代空间 转移到 老生代空间 的条件
  * 经历过一次以上 Scavenge GC 的对象
  * 当 to space 体积超过25%
* 标记清除算法: 标记存活的对象，未被标记的则被释放
  * 增量标记: 小模块标记，在代码执行间隙执，GC 会影响性能
  * 并发标记(最新技术): 不阻塞 js 执行
* 压缩算法: 将内存中清除后导致的碎片化对象往内存堆的一端移动，解决 内存的碎片化

**内存泄露**

* 意外的全局变量: 无法被回收
* 定时器: 未被正确关闭，导致所引用的外部变量无法被释放
* 事件监听: 没有正确销毁 (低版本浏览器可能出现)
* 闭包: 会导致父级中的变量无法被释放
* dom 引用: dom 元素被删除时，内存中的引用未被正确清空

可用 chrome 中的 timeline 进行内存标记，可视化查看内存的变化情况，找出异常点。

**线程和进程分别是什么**

首先来一句话概括：进程和线程都是一个时间段的描述，都是对CPU工作时间段的描述。

当一个任务得到 CPU 资源后，需要加载执行这个任务所需要的执行环境，也叫上下文，进程就是包含上下文切换的程序执行时间总和 = CPU加载上下文 + CPU执行 + CPU保存上下文。可见进程的颗粒度太大，每次都需要上下文的调入，保存，调出。

如果我们把进程比喻为一个运行在电脑上的软件，那么一个软件的执行不可能是一条逻辑执行的，必定有多个分支和多个程序段，就好比要实现程序A，实际分成 a，b，c等多个块组合而成。

那么这里具体的执行就是：程序A得到CPU => CPU加载上下文 => 开始执行程序A的a小段 => 然后执行A的b小段 => 然后再执行A的c小段 => 最后CPU保存A的上下文。这里a，b，c 的执行共享了A的上下文，CPU在执行的时候没有进行上下文切换的。

a，b，c 我们就是称为线程，就是说线程是共享了进程的上下文环境，是更为细小的 CPU 执行时间段。

![](/img/localBlog/1585059037296.jpg)

**get 请求传参长度的误区**

误区：我们经常说 get 请求参数的大小存在限制，而 post 请求的参数大小是无限制的。

实际上 HTTP 协议从未规定 GET/POST 的请求长度限制是多少。对 get 请求参数的限制是来源与浏览器或web 服务器，浏览器
或 web 服务器限制了 url 的长度。为了明确这个概念，我们必须再次强调下面几点:

（1）HTTP 协议未规定 GET 和 POST 的长度限制
（2）GET 的最大长度显示是因为浏览器和 web 服务器限制了 URI 的长度
（3）不同的浏览器和 WEB 服务器，限制的最大长度不一样
（4）要支持 IE，则最大长度为 2083byte，若只支持 Chrome，则最大长度 8182byte

**http/https 协议**

1.0 协议缺陷:
* 无法复用链接，完成即断开，重新慢启动和 TCP 3次握手
* head of line blocking: 线头阻塞，导致请求之间互相影响

1.1 改进:
* 长连接(默认 keep-alive)，复用
* host 字段指定对应的虚拟站点
* 新增功能:
  * 断点续传
  * 身份认证
  * 状态管理
  * cache 缓存
    * Cache-Control
    * Expires
    * Last-Modified
    * Etag

2.0:
* 多路复用
* 二进制分帧层: 应用层和传输层之间
* 首部压缩
* 服务端推送

https: 较为安全的网络传输协议
* 证书(公钥)
* SSL 加密
* 端口 443

TCP:
* 三次握手
* 四次挥手
* 滑动窗口: 流量控制
* 拥塞处理
  * 慢开始
  * 拥塞避免
  * 快速重传
  * 快速恢复

缓存策略: 可分为 强缓存 和 协商缓存

* Cache-Control/Expires: 浏览器判断缓存是否过期，未过期时，直接使用强缓存，Cache-Control的 max-age 优先级高于 Expires
* 当缓存已经过期时，使用协商缓存

* 唯一标识方案: Etag(response 携带) & If-None-Match(request携带，上一次返回的 Etag): 服务器判断资源是否被修改，
* 最后一次修改时间: Last-Modified(response) & If-Modified-Since (request，上一次返回的Last-Modified)
  * 如果一致，则直接返回 304 通知浏览器使用缓存
  * 如不一致，则服务端返回新的资源
* Last-Modified 缺点：
  * 周期性修改，但内容未变时，会导致缓存失效
  * 最小粒度只到 s， s 以内的改动无法检测到
* Etag 的优先级高于 Last-Modified


**常见状态码**

* 1xx: 接受，继续处理
* 200: 成功，并返回数据
* 201: 已创建
* 202: 已接受
* 203: 成为，但未授权
* 204: 成功，无内容
* 205: 成功，重置内容
* 206: 成功，部分内容
* 301: 永久移动，重定向
* 302: 临时移动，可使用原有URI
* 304: 资源未修改，可使用缓存
* 305: 需代理访问
* 400: 请求语法错误
* 401: 要求身份认证
* 403: 拒绝请求
* 404: 资源不存在
* 500: 服务器错误

**Websocket**

Websocket 是一个 持久化的协议， 基于 http ， 服务端可以 主动 push

兼容：

* 长轮询： 定时发送 ajax
* long poll： 发送 --> 有消息时再 response

**TCP三次握手**

建立连接前，客户端和服务端需要通过握手来确认对方:

* 客户端发送 syn(同步序列编号) 请求，进入 syn_send 状态，等待确认
* 服务端接收并确认 syn 包后发送 syn+ack 包，进入 syn_recv 状态
* 客户端接收 syn+ack 包后，发送 ack 包，双方进入 established 状态

**TCP四次挥手**

* 客户端 -- FIN --> 服务端， FIN—WAIT
* 服务端 -- ACK --> 客户端， CLOSE-WAIT
* 服务端 -- ACK,FIN --> 客户端， LAST-ACK
* 客户端 -- ACK --> 服务端，CLOSED

**dns解析**

解析顺序

* 浏览器缓存
当用户通过浏览器访问某域名时，浏览器首先会在自己的缓存中查找是否有该域名对应的IP地址（若曾经访问过该域名且没有清空缓存便存在）；

* 系统缓存
当浏览器缓存中无域名对应IP则会自动检查用户计算机系统Hosts文件DNS缓存是否有该域名对应IP；

* 路由器缓存
当浏览器及系统缓存中均无域名对应IP则进入路由器缓存中检查，以上三步均为客服端的DNS缓存；

* ISP（互联网服务提供商）DNS缓存
当在用户客服端查找不到域名对应IP地址，则将进入ISP DNS缓存中进行查询。比如你用的是电信的网络，则会进入电信的DNS缓存服务器中进行查找；

* 根域名服务器
当以上均未完成，则进入根服务器进行查询。全球仅有13台根域名服务器，1个主根域名服务器，其余12为辅根域名服务器。根域名收到请求后会查看区域文件记录，若无则将其管辖范围内顶级域名（如`.com`）服务器IP告诉本地DNS服务器；

* 顶级域名服务器
顶级域名服务器收到请求后查看区域文件记录，若无则将其管辖范围内主域名服务器的IP地址告诉本地DNS服务器；

* 主域名服务器
主域名服务器接受到请求后查询自己的缓存，如果没有则进入下一级域名服务器进行查找，并重复该步骤直至找到正确纪录；

* 保存结果至缓存
本地域名服务器把返回的结果保存到缓存，以备下一次使用，同时将该结果反馈给客户端，客户端通过这个IP地址与web服务器建立链接。

TCP/ip参数中设置的首选DNS服务器，在此我们叫它本地DNS服务器。

从客户端到本地DNS服务器是属于递归查询，而DNS服务器之间就是的交互查询就是迭代查询。

**SSRF**

简介

SSRF（Server-Side Request Forgery），服务端请求伪造。

攻击利用了可访问Web服务器（A）的特定功能构造恶意payload；攻击者在访问A时，利用A的特定功能构造特殊payload，由A发起对内部网络中系统B（内网隔离，外部不可访问）的请求，从而获取敏感信息。此时A被作为中间人（跳板）进行利用。

SSRF漏洞原因，主要是由于服务端提供了从其他服务器获取数据的功能，但未对目标地址进行过滤和校验。

常见业务场景（功能点）：

* 分享，通过URL地址分享网页内容，通过URL获取目标页标签等内容
* 转码服务，适配手机屏幕大小，通过URL地址进行图片转码
* 图片加载与下载，通过URL加载网络图片（头像上传、等）
* 图片、文章收藏，通过URL获取目标的title等信息
* 其他加载URL的功能
* XXE漏洞点

漏洞利用

* 内网探测（端口、服务、指纹信息）
* 文件读取（敏感信息）
* 内网应用攻击、反弹Shell（特定环境）

防御

* 白名单过滤及DNS解析

优先考虑白名单方式验证，过滤应用需要的域名及IP。

白名单不能满足需求时考虑黑名单方式，例如禁止请求私有IP地址。黑名单容易存在过滤不全的问题。

* 响应处理

对服务器响应内容进行处理（验证是否为预期响应内容），任何情况下都不建议直接返回服务器响应内容给客户端。

* 禁用不必要的URL协议

这个不用多说，主要就是通过file、http等协议进行利用，如果不是必要的建议直接禁用。

* 内部服务认证

基于不可信原则，内网服务需进行认证鉴权。

**灰度发布**

在灰度发布开始后，先启动一个新版本应用，但是并不直接将流量切过来，而是测试人员对新版本进行线上测试，启动的这个新版本应用，就是我们的金丝雀。如果没有问题，那么可以将少量的用户流量导入到新版本上，然后再对新版本做运行状态观察，收集各种运行时数据，如果此时对新旧版本做各种数据对比，就是所谓的A/B测试。

当确认新版本运行良好后，再逐步将更多的流量导入到新版本上，在此期间，还可以不断地调整新旧两个版本的运行的服务器副本数量，以使得新版本能够承受越来越大的流量压力。直到将100%的流量都切换到新版本上，最后关闭剩下的老版本服务，完成灰度发布。

如果在灰度发布过程中（灰度期）发现了新版本有问题，就应该立即将流量切回老版本上，这样，就会将负面影响控制在最小范围内。

在新版本应用发布时，为了服务器不停机升级，使用灰度发布策略，在灰度发布开始时，使用HTTP Header 匹配指定测试人员的流量到新版本上，然后当新版本内部测试通过后，可以再按百分比，将用户流量一点一点导入到新版本中，比如先导入10%观察一下运行情况，然后再导入20%，如此累加，直到将流量全部导入到新版本上，最后完成升级，如果期间发现问题，就立即取消升级，将流量切回到老版本。

运用灰度发布，就再也不需要加班到深夜进行停机升级了，在白天就可以放心大胆地、安全地发布新版本。

## 数据结构和算法

**特别大的数据量，实现查找，排序**

1）位图法

使用场景举例：对2G的数据量进行排序，这是基本要求。
数据：1、每个数据不大于8亿；2、数据类型位int；3、每个数据最多重复一次。

内存：最多用200M的内存进行操作。

首先对占用的内存进行判断，每个数据不大于8亿，那么8亿是一个什么概念呢。

```
1 byte = 8 bit（位）
1024 byte = 8*1024 bit = 1k
1024 k = 8*1024*1024 bit = 1M = 8388608 bit
```

也就是1M=8388608位

而位图法的基本思想就是利用一位代表一个数字，例如3位上为1,则说明3在数据中出现过，若为0，则说明3在数据中没有出现过。所以当题目中出现每个数据最多重复一次这个条件时，我们可以考虑使用位图法来进行大数据排序。

那么假如使用位图法来进行这题的排序，内存占用多少呢。由题目知道每个数据不大于8亿，那么我们就需要8亿位，占用800000000/8388608=95M的空间，满足最多使用200M内存进行操作的条件，这也是这题能够使用位图法来解决的一个基础。

2）堆排序法

堆排序是4种平均时间复杂度为nlogn的排序方法之一，其优点在于当求M个数中的前n个最大数，和最小数的时候性能极好。所以当从海量数据中要找出前m个最大值或最小值，而对其他值没有要求时，使用堆排序法效果很好。

使用场景：从1亿个整数里找出100个最大的数

步骤：

（1）读取前100个数字，建立最大值堆。（这里采用堆排序将空间复杂度讲得很低，要排序1亿个数，但一次性只需读取100个数字，或者设置其他基数，不需要1次性读完所有数据，降低对内存要求）

（2）依次读取余下的数，与最大值堆作比较，维持最大值堆。可以每次读取的数量为一个磁盘页面，将每个页面的数据依次进堆比较，这样节省IO时间。

（3）将堆进行排序，即可得到100个有序最大值。

堆排序是一种常见的算法，但了解其的使用场景能够帮助我们更好的理解它。

3）较为通用的分治策略

分治策略师对常见复杂问题的一种万能的解决方法，虽然很多情况下，分治策略的解法都不是最优解，但是其通用性很强。分治法的核心就是将一个复杂的问题通过分解抽象成若干个简单的问题。

应用场景：10G的数据，在2G内存的单台机器上排序的算法

我的想法，这个场景既没有介绍数据是否有重复，也没有给出数据的范围，也不是求最大的个数。而通过分治虽然可能需要的io次数很多，但是对解决这个问题还是具有一定的可行性的。

步骤：

（1）从大数据中抽取样本，将需要排序的数据切分为多个样本数大致相等的区间，例如：1-100，101-300…

（2）将大数据文件切分为多个小数据文件，这里要考虑IO次数和硬件资源问题，例如可将小数据文件数设定为1G（要预留内存给执行时的程序使用）

（3）使用最优的算法对小数据文件的数据进行排序，将排序结果按照步骤1划分的区间进行存储

（4）对各个数据区间内的排序结果文件进行处理，最终每个区间得到一个排序结果的文件

（5）将各个区间的排序结果合并。通过分治将大数据变成小数据进行处理，再合并。

## 开放性题目

你的优点
你的缺点
最近在看什么书? 怎么学习的前端知识? 保持自我学习?
为什么要从事前端?
为什么离职？
你的职业规划
有什么问题问我的吗？
最近项目解决的一个技术难点，即项目中遇到了哪些坑？怎样解决的？
最近做的最成功的一次分享是什么
说一件你做的最酷的事情是什么
怎样理解前端工程化？
前端发展趋势？
框架选型依据？
所在团队工作流程的介绍、以及你在团队中的定位和技术排名

你为什么选择我们公司？

你有什么想问我的？

为什么做这个系统？这个系统的价值是什么？

这个系统有哪些功能？

机器人对话，人工客服实时通讯，im 通用功能模块（工单、留言、现场会话监控）

优缺点有哪些？

如果让你重新设计这个系统你会如何设计？

明确你的项目的整体架构，在面试的时候能够清楚地画给面试官看并且清楚地指出从哪里调用到哪里、使用什么方式调用?

明确你的模块在整个项目中所处的位置及作用?

明确你的模块用到了哪些技术，更好一些的可以再了解一下整个项目用到了哪些技术?

谈一下你在项目中解决过的比较复杂的问题?

讲一个项目，项目的难点在哪，你对项目有什么贡献
整体架构：客户端、通讯服务、数据服务、node(bff)层
有挑战性的事：代码整体的优化重构：分层、模块化
目的：1，提效、提质2，外包交接效率

为什么离职
1，尝试一些新的技术
2，接触一些新的业务
3，拓宽自己的视野

为什么裸辞
1，有一个比较充足的时间对掌握的知识进行回顾、整理，构建自己的知识体系

优点
1，爱学习爱看书
2，有毅力

缺点
1，不习惯严厉的批评别人

js

http://www.cnblogs.com/TomXu/archive/2011/12/15/2288411.html

设计模式：

https://juejin.im/post/5a6dd4dd51882573385ffa8e

https://juejin.im/post/5a77211b6fb9a0635774d61a
