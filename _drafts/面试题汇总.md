# 面试题汇总

## HTML

HTML 语义化，HTML 语义化的优点很多，比如清晰的页面结构、有利于 SEO、便于团队开发和维护
canvas
本地存储（ localStorage、sessionStorage、cookie 的理解 ）

## CSS

**CSS选择器的优先级**

* !important
* 内联样式（1000）
* ID选择器（0100）
* 类选择器/属性选择器/伪类选择器（0010）
* 元素选择器/关系选择器/伪元素选择器（0001）
* 通配符选择器（0000）

伪类选择器：
* :link 未访问
* :visited 已访问
* :hover 鼠标悬停
* :active 鼠标按下
* :not(s) 匹配不含s选择器的元素
* :frist-child 父元素的第一个元素
* :last-child 父元素的最后一个元素
* :only-child 父元素的唯一一个元素
* :checked 选中 :checked+伪元素

关系选择器包含：
* 包含选择器（A B）：如ul li{}
* 子选择器（A>B）
* 相邻选择器（A+B）
* 兄弟选择器（A~B）：注意对它后面的元素起作用

伪元素选择器(content属性)：
* ::before
* ::after

**盒模型**

页面渲染时，dom 元素所采用的布局模型。可通过box-sizing进行设置。根据计算宽高的区域可分为：

* content-box (W3C 标准盒模型)
* border-box (IE 盒模型)
* padding-box
* margin-box

![](/img/localBlog/1584951498782.jpg)

box-sizing: content-box（W3C盒子模型）：元素的宽高大小表现为内容的大小。
box-sizing: border-box（IE盒子模型）：元素的宽高表现为内容 + 内边距 + 边框的大小。背景会延伸到边框的外沿。

IE5.x和IE6在怪异模式中使用非标准的盒子模型，这些浏览器的width属性不是内容的宽度，而是内容、内边距和边框的宽度的总和。

**什么是BFC**

BFC 全称为块级格式化上下文 (Block Formatting Context) 。BFC是 W3C CSS 2.1 规范中的一个概念，它决定了元素如何对其内容进行定位以及与其他元素的关系和相互作用，当涉及到可视化布局的时候，Block Formatting Context提供了一个环境，HTML元素在这个环境中按照一定规则进行布局。一个环境中的元素不会影响到其它环境中的布局。比如浮动元素会形成BFC，浮动元素内部子元素的主要受该浮动元素影响，两个浮动元素之间是互不影响的。这里有点类似一个BFC就是一个独立的行政单位的意思。可以说**BFC就是一个作用范围，把它理解成是一个独立的容器，并且这个容器里box的布局与这个容器外的box毫不相干**。

触发BFC的条件：

* 根元素或其它包含它的元素
* 浮动元素 (元素的 float 不是 none)
* 绝对定位元素 (元素具有 position 为 absolute 或 fixed)
* 内联块 (元素具有 display: inline-block)
* 表格单元格 (元素具有 display: table-cell，HTML表格单元格默认属性)
* 表格标题 (元素具有 display: table-caption, HTML表格标题默认属性)
* 具有overflow 且值不是 visible 的块元素
* 弹性盒（flex或inline-flex）
* display: flow-root
* column-span: all

BFC的约束规则：

* 内部的盒会在垂直方向一个接一个排列（可以看作BFC中有一个的常规流）
* 处于同一个BFC中的元素相互影响，可能会发生外边距重叠
* 每个元素的margin box的左边，与容器块border box的左边相接触(对于从左往右的格式化，否则相反)，即使存在浮动也是如此
* BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素，反之亦然
* 计算BFC的高度时，考虑BFC所包含的所有元素，连浮动元素也参与计算
* 浮动盒区域不叠加到BFC上

BFC可以解决的问题：

* 垂直外边距重叠问题
* 去除浮动
* 自适用两列布局（float + overflow）

**层叠上下文**

元素提升为一个比较特殊的图层，在三维空间中 (z轴) 高出普通元素一等。

触发条件

* 根层叠上下文(html)
* position
* css3属性
  flex
  transform
  opacity
  filter
  will-change
  -webkit-overflow-scrolling

层叠等级：层叠上下文在z轴上的排序

![](/img/localBlog/1584965585320.jpg)

* 在同一层叠上下文中，层叠等级才有意义
* z-index的优先级最高

**居中布局**

水平居中

* 行内元素: text-align: center
* 块级元素: margin: 0 auto
* absolute + transform
* flex + justify-content: center

垂直居中

* line-height: height
* absolute + transform
* flex + align-items: center
* table

水平垂直居中

* absolute + transform
* flex + justify-content + align-items

**伪类和伪元素的区别**

伪类用于当已有元素处于的某个状态时，为其添加对应的样式，这个状态是根据用户行为而动态变化的。比如说，当用户悬停在指定的元素时，我们可以通过:hover来描述这个元素的状态。虽然它和普通的css类相似，可以为已有的元素添加样式，但是它只有处于dom树无法描述的状态下才能为元素添加样式，所以将其称为伪类。

伪元素用于创建一些不在文档树中的元素，并为其添加样式。比如说，我们可以通过:before来在一个元素前增加一些文本，并为这些文本添加样式。虽然用户可以看到这些文本，但是这些文本实际上不在文档树中。
区别

伪类的操作对象是文档树中已有的元素，而伪元素则创建了一个文档树外的元素。因此，**伪类与伪元素的区别在于：有没有创建一个文档树之外的元素**。

CSS3规范中的要求使用双冒号`(::)`表示伪元素，以此来区分伪元素和伪类，比如::before和::after等伪元素使用双冒号`(::)`，:hover和:active等伪类使用单冒号`(:)`。除了一些低于IE8版本的浏览器外，大部分浏览器都支持伪元素的双冒号`(::)`表示方法。

**Flex 布局**

布局的传统解决方案，基于盒状模型，依赖 display 属性 + position属性 + float属性。它对于那些特殊布局非常不方便，比如，垂直居中就不容易实现。

Flex 是 Flexible Box 的缩写，意为"**弹性布局**"，用来为盒状模型提供最大的灵活性。

**采用 Flex 布局的元素，称为 Flex 容器（flex container），简称"容器"。它的所有子元素自动成为容器成员，称为 Flex 项目（flex item），简称"项目"**。

容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis）。主轴的开始位置（与边框的交叉点）叫做main start，结束位置叫做main end；交叉轴的开始位置叫做cross start，结束位置叫做cross end。

项目默认沿主轴排列。单个项目占据的主轴空间叫做main size，占据的交叉轴空间叫做cross size。

以下6个属性设置在容器上：

* flex-direction
* flex-wrap
* flex-flow
* justify-content
* align-items
* align-content

以下6个属性设置在项目上：

* order
* flex-grow
* flex-shrink
* flex-basis
* flex
* align-self

**CSS 中解决浮动中高度塌陷的方案有哪些？**

* 通过增加尾元素清除浮动
`:after / <br> : clear: both`
* 创建父级 BFC
* 父级设置高度

**Flex 如何实现上下两行，上行高度自适应，下行高度 200px？**

flex-direction: column
flex: 1

**link 与 @import 的区别**

* link功能较多，可以定义 RSS，定义 Rel 等作用，而@import只能用于加载 css
* 当解析到link时，页面会同步加载所引的 css，而@import所引用的 css 会等到页面加载完才被加载
* @import需要 IE5 以上才能使用
* link可以使用 js 动态引入，@import不行

## JavaScript

**打乱数组**

```
function shuffle(arr) {
  let i = arr.length;
  while (i) {
    let j = Math.floor(Math.random() * i--);
    [arr[j], arr[i]] = [arr[i], arr[j]];
  }
}
```

**ajax**

```
//步骤一:创建异步对象
var ajax = new XMLHttpRequest();

//步骤二:设置请求的url参数,参数一是请求的类型,参数二是请求的url,可以带参数,动态的传递参数starName到服务端
ajax.open('get','getStar.php?starName='+name);

//步骤三:发送请求
ajax.send();

//步骤四:注册事件 onreadystatechange 状态改变就会调用
ajax.onreadystatechange = function () {
  if (ajax.readyState==4 && ajax.status==200) {
    //步骤五 如果能够进到这个判断说明数据完美的回来了,并且请求的页面是存在的
    console.log(ajax.responseText);
  }
}
```

**bind 实现**

```
if (!Function.prototype.bind) {
  Function.prototype.bind = function (...args) {
    const self = this;
    const context = args.shift();
    return function (...curArgs) {
      return self.apply(context, [...args, ...curArgs]);
    }
  }
}
```

**eventBus实现**

```
class EventBus {
  constructor() {
    this.event = Object.create(null);
  };
  on(name, fn) {
    if(!this.event[name]) {
      this.event[name] = [];
    };
    this.event[name].push(fn);
  };
  emit(name, ...args) {
    this.event[name] && this.event[name].forEach(fn => {
      fn(...args)
    });
  };
  once(name, fn) {
    const cb = (...args) => {
      fn.apply(this, args);
      this.off(name, fn);
    };
    this.on(name, cb);
  };
  off(name, offcb) {
    if(this.event[name]){
      let index = this.event[name].findIndex((fn) => {
        return offcb === fn;
      })
      if (index >= 0) {
        this.event[name].splice(index, 1);
      }
    }
  }
}
```

**JSONP**

```
var script = document.createElement('script');
script.type = 'text/javascript';

// 传参并指定回调执行函数为onBack
script.src = 'http://www.domain-com:8080/login?user=admin&callback=onBack';
document.head.appendChild(script);

// 回调执行函数
function onBack(res) {
  alert(JSON.stringify(res));
}
```

**ES5 和 ES6 继承的区别**

* ES5 的继承使用借助构造函数实现，实质是先创造子类的实例对象this，然后再将父类的方法添加到this上面。ES6 的继承机制完全不同，实质是先创造父类的实例对象this（所以必须先调用super方法），然后再用子类的构造函数修改this。

* ES6 在继承的语法上不仅继承了类的原型对象，还继承了类的静态属性和静态方法

**执行上下文(EC)**

执行上下文可以简单理解为一个对象:

它包含三个部分:

* 变量对象(VO)
* 作用域链(词法作用域)
* this指向

它的类型:

* 全局执行上下文
* 函数执行上下文
* eval执行上下文

代码执行过程:

* 创建 全局上下文 (global EC)
* 全局执行上下文 (caller) 逐行 自上而下 执行。遇到函数时，函数执行上下文 (callee) 被push到执行栈顶层
* 函数执行上下文被激活，成为 active EC, 开始执行函数中的代码，caller 被挂起
* 函数执行完后，callee 被pop移除出执行栈，控制权交还全局上下文 (caller)，继续执行

**变量对象**

变量对象，是执行上下文中的一部分，可以抽象为一种 数据作用域，其实也可以理解为就是一个简单的对象，它存储着该执行上下文中的所有 变量和函数声明(不包含函数表达式)。

活动对象 (AO): 当变量对象所处的上下文为 active EC 时，称为活动对象。

**作用域链**

我们知道，我们可以在执行上下文中访问到父级甚至全局的变量，这便是作用域链的功劳。作用域链可以理解为一组对象列表，包含 父级和自身的变量对象，因此我们便能通过作用域链访问到父级里声明的变量或者函数。

由两部分组成:

* `[[scope]]`属性: 指向父级变量对象和作用域链，也就是包含了父级的`[[scope]]`和AO
* AO: 自身活动对象

如此 `[[scopr]]`包含`[[scope]]`，便自上而下形成一条 链式作用域。

**闭包**

闭包属于一种特殊的作用域，称为 静态作用域。它的定义可以理解为: 父函数被销毁 的情况下，返回出的子函数的`[[scope]]`中仍然保留着父级的单变量对象和作用域链，因此可以继续访问到父级的变量对象，这样的函数称为闭包。

闭包会产生一个很经典的问题:

多个子函数的`[[scope]]`都是同时指向父级，是完全共享的。因此当父级的变量对象被修改时，所有子函数都受到影响。

解决:

* 变量可以通过 函数参数的形式 传入，避免使用默认的`[[scope]]`向上查找
* 使用setTimeout包裹，通过第三个参数传入
* 使用 块级作用域，让变量成为自己上下文的属性，避免共享

**script 引入方式**

* html 静态`<script>`引入
* js 动态插入`<script>`
* `<script defer>`: 异步加载，元素解析完成后执行
* `<script async>`: 异步加载，与元素渲染并行执行

## 前端框架（ MVVM ）

响应式的基本原理是什么
发布订阅模式的理解
Virtual DOM 的理解
前端路由的实现原理
nextTick / setState 的实现原理
diff 算法
单页面应用（SPA）的原理和优缺点
vue 具体的双向数据绑定，具体实现
key 的作用
Vue 组件间通信性能优化

## 浏览器 & 计算机基础

浏览器缓存机制
浏览器中 JavaScript 的执行机制
页面渲染原理
浏览器安全问题
浏览器为什么会跨域
如何系统的优化页面
HTTP 与 HTTPS 的区别
TCP/IP 协议
三次握手和四次挥手
CDN 的作用和原理
正向代理与反向代理的特点

## 前端工程化

如何进行高效的多人协作？
如何保证项目的可维护性？
如何提高项目的开发质量？
如何降低项目生产的风险？

前端工程化细分的话我觉得可以分成模块化、组件化、规范化三个方向。或者说一切能提升前端开发效率，提高前端应用质量的手段和工具都是前端工程化的实践。

模块化
JavaScript 模块化
CSS 模块化
资源模块化

组件化
从 UI 拆分下来的每个包含模板(HTML)+样式(CSS)+逻辑(JS)功能完备的结构单元，我们称之为组件。
也就是将复杂页面按功能拆分成多个独立的组件。

规范化
编码规范
接口规范
git 使用规范
CodeReview
UI 元素规范

理解 Babel、ESLint、webpack 等工具在项目中的作用
Babel 的核心原理
Webpack 的编译原理、构建流程、热更新原理
nginx 的基本理解
理解 Git 的工作流程
Mock 的意义及优点

## 性能优化

前端性能衡量指标、性能监控（performance,LightHouse）
常见的性能优化方案有哪些
SSR 方案的性能优化
Webpack 的性能优化方案
React、Vue 等框架使用性能优化方案
网络层面的优化方案
页面渲染层面的优化方案
白屏的优化方案

## 数据结构和算法

## 开放性题目

你的优点
你的缺点
最近在看什么书? 怎么学习的前端知识? 保持自我学习?
为什么要从事前端?
为什么离职？
你的职业规划
有什么问题问我的吗？
最近项目解决的一个技术难点，即项目中遇到了哪些坑？怎样解决的？
最近做的最成功的一次分享是什么
说一件你做的最酷的事情是什么
怎样理解前端工程化？
前端发展趋势？
框架选型依据？
所在团队工作流程的介绍、以及你在团队中的定位和技术排名