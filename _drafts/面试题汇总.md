# 面试题汇总

## HTML

HTML 语义化，HTML 语义化的优点很多，比如清晰的页面结构、有利于 SEO、便于团队开发和维护
canvas
本地存储（ localStorage、sessionStorage、cookie 的理解 ）

## CSS

**CSS选择器的优先级**

* !important
* 内联样式（1000）
* ID选择器（0100）
* 类选择器/属性选择器/伪类选择器（0010）
* 元素选择器/关系选择器/伪元素选择器（0001）
* 通配符选择器（0000）

伪类选择器：
* :link 未访问
* :visited 已访问
* :hover 鼠标悬停
* :active 鼠标按下
* :not(s) 匹配不含s选择器的元素
* :frist-child 父元素的第一个元素
* :last-child 父元素的最后一个元素
* :only-child 父元素的唯一一个元素
* :checked 选中 :checked+伪元素

关系选择器包含：
* 包含选择器（A B）：如ul li{}
* 子选择器（A>B）
* 相邻选择器（A+B）
* 兄弟选择器（A~B）：注意对它后面的元素起作用

伪元素选择器(content属性)：
* ::before
* ::after

**盒模型**

页面渲染时，dom 元素所采用的布局模型。可通过box-sizing进行设置。根据计算宽高的区域可分为：

* content-box (W3C 标准盒模型)
* border-box (IE 盒模型)
* padding-box
* margin-box

![](/img/localBlog/1584951498782.jpg)

box-sizing: content-box（W3C盒子模型）：元素的宽高大小表现为内容的大小。
box-sizing: border-box（IE盒子模型）：元素的宽高表现为内容 + 内边距 + 边框的大小。背景会延伸到边框的外沿。

IE5.x和IE6在怪异模式中使用非标准的盒子模型，这些浏览器的width属性不是内容的宽度，而是内容、内边距和边框的宽度的总和。

**什么是BFC**

BFC 全称为块级格式化上下文 (Block Formatting Context) 。BFC是 W3C CSS 2.1 规范中的一个概念，它决定了元素如何对其内容进行定位以及与其他元素的关系和相互作用，当涉及到可视化布局的时候，Block Formatting Context提供了一个环境，HTML元素在这个环境中按照一定规则进行布局。一个环境中的元素不会影响到其它环境中的布局。比如浮动元素会形成BFC，浮动元素内部子元素的主要受该浮动元素影响，两个浮动元素之间是互不影响的。这里有点类似一个BFC就是一个独立的行政单位的意思。可以说**BFC就是一个作用范围，把它理解成是一个独立的容器，并且这个容器里box的布局与这个容器外的box毫不相干**。

触发BFC的条件：

* 根元素或其它包含它的元素
* 浮动元素 (元素的 float 不是 none)
* 绝对定位元素 (元素具有 position 为 absolute 或 fixed)
* 内联块 (元素具有 display: inline-block)
* 表格单元格 (元素具有 display: table-cell，HTML表格单元格默认属性)
* 表格标题 (元素具有 display: table-caption, HTML表格标题默认属性)
* 具有overflow 且值不是 visible 的块元素
* 弹性盒（flex或inline-flex）
* display: flow-root
* column-span: all

BFC的约束规则：

* 内部的盒会在垂直方向一个接一个排列（可以看作BFC中有一个的常规流）
* 处于同一个BFC中的元素相互影响，可能会发生外边距重叠
* 每个元素的margin box的左边，与容器块border box的左边相接触(对于从左往右的格式化，否则相反)，即使存在浮动也是如此
* BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素，反之亦然
* 计算BFC的高度时，考虑BFC所包含的所有元素，连浮动元素也参与计算
* 浮动盒区域不叠加到BFC上

BFC可以解决的问题：

* 垂直外边距重叠问题
* 去除浮动
* 自适用两列布局（float + overflow）

**层叠上下文**

元素提升为一个比较特殊的图层，在三维空间中 (z轴) 高出普通元素一等。

触发条件

* 根层叠上下文(html)
* position
* css3属性
  flex
  transform
  opacity
  filter
  will-change
  -webkit-overflow-scrolling

层叠等级：层叠上下文在z轴上的排序

![](/img/localBlog/1584965585320.jpg)

* 在同一层叠上下文中，层叠等级才有意义
* z-index的优先级最高

**居中布局**

水平居中

* 行内元素: text-align: center
* 块级元素: margin: 0 auto
* absolute + transform
* flex + justify-content: center

垂直居中

* line-height: height
* absolute + transform
* flex + align-items: center
* table

水平垂直居中

* absolute + transform
* flex + justify-content + align-items

**伪类和伪元素的区别**

伪类用于当已有元素处于的某个状态时，为其添加对应的样式，这个状态是根据用户行为而动态变化的。比如说，当用户悬停在指定的元素时，我们可以通过:hover来描述这个元素的状态。虽然它和普通的css类相似，可以为已有的元素添加样式，但是它只有处于dom树无法描述的状态下才能为元素添加样式，所以将其称为伪类。

伪元素用于创建一些不在文档树中的元素，并为其添加样式。比如说，我们可以通过:before来在一个元素前增加一些文本，并为这些文本添加样式。虽然用户可以看到这些文本，但是这些文本实际上不在文档树中。
区别

伪类的操作对象是文档树中已有的元素，而伪元素则创建了一个文档树外的元素。因此，**伪类与伪元素的区别在于：有没有创建一个文档树之外的元素**。

CSS3规范中的要求使用双冒号`(::)`表示伪元素，以此来区分伪元素和伪类，比如::before和::after等伪元素使用双冒号`(::)`，:hover和:active等伪类使用单冒号`(:)`。除了一些低于IE8版本的浏览器外，大部分浏览器都支持伪元素的双冒号`(::)`表示方法。

**Flex 布局**

布局的传统解决方案，基于盒状模型，依赖 display 属性 + position属性 + float属性。它对于那些特殊布局非常不方便，比如，垂直居中就不容易实现。

Flex 是 Flexible Box 的缩写，意为"**弹性布局**"，用来为盒状模型提供最大的灵活性。

**采用 Flex 布局的元素，称为 Flex 容器（flex container），简称"容器"。它的所有子元素自动成为容器成员，称为 Flex 项目（flex item），简称"项目"**。

容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis）。主轴的开始位置（与边框的交叉点）叫做main start，结束位置叫做main end；交叉轴的开始位置叫做cross start，结束位置叫做cross end。

项目默认沿主轴排列。单个项目占据的主轴空间叫做main size，占据的交叉轴空间叫做cross size。

以下6个属性设置在容器上：

* flex-direction
* flex-wrap
* flex-flow
* justify-content
* align-items
* align-content

以下6个属性设置在项目上：

* order
* flex-grow
* flex-shrink
* flex-basis
* flex
* align-self

**CSS 中解决浮动中高度塌陷的方案有哪些？**

* 通过增加尾元素清除浮动
`:after / <br> : clear: both`
* 创建父级 BFC
* 父级设置高度

**Flex 如何实现上下两行，上行高度自适应，下行高度 200px？**

flex-direction: column
flex: 1

**link 与 @import 的区别**

* link功能较多，可以定义 RSS，定义 Rel 等作用，而@import只能用于加载 css
* 当解析到link时，页面会同步加载所引的 css，而@import所引用的 css 会等到页面加载完才被加载
* @import需要 IE5 以上才能使用
* link可以使用 js 动态引入，@import不行

## JavaScript

**打乱数组**

```
function shuffle(arr) {
  let i = arr.length;
  while (i) {
    let j = Math.floor(Math.random() * i--);
    [arr[j], arr[i]] = [arr[i], arr[j]];
  }
}
```

**ajax**

```
//步骤一:创建异步对象
var ajax = new XMLHttpRequest();

//步骤二:设置请求的url参数,参数一是请求的类型,参数二是请求的url,可以带参数,动态的传递参数starName到服务端
ajax.open('get','getStar.php?starName='+name);

//步骤三:发送请求
ajax.send();

//步骤四:注册事件 onreadystatechange 状态改变就会调用
ajax.onreadystatechange = function () {
  if (ajax.readyState==4 && ajax.status==200) {
    //步骤五 如果能够进到这个判断说明数据完美的回来了,并且请求的页面是存在的
    console.log(ajax.responseText);
  }
}
```

**bind 实现**

```
if (!Function.prototype.bind) {
  Function.prototype.bind = function (...args) {
    const self = this;
    const context = args.shift();
    return function (...curArgs) {
      return self.apply(context, [...args, ...curArgs]);
    }
  }
}
```

**eventBus实现**

```
class EventBus {
  constructor() {
    this.event = Object.create(null);
  };
  on(name, fn) {
    if(!this.event[name]) {
      this.event[name] = [];
    };
    this.event[name].push(fn);
  };
  emit(name, ...args) {
    this.event[name] && this.event[name].forEach(fn => {
      fn(...args)
    });
  };
  once(name, fn) {
    const cb = (...args) => {
      fn.apply(this, args);
      this.off(name, fn);
    };
    this.on(name, cb);
  };
  off(name, offcb) {
    if(this.event[name]){
      let index = this.event[name].findIndex((fn) => {
        return offcb === fn;
      })
      if (index >= 0) {
        this.event[name].splice(index, 1);
      }
    }
  }
}
```

**JSONP**

```
var script = document.createElement('script');
script.type = 'text/javascript';

// 传参并指定回调执行函数为onBack
script.src = 'http://www.domain-com:8080/login?user=admin&callback=onBack';
document.head.appendChild(script);

// 回调执行函数
function onBack(res) {
  alert(JSON.stringify(res));
}
```

**ES5 和 ES6 继承的区别**

* ES5 的继承使用借助构造函数实现，实质是先创造子类的实例对象this，然后再将父类的方法添加到this上面。ES6 的继承机制完全不同，实质是先创造父类的实例对象this（所以必须先调用super方法），然后再用子类的构造函数修改this。

* ES6 在继承的语法上不仅继承了类的原型对象，还继承了类的静态属性和静态方法

**执行上下文(EC)**

执行上下文可以简单理解为一个对象:

它包含三个部分:

* 变量对象(VO)
* 作用域链(词法作用域)
* this指向

它的类型:

* 全局执行上下文
* 函数执行上下文
* eval执行上下文

代码执行过程:

* 创建 全局上下文 (global EC)
* 全局执行上下文 (caller) 逐行 自上而下 执行。遇到函数时，函数执行上下文 (callee) 被push到执行栈顶层
* 函数执行上下文被激活，成为 active EC, 开始执行函数中的代码，caller 被挂起
* 函数执行完后，callee 被pop移除出执行栈，控制权交还全局上下文 (caller)，继续执行

**变量对象**

变量对象，是执行上下文中的一部分，可以抽象为一种 数据作用域，其实也可以理解为就是一个简单的对象，它存储着**该执行上下文中的所有 变量和函数声明**(不包含函数表达式)。

活动对象 (AO): 当变量对象所处的上下文为 active EC 时，称为活动对象。

**作用域链**

我们知道，我们可以在执行上下文中访问到父级甚至全局的变量，这便是作用域链的功劳。作用域链可以理解为一组对象列表，包含 父级和自身的变量对象，因此我们便能通过作用域链访问到父级里声明的变量或者函数。

由两部分组成:

* `[[scope]]`属性: 指向父级变量对象和作用域链，也就是包含了父级的`[[scope]]`和AO
* AO: 自身活动对象

如此 `[[scope]]`包含`[[scope]]`，便自上而下形成一条 链式作用域。

**闭包**

闭包属于一种特殊的作用域，称为 静态作用域。它的定义可以理解为: 父函数被销毁 的情况下，返回出的子函数的`[[scope]]`中仍然保留着父级的变量对象和作用域链，因此可以继续访问到父级的变量对象，这样的函数称为闭包。

闭包会产生一个很经典的问题:

多个子函数的`[[scope]]`都是同时指向父级，是完全共享的。因此当父级的变量对象被修改时，所有子函数都受到影响。

解决:

* 变量可以通过 函数参数的形式 传入，避免使用默认的`[[scope]]`向上查找
* 使用setTimeout包裹，通过第三个参数传入
* 使用 块级作用域，让变量成为自己上下文的属性，避免共享

**script 引入方式**

* html 静态`<script>`引入
* js 动态插入`<script>`
* `<script defer>`: 异步加载，元素解析完成后执行
* `<script async>`: 异步加载，与元素渲染并行执行

**new运算符的执行过程**

新生成一个对象
链接到原型: `obj.__proto__ = Con.prototype`
绑定this: apply
返回新对象

**instanceof原理**

能在实例的 原型对象链 中找到该构造函数的prototype属性所指向的 原型对象，就返回true。即:

```
// __proto__: 代表原型对象链
instance.[__proto__...] === instance.constructor.prototype

// return true
```

**类型转换**

大家都知道 JS 中在使用运算符号或者对比符时，会自带隐式转换，规则如下:

* -、*、/、% ：一律转换成数值后计算
+：
  * 数字 + 字符串 = 字符串， 运算顺序是从左到右
  * 数字 + 对象， 优先调用对象的valueOf -> toString
  * 数字 + boolean/null = 数字
  * 数字 + undefined == NaN
* [1].toString() === '1'
* {}.toString() === '[object object]'
* NaN !== NaN 、+undefined === NaN

**类型判断**

判断 Target 的类型，单单用 typeof 并无法完全满足，这其实并不是 bug，本质原因是 JS 的万物皆对象的理论。因此要真正完美判断时，我们需要区分对待:

* 基本类型(null): 使用 String(null)
* 基本类型(string / number / boolean / undefined) + function: 直接使用 typeof即可
* 其余引用类型(Array / Date / RegExp Error): 调用toString后根据[object XXX]进行判断

很稳的判断封装:

```
let class2type = {}
'Array Date RegExp Object Error'.split(' ').forEach(e => class2type[ '[object ' + e + ']' ] = e.toLowerCase()) 

function type(obj) {
    if (obj == null) return String(obj)
    return typeof obj === 'object' ? class2type[ Object.prototype.toString.call(obj) ] || 'object' : typeof obj
}
```

**防抖 (debounce)**

将多次高频操作优化为只在最后一次执行，通常使用的场景是：用户输入，只需再输入完成后做一次输入校验即可。

```
function debounce(fn, wait, immediate) {
    let timer = null

    return function(...args) {
        let context = this
        if (immediate && !timer) {
          fn.apply(context, args);
        }

        if (timer) clearTimeout(timer)
        timer = setTimeout(() => {
            fn.apply(context, args);
            timer = null;
        }, wait)
    }
}
```

**节流(throttle)**

每隔一段时间后执行一次，也就是降低频率，将高频操作优化成低频操作，通常使用场景: 滚动条事件 或者 resize 事件，通常每隔 100~500 ms执行一次即可。

```
function throttle(fn, wait) {
    let timer = null
    
    return function(...args) {
        let context = this;
        if (!timer) {
            timer = setTimeout(() => {
                fn.apply(context, args)
                timer = null
            }, wait)
        }
    }
}
```

**函数执行改变this**

由于 JS 的设计原理: 在函数中，可以引用运行环境中的变量。因此就需要一个机制来让我们可以在函数体内部获取当前的运行环境，这便是this。

因此要明白 this 指向，其实就是要搞清楚 函数的运行环境，说人话就是，谁调用了函数。例如:

* obj.fn()，便是 obj 调用了函数，既函数中的 this === obj
* fn()，这里可以看成 window.fn()，因此 this === window

但这种机制并不完全能满足我们的业务需求，因此提供了三种方式可以手动修改 this 的指向:

* call: fn.call(target, 1, 2)
* apply: fn.apply(target, [1, 2])
* bind: fn.bind(target)(1,2)

**babel编译原理**

babylon 将 ES6/ES7 代码解析成 AST
babel-traverse 对 AST 进行遍历转译，得到新的 AST
新 AST 通过 babel-generator 转换成 ES5


**观察者模式  发布-订阅模式 的区别**

两者都是订阅-通知的模式，区别在于：
观察者模式：观察者和订阅者是互相知道彼此的，是一个紧耦合的设计
发布-订阅：观察者和订阅者是不知道彼此的，因为他们中间是通过一个订阅中心来交互的，订阅中心存储了多个订阅者，当有新的发布的时候，就会告知订阅者
设计模式的名词实在有点多且绕，我画个简单的图：

![](/img/localBlog/1585058756549.jpg)

**函数柯里化**

在一个函数中，首先填充几个参数，然后再**返回一个新的函数的技术**，称为函数的柯里化。**通常可用于在不侵入函数的前提下，为函数 预置通用参数，供多次重复调用**。

```
const add = function add(x) {
    return function (y) {
        return x + y
    }
}

const add1 = add(1)

add1(2) === 3
add1(20) === 21
```

**数组乱序**

```
var arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
arr.sort(function () {
    return Math.random() - 0.5;
});
```

**数组拆解**

```
flat: [1,[2,3]] --> [1, 2, 3]
arr.prototype.flat = function() {
    this.toString().split(',').map(item => +item )
}
```

**什么是尾递归？**

先给面试官简单说下什么是递归函数：函数内部循环调用自身的就是递归函数，若函数没有执行完毕，执行栈中会一直保持函数相关的变量，一直占用内存，当递归次数过大的时候，就可能会出现内存溢出，也叫爆栈，页面可能会卡死。

所以为了避免出现这种情况，可以采用尾递归。

尾递归：在函数的最后一步是调用函数，进入下一个函数不在需要上一个函数的环境了，内存空间 O(n) 到 O(1) 的优化 ，这就是尾递归。

尾递归的好处：可以释放外层函数的调用栈，较少栈层级，节省内存开销，避免内存溢出。

网上很多用斐波那契数列作为栗子，但我偏不，我用个数组累加的栗子

```
function add1(arr) {
    if (arr.length === 0) {
        return 0
    }
    return add1(arr.slice(1)) + arr[0] // 还有父级函数中 arr[0] 的引用
}

function add(arr, re) {
    if (arr.length === 0) {
        return re + 0
    } else {
        return add(arr.slice(1), arr[0] + re) // 仅仅是函数调用
    }
}

console.log(add([1, 2, 3, 4], 0))  // 10
console.log(add1([1, 2, 3, 4])) // 10
```

## 前端框架（ MVVM ）

**nextTick**

在下次dom更新循环结束之后执行延迟回调，可用于获取更新后的dom状态

新版本中默认是mincrotasks, v-on中会使用macrotasks

macrotasks任务的实现:

setImmediate / setTimeout

响应式的基本原理是什么
发布订阅模式的理解
Virtual DOM 的理解
前端路由的实现原理
nextTick / setState 的实现原理
diff 算法
单页面应用（SPA）的原理和优缺点
vue 具体的双向数据绑定，具体实现
key 的作用
Vue 组件间通信性能优化

## 浏览器

**从输入 url 到展示的过程**

* DNS 解析
* TCP 三次握手
* 发送请求，分析 url，设置请求报文(头，主体)
* 服务器返回请求的文件 (html)
* 浏览器渲染
  * HTML parser --> DOM Tree
  标记化算法，进行元素状态的标记
  dom 树构建
  * CSS parser --> Style Tree
  解析 css 代码，生成样式树
  * attachment --> Render Tree
  结合 dom树 与 style树，生成渲染树
  * layout: 布局
  * GPU painting: 像素绘制页面

**Web Worker**

现代浏览器为JavaScript创造的 多线程环境。可以新建并将部分任务分配到worker线程并行运行，两个线程可 独立运行，互不干扰，可通过自带的 消息机制 相互通信。

基本用法:

```
// 创建 worker
const worker = new Worker('work.js');

// 向主进程推送消息
worker.postMessage('Hello World');

// 监听主进程来的消息
worker.onmessage = function (event) {
  console.log('Received message ' + event.data);
}
```

限制:

* 同源限制
* 无法使用 document / window / alert / confirm
* 无法加载本地资源


**V8垃圾回收机制**

垃圾回收: 将内存中不再使用的数据进行清理，释放出内存空间。V8 将内存分成 新生代空间 和 老生代空间。

新生代空间: 用于存活较短的对象
* 又分成两个空间: from 空间 与 to 空间
* Scavenge GC算法: 当 from 空间被占满时，启动 GC 算法
* 存活的对象从 from space 转移到 to space
* 清空 from space
* from space 与 to space 互换
* 完成一次新生代GC

老生代空间: 用于存活时间较长的对象
* 从 新生代空间 转移到 老生代空间 的条件
  * 经历过一次以上 Scavenge GC 的对象
  * 当 to space 体积超过25%
* 标记清除算法: 标记存活的对象，未被标记的则被释放
  * 增量标记: 小模块标记，在代码执行间隙执，GC 会影响性能
  * 并发标记(最新技术): 不阻塞 js 执行
* 压缩算法: 将内存中清除后导致的碎片化对象往内存堆的一端移动，解决 内存的碎片化

**内存泄露**

* 意外的全局变量: 无法被回收
* 定时器: 未被正确关闭，导致所引用的外部变量无法被释放
* 事件监听: 没有正确销毁 (低版本浏览器可能出现)
* 闭包: 会导致父级中的变量无法被释放
* dom 引用: dom 元素被删除时，内存中的引用未被正确清空

可用 chrome 中的 timeline 进行内存标记，可视化查看内存的变化情况，找出异常点。

**线程和进程分别是什么**

首先来一句话概括：进程和线程都是一个时间段的描述，都是对CPU工作时间段的描述。

当一个任务得到 CPU 资源后，需要加载执行这个任务所需要的执行环境，也叫上下文，进程就是包含上下文切换的程序执行时间总和 = CPU加载上下文 + CPU执行 + CPU保存上下文。可见进程的颗粒度太大，每次都需要上下文的调入，保存，调出。

如果我们把进程比喻为一个运行在电脑上的软件，那么一个软件的执行不可能是一条逻辑执行的，必定有多个分支和多个程序段，就好比要实现程序A，实际分成 a，b，c等多个块组合而成。

那么这里具体的执行就是：程序A得到CPU => CPU加载上下文 => 开始执行程序A的a小段 => 然后执行A的b小段 => 然后再执行A的c小段 => 最后CPU保存A的上下文。这里a，b，c 的执行共享了A的上下文，CPU在执行的时候没有进行上下文切换的。

a，b，c 我们就是称为线程，就是说线程是共享了进程的上下文环境，是更为细小的 CPU 执行时间段。

![](/img/localBlog/1585059037296.jpg)

## 网络

**http/https 协议**

1.0 协议缺陷:
* 无法复用链接，完成即断开，重新慢启动和 TCP 3次握手
* head of line blocking: 线头阻塞，导致请求之间互相影响

1.1 改进:
* 长连接(默认 keep-alive)，复用
* host 字段指定对应的虚拟站点
* 新增功能:
  * 断点续传
  * 身份认证
  * 状态管理
  * cache 缓存
    * Cache-Control
    * Expires
    * Last-Modified
    * Etag

2.0:
* 多路复用
* 二进制分帧层: 应用层和传输层之间
* 首部压缩
* 服务端推送

https: 较为安全的网络传输协议
* 证书(公钥)
* SSL 加密
* 端口 443

TCP:
* 三次握手
* 四次挥手
* 滑动窗口: 流量控制
* 拥塞处理
  * 慢开始
  * 拥塞避免
  * 快速重传
  * 快速恢复

缓存策略: 可分为 强缓存 和 协商缓存

* Cache-Control/Expires: 浏览器判断缓存是否过期，未过期时，直接使用强缓存，Cache-Control的 max-age 优先级高于 Expires
* 当缓存已经过期时，使用协商缓存

* 唯一标识方案: Etag(response 携带) & If-None-Match(request携带，上一次返回的 Etag): 服务器判断资源是否被修改，
* 最后一次修改时间: Last-Modified(response) & If-Modified-Since (request，上一次返回的Last-Modified)
  * 如果一致，则直接返回 304 通知浏览器使用缓存
  * 如不一致，则服务端返回新的资源
* Last-Modified 缺点：
  * 周期性修改，但内容未变时，会导致缓存失效
  * 最小粒度只到 s， s 以内的改动无法检测到
* Etag 的优先级高于 Last-Modified


**常见状态码**

* 1xx: 接受，继续处理
* 200: 成功，并返回数据
* 201: 已创建
* 202: 已接受
* 203: 成为，但未授权
* 204: 成功，无内容
* 205: 成功，重置内容
* 206: 成功，部分内容
* 301: 永久移动，重定向
* 302: 临时移动，可使用原有URI
* 304: 资源未修改，可使用缓存
* 305: 需代理访问
* 400: 请求语法错误
* 401: 要求身份认证
* 403: 拒绝请求
* 404: 资源不存在
* 500: 服务器错误

**Websocket**

Websocket 是一个 持久化的协议， 基于 http ， 服务端可以 主动 push

兼容：

* 长轮询： 定时发送 ajax
* long poll： 发送 --> 有消息时再 response

**TCP三次握手**

建立连接前，客户端和服务端需要通过握手来确认对方:

* 客户端发送 syn(同步序列编号) 请求，进入 syn_send 状态，等待确认
* 服务端接收并确认 syn 包后发送 syn+ack 包，进入 syn_recv 状态
* 客户端接收 syn+ack 包后，发送 ack 包，双方进入 established 状态

**TCP四次挥手**

* 客户端 -- FIN --> 服务端， FIN—WAIT
* 服务端 -- ACK --> 客户端， CLOSE-WAIT
* 服务端 -- ACK,FIN --> 客户端， LAST-ACK
* 客户端 -- ACK --> 服务端，CLOSED

**dns解析**

解析顺序

* 浏览器缓存
当用户通过浏览器访问某域名时，浏览器首先会在自己的缓存中查找是否有该域名对应的IP地址（若曾经访问过该域名且没有清空缓存便存在）；

* 系统缓存
当浏览器缓存中无域名对应IP则会自动检查用户计算机系统Hosts文件DNS缓存是否有该域名对应IP；

* 路由器缓存
当浏览器及系统缓存中均无域名对应IP则进入路由器缓存中检查，以上三步均为客服端的DNS缓存；

* ISP（互联网服务提供商）DNS缓存
当在用户客服端查找不到域名对应IP地址，则将进入ISP DNS缓存中进行查询。比如你用的是电信的网络，则会进入电信的DNS缓存服务器中进行查找；

* 根域名服务器
当以上均未完成，则进入根服务器进行查询。全球仅有13台根域名服务器，1个主根域名服务器，其余12为辅根域名服务器。根域名收到请求后会查看区域文件记录，若无则将其管辖范围内顶级域名（如`.com`）服务器IP告诉本地DNS服务器；

* 顶级域名服务器
顶级域名服务器收到请求后查看区域文件记录，若无则将其管辖范围内主域名服务器的IP地址告诉本地DNS服务器；

* 主域名服务器
主域名服务器接受到请求后查询自己的缓存，如果没有则进入下一级域名服务器进行查找，并重复该步骤直至找到正确纪录；

* 保存结果至缓存
本地域名服务器把返回的结果保存到缓存，以备下一次使用，同时将该结果反馈给客户端，客户端通过这个IP地址与web服务器建立链接。

TCP/ip参数中设置的首选DNS服务器，在此我们叫它本地DNS服务器。

从客户端到本地DNS服务器是属于递归查询，而DNS服务器之间就是的交互查询就是迭代查询。

## 性能优化

前端性能衡量指标、性能监控（performance,LightHouse）
常见的性能优化方案有哪些
SSR 方案的性能优化
Webpack 的性能优化方案
React、Vue 等框架使用性能优化方案
网络层面的优化方案
页面渲染层面的优化方案
白屏的优化方案

## 数据结构和算法

## 开放性题目

你的优点
你的缺点
最近在看什么书? 怎么学习的前端知识? 保持自我学习?
为什么要从事前端?
为什么离职？
你的职业规划
有什么问题问我的吗？
最近项目解决的一个技术难点，即项目中遇到了哪些坑？怎样解决的？
最近做的最成功的一次分享是什么
说一件你做的最酷的事情是什么
怎样理解前端工程化？
前端发展趋势？
框架选型依据？
所在团队工作流程的介绍、以及你在团队中的定位和技术排名