# 常见问题整理

## 前端工程化

概念如下：前端工程化是使用软件工程的技术和方法来进行前端项目的开发、维护和管理（曾经的前端开发可不是这样的，不然为什么要说工程"化"呢？）。

所有能降低成本，并且能提高效率的事情的总称为工程化。

这里顺带说下软件工程的概念：应用计算机科学理论和技术以及工程管理原则和方法，按预算和进度，实现满足用户要求的软件产品的定义、开发、和维护的工程或进行研究的学科。

前端工程化包含如下：

1.代码规范: 保证团队所有成员以同样的规范开发代码。

2.分支管理: 不同的开发人员开发不同的功能或组件，按照统一的流程合并到主干。

3.模块管理: 一方面，团队引用的模块应该是规范的;另一方面，必须保证这些模块可以正确的加入到最终编译好的包文件中。（以上两点可以总结为模块化或者组件化开发。）

4.自动化测试：为了保证和并进主干的代码达到质量标准，必须有测试，而且测试应该是自动化的，可以回归的。

5.构建：主干更新以后，自动将代码编译为最终的目标格式，并且准备好各种静态资源

6.部署。 将构建好的代码部署到生产环境。

## 遍历相关的几个 api

**for...in**

主要用于遍历对象的**可枚举属性，包括自有属性、继承自原型的属性**。

通常，在迭代过程中最好不要在对象上进行添加、修改或者删除属性的操作，除非是对当前正在被访问的属性。这里并不保证是否一个被添加的属性在迭代过程中会被访问到，不保证一个修改后的属性（除非是正在被访问的）会在修改前或者修改后被访问，不保证一个被删除的属性将会在它被删除之前被访问。

for...in 不应该用于迭代一个 Array，其中索引顺序很重要。数组索引只是具有整数名称的枚举属性，并且与通用对象属性相同。不能保证 for ... in 将以任何特定的顺序返回索引。for ... in 循环语句将返回所有可枚举属性，包括非整数类型的名称和继承的那些。

```
for (var prop in obj) {
  if (obj.hasOwnProperty(prop)) {
    console.log(`obj.${prop} = ${obj[prop]}`);
  }
}
```

in 操作符和 for...in 类似，检查属性是否存在是**对象及其原型上的可枚举属性**。

**Object.keys()**

Object.keys() 方法会返回一个由一个给定对象的**自身可枚举属性**组成的数组，数组中属性名的排列顺序和使用 for...in 循环遍历该对象时返回的顺序一致 。如果对象的键-值都不可枚举，那么将返回由键组成的数组。

Polyfill：

```
if (!Object.keys) {
  Object.keys = function (obj) {
    var hasOwnProperty = Object.prototype.hasOwnProperty;

    if (typeof obj !== 'object' && typeof obj !== 'function' || obj === null) throw new TypeError('Object.keys called on non-object');

    var result = [];

    for (var prop in obj) {
      if (hasOwnProperty.call(obj, prop)) result.push(prop);
    }

    return result;
  }
};
```

Object.values、Object.entries 与 Object.keys 类似，都是遍历对象的自身可枚举属性。

**Object.getOwnPropertyNames()**

Object.getOwnPropertyNames() 返回一个数组，该数组对元素是 obj 自身拥有的**枚举或不可枚举属性名称字符串(但不包括 Symbol 值作为名称的属性)**。数组中枚举属性的顺序与通过 for...in 循环（或 Object.keys）迭代该对象属性时一致。数组中不可枚举属性的顺序未定义。

下面的例子使用了 Array.prototype.filter() 方法，从所有的属性名数组（使用 Object.getOwnPropertyNames()方法获得）中去除可枚举的属性（使用 Object.keys()方法获得），剩余的属性便是不可枚举的属性了：

```
var target = myObject;
var enum_and_nonenum = Object.getOwnPropertyNames(target);
var enum_only = Object.keys(target);
var nonenum_only = enum_and_nonenum.filter(function(key) {
    var indexInEnum = enum_only.indexOf(key);
    if (indexInEnum == -1) {
        // 没有发现在enum_only健集中意味着这个健是不可枚举的,
        // 因此返回true 以便让它保持在过滤结果中
        return true;
    } else {
        return false;
    }
});

console.log(nonenum_only);
```

**for...of**

for...of 语句在可迭代对象（包括 Array，Map，Set，String，TypedArray，arguments 对象等等）上创建一个迭代循环，调用自定义迭代钩子，并为每个不同属性的值执行语句。

普通对象本身不存在迭代器，我们可以显式实现可迭代协议的对象。

```
var iterable = {
  [Symbol.iterator]() {
    return {
      i: 0,
      next() {
        if (this.i < 3) {
          return { value: this.i++, done: false };
        }
        return { value: undefined, done: true };
      }
    };
  }
};

for (var value of iterable) {
  console.log(value);
}
// 0
// 1
// 2
```

无论是 for...in 还是 for...of 语句都是迭代一些东西。它们之间的主要区别在于它们的迭代方式。

for...in 语句以原始插入顺序迭代对象的可枚举属性。

for...of 语句遍历可迭代对象定义要迭代的数据。

以下示例显示了与 Array 一起使用时，for...of 循环和 for...in 循环之间的区别。

```
Object.prototype.objCustom = function() {};
Array.prototype.arrCustom = function() {};

let iterable = [3, 5, 7];
iterable.foo = 'hello';

for (let i in iterable) {
  console.log(i); // logs 0, 1, 2, "foo", "arrCustom", "objCustom"
}

for (let i in iterable) {
  if (iterable.hasOwnProperty(i)) {
    console.log(i); // logs 0, 1, 2, "foo"
  }
}

for (let i of iterable) {
  console.log(i); // logs 3, 5, 7
}
```

**Array.prototype.forEach()**

forEach 方法按升序为数组中含有效值的每一项执行一次 callback 函数，那些已删除或者未初始化的项将被跳过（例如在稀疏数组上）。

forEach 遍历的范围在第一次调用 callback 前就会确定。调用 forEach 后添加到数组中的项不会被 callback 访问到。如果已经存在的值被改变，则传递给 callback 的值是 forEach 遍历到他们那一刻的值。已删除的项不会被遍历到。如果已访问的元素在迭代时被删除了（例如使用 shift()），之后的元素将被跳过。

下面的例子会输出"one", "two", "four"。当到达包含值"two"的项时，整个数组的第一个项被移除了，这导致所有剩下的项上移一个位置。因为元素 "four"现在在数组更前的位置，"three"会被跳过。 forEach()不会在迭代之前创建数组的副本。

```
var words = ['one', 'two', 'three', 'four'];
words.forEach(function(word) {
  console.log(word);
  if (word === 'two') {
    words.shift();
  }
});
// one
// two
// four
```

**Reflect.ownKeys()**

Reflect.ownKeys 方法返回一个由目标对象自身的属性键组成的数组。它的返回值等同于 Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target))。

```
Reflect.ownKeys({z: 3, y: 2, x: 1}); // [ "z", "y", "x" ]
Reflect.ownKeys([]); // ["length"]

var sym = Symbol.for("comet");
var sym2 = Symbol.for("meteor");
var obj = {[sym]: 0, "str": 0, "773": 0, "0": 0,
           [sym2]: 0, "-1": 0, "8": 0, "second str": 0};
Reflect.ownKeys(obj);
// [ "0", "8", "773", "str", "-1", "second str", Symbol(comet), Symbol(meteor) ]
```

**稀疏数组**

我们来看看对于稀疏数组，上面的几个 api 是什么结果：

```
var x= [1,,2];

for (let i in x) {
  console.log(i); // 0 2
}

Object.keys(x); // ['0', '2']

Object.getOwnPropertyNames(x); // ['0', '2', 'length']

for (let i of x) {
  console.log(i); // 1 undefined 2
}

x.forEach(o => console.log(o)) // 1 2

Reflect.ownKeys([1,,2]) // ['0', '2', 'length']
```

## 深拷贝

使用下面这个例子来演示：

```
let test = {
    num: 0,
    str: '',
    boolean: true,
    unf: undefined,
    nul: null,
    obj: {
        name: '我是一个对象',
        id: 1
    },
    arr: [0, 1, 2],
    func: function() {
        console.log('我是一个函数')
    },
    date: new Date(0),
    reg: new RegExp('/我是一个正则/ig'),
    err: new Error('我是一个错误')
}

// 判断是否为对象
function isObject(value) {
  const type = typeof value
  return value !== null && (type == 'object' || type == 'function')
}

// 判断特殊对象类型
const toString = Object.prototype.toString
function getTag(value) {
  if (value == null) {
    return value === undefined ? '[object Undefined]' : '[object Null]'
  }
  return toString.call(value)
}
```

**序列化反序列化**

这个方法非常有趣，它先把代码序列化成数据，再反序列化回对象：

```
// 序列化反序列化法
function deepClone(obj) {
    return JSON.parse(JSON.stringify(obj))
}
```

它有这些问题：

1. 对象循环引用的时候会出问题
2. 键值是 Symbol 的时候无法拷贝
3. 原型上的属性(可枚举、不可枚举、Symbol)未拷贝
4. func、date、reg 和 err 等特殊对象并没有拷贝成功
5. 不可枚举属性无法拷贝

这种方法比较适合平常开发中使用，主要用来拷贝 JSON 格式的对象，不需要考虑对象和数组之外的类型。

**递归遍历**

先看一个简单版的实现：

```
function deepClone(obj) {
    if (!isObject(obj)) {
        return obj;
    }

    let isArray = Array.isArray(obj)
    let cloneObj = isArray ? [] : {}

    Object.entries(obj).forEach([key, val] =>
        cloneObj[key] = deepClone(val)
    )

    return cloneObj
}
```

用这种方法 arr 和 obj 都深拷贝成功了，它们的内存引用已经不同了。但和 JSON 格式化一样，依旧存在这些问题：

1. 对象循环引用的时候会出问题
2. 键值是 Symbol 的时候无法拷贝
3. 原型上的属性(可枚举、不可枚举、Symbol)未拷贝
4. func、date、reg 和 err 等特殊对象并没有拷贝成功
5. 不可枚举属性无法拷贝

接下来我们来一个个解决问题。

首先，使用 Reflect.ownKeys 可以获得对象的所有属性(可枚举、不可枚举、Symbol)，因此可以解决 2、5 的问题。

```
function deepClone(obj) {
    if (!isObject(obj)) {
        return obj;
    }

    let isArray = Array.isArray(obj)
    let cloneObj = isArray ? [] : {}
    Reflect.ownKeys(cloneObj).forEach(key => {
        cloneObj[key] = deepClone(obj[key])
    })

    return cloneObj
}
```

当然，如果你只需要拷贝对象的可枚举属性和 Symbol 键值的属性时，一般也不需要拷贝不可枚举属性，可以这样：

```
function deepClone(obj) {
    if (!isObject(obj)) {
        return obj;
    }

    let isArray = Array.isArray(obj)
    let cloneObj = isArray ? [] : {}
    let symKeys = Object.getOwnPropertySymbols(obj)
    if (symKeys.length > 0) {
        symKeys.forEach(symKey => {
            cloneObj[symKey] = deepClone(obj[symKey])
        })
    }

    Object.entries(obj).forEach([key, val] =>
        cloneObj[key] = deepClone(val)
    )

    return cloneObj
}
```

接着，对象成环怎么办？

我们给 test 加一个 loopObj 键，值指向自身：

```
test.loopObj = test
```

这时我们使用上面的递归方法都会栈溢出，而使用 jSON 格式化也会报错。

我们可以设置一个哈希表存储已拷贝过的对象，来解决循环引用问题：

```
function deepClone(obj, hash = new WeakMap()) {
    if (!isObject(obj)) {
        return obj
    }
    // 查表
    if (hash.has(obj)) return hash.get(obj)

    let isArray = Array.isArray(obj)
    let cloneObj = isArray ? [] : {}
    // 哈希表设值
    hash.set(obj, cloneObj)

    let symKeys = Object.getOwnPropertySymbols(obj)
    if (symKeys.length > 0) {
        symKeys.forEach(symKey => {
            cloneObj[symKey] = deepClone(obj[symKey])
        })
    }

    Object.entries(obj).forEach([key, val] =>
        cloneObj[key] = deepClone(val)
    )

    return cloneObj
}
```

这里我们使用 WeakMap 作为哈希表，因为它的键是弱引用的，而我们这个场景里键恰好是对象，需要弱引用。

最后，怎么拷贝原型上的属性？

众所周知，JS 对象是基于原型链设计的，所以当一个对象的属性查找不到时会沿着它的原型链向上查找，也就是一个非构造函数对象的 `__proto__` 属性。

我们可以使用 for...in 追踪原型链上的属性，而其它三种方法(Object.keys、Reflect.ownKeys 和 JSON 方法)都不会追踪原型链上的属性：

```
function deepClone(obj, hash = new WeakMap()) {
    if (!isObject(obj)) {
        return obj
    }
    // 查表
    if (hash.has(obj)) return hash.get(obj)

    let isArray = Array.isArray(obj)
    let cloneObj = isArray ? [] : {}
    // 哈希表设值
    hash.set(obj, cloneObj)

    let symKeys = Object.getOwnPropertySymbols(obj)
    if (symKeys.length > 0) {
        symKeys.forEach(symKey => {
            cloneObj[symKey] = deepClone(obj[symKey])
        })
    }

    // 拷贝可枚举属性（包括原型链上的）
    for (let key in obj) {
        cloneObj[key] = deepClone(obj[key], hash);
    }

    return cloneObj
}
```

至于要拷贝 js 中的特殊对象，则需要判断对象对具体类型，并做相应的处理。而要拷贝原型链上的不可枚举属性就需要一层层递归调用`Object.getPrototypeOf`来获取对象原型。

## 数组扁平化

**flat**

```
var arr1 = [1, 2, [3, 4]];
arr1.flat();
// [1, 2, 3, 4]

var arr2 = [1, 2, [3, 4, [5, 6]]];
arr2.flat();
// [1, 2, 3, 4, [5, 6]]

var arr3 = [1, 2, [3, 4, [5, 6]]];
arr3.flat(2);
// [1, 2, 3, 4, 5, 6]

//使用 Infinity 作为深度，展开任意深度的嵌套数组
arr3.flat(Infinity);
// [1, 2, 3, 4, 5, 6]
```

**递归**

```
// 使用 reduce、concat 和递归无限反嵌套多层嵌套的数组
var arr1 = [1,2,3,[1,2,3,4, [2,3,4]]];

function flattenDeep(arr1) {
   return arr1.reduce((acc, val) => Array.isArray(val) ? acc.concat(flattenDeep(val)) : acc.concat(val), []);
}
flattenDeep(arr1);
// [1, 2, 3, 1, 2, 3, 4, 2, 3, 4]

or

function fn(arr){
  let arr1 = []
  arr.forEach((val)=>{
      if(val instanceof Array){
        arr1 = arr1.concat(fn(val));
      }else{
        arr1.push(val);
      }
  })
  return arr1
}
```

**循环**

```
更优：
function flatten(arr){
  while(arr.some(item => Array.isArray(item))){
    arr = [].concat.apply([],arr);
  }
  return arr;
}

or

function flatten(arr){
  while(arr.some(item => Array.isArray(item))){
    arr = arr.reduce((prev,cur)=>{
      return prev.concat(cur);
    },[]);
  }
  return arr;
}
```

**stack**

```
// 不使用递归，使用 stack 无限反嵌套多层嵌套数组
var arr1 = [1,2,3,[1,2,3,4, [2,3,4]]];
function flatten(input) {
  const stack = [...input];
  const res = [];
  while (stack.length) {
    // 使用 pop 从 stack 中取出并移除值
    const next = stack.pop();
    if (Array.isArray(next)) {
      // 使用 push 送回内层数组中的元素，不会改动原始输入 original input
      stack.push(...next);
    } else {
      res.push(next);
    }
  }
  // 使用 reverse 恢复原数组的顺序
  return res.reverse();
}
flatten(arr1);// [1, 2, 3, 1, 2, 3, 4, 2, 3, 4]
```

**toString**

针对数字类型的字符串

```
let arr1 = arr.toString().split(',').map((val)=>{
  return parseInt(val)
})
console.log(arr1)
```

## 数组去重

**Set**

严格相等比较，且可以去重 NaN。对于对象，引用相同也可去重。

```
function unique (arr) {
  return Array.from(new Set(arr))
}
var arr = [1,1,'true','true',true,true,15,15,false,false, undefined,undefined, null,null, NaN, NaN,'NaN', 0, 0, 'a', 'a',{},{}];
console.log(unique(arr))
 //[1, "true", true, 15, false, undefined, null, NaN, "NaN", 0, "a", {}, {}]
```

**遍历**

这些方法都只能去重引用相同的对象，对于引用不同的对象需要更加准确的处理。

```
function unique(arr) {
  if (!Array.isArray(arr)) {
    console.log('type error!')
    return
  }
  var array = [];
  for (var i = 0; i < arr.length; i++) {
    if (array .indexOf(arr[i]) === -1) {
      array .push(arr[i])
    }
  }
  return array;
}
var arr = [1,1,'true','true',true,true,15,15,false,false, undefined,undefined, null,null, NaN, NaN,'NaN', 0, 0, 'a', 'a',{},{}];
console.log(unique(arr))
   // [1, "true", true, 15, false, undefined, null, NaN, NaN, "NaN", 0, "a", {…}, {…}]  //NaN、{}没有去重
```

```
function unique(arr) {
  if (!Array.isArray(arr)) {
      console.log('type error!')
      return
  }
  var array =[];
  for(var i = 0; i < arr.length; i++) {
    if( !array.includes( arr[i]) ) {//includes 检测数组是否有某个值
        array.push(arr[i]);
      }
  }
  return array
}
var arr = [1,1,'true','true',true,true,15,15,false,false, undefined,undefined, null,null, NaN, NaN,'NaN', 0, 0, 'a', 'a',{},{}];
    console.log(unique(arr))
    //[1, "true", true, 15, false, undefined, null, NaN, "NaN", 0, "a", {…}, {…}]     //{}没有去重
```

```
function arrayNonRepeatfy(arr) {
  let map = new Map();
  let array = new Array();  // 数组用于返回结果
  for (let i = 0; i < arr.length; i++) {
    if(map.has(arr[i])) {  // 如果有该key值
      map.set(arr[i], true);
    } else {
      map.set(arr[i], false);   // 如果没有该key值
      array.push(arr[i]);
    }
  }
  return array ;
}
 var arr = [1,1,'true','true',true,true,15,15,false,false, undefined,undefined, null,null, NaN, NaN,'NaN', 0, 0, 'a', 'a',{},{}];
    console.log(unique(arr))
//[1, "a", "true", true, 15, false, 1, {…}, null, NaN, NaN, "NaN", 0, "a", {…}, undefined]
```

**对象数组**

针对对象数组，我们来实现去重。

```
var arr=[{id:1,name:'bob'},{id:1,name:'bob'},{id:1,name:'bob'},{id:1,name:'lucy'},{id:1,name:'lucy'},{id:2,name:'lucy'},{id:2,name:'张三'}]
//去掉相同id的项目
var arr1=arr.filter(function(element,index,self){
  return self.findIndex(el=>el.id==element.id)===index
})
//封装成方法，通过某个属性去重
function filterRepeat(arr,prop){
  return arr.filter(function(element,index,self){
    return self.findIndex(el=>el[prop]==element[prop])===index
  })
}
//自定义去重方法
function filterRepeat2(arr,compareFn){
  return arr.filter(function(element,index,self){
    return self.findIndex(el=>compareFn(el,element))===index
  })
}
//加载到数组原型上
Array.prototype.filterRepeat=function(){
      if(typeof arguments[0]=='string')  return filterRepeat(this,arguments[0])
      return filterRepeat2(this,arguments[0])
}
//test 通过name属性去重
var newArr=arr.filterRepeat('name')
console.log(newArr)
var newArr2=arr.filterRepeat(function(a,b){return a.id==b.id&&a.name==b.name})
console.log(newArr2)

or

var arr=[{id:1,name:'bob'},{id:1,name:'bob'},{id:1,name:'bob'},{id:1,name:'lucy'},{id:1,name:'lucy'},{id:2,name:'lucy'},{id:2,name:'张三'}]
var arr1=arr.reduce(function(prev,element){
  if(!prev.find(el=>el.id==element.id)) {
    prev.push(element)
  }
  return prev
},[])
```

## 大数相加

使用字符串处理两个相加会大于 Number.MAX_SAFE_INTEGER (2^52 - 1) 的数字相加。

```
function add(a, b) {
  const arr_a = [...a].reverse().map(value => +value); // [个位,十位...]
  const arr_b = [...b].reverse().map(value => +value);
  const result = [];

  let carry = 0, // 进位
    i = 0,
    value_a = 0,
    value_b = 0;

  // 可能a, b在i位都没有数值，但存在进位
  while (arr_a[i] || arr_b[i] || carry) {
    let sum = 0,
      value = 0;
    value_a = arr_a[i] || 0;
    value_b = arr_b[i] || 0;
    sum = value_a + value_b + carry;
    carry = Math.floor(sum / 10);
    value = carry ? sum - 10 : sum;
    result.push(value);
    i++;
  }

  return result.reverse().join("");
}
```

## xss csrf csp 攻击和防范

[前端安全之 XSS 攻击](../_posts/2019-02-06-前端安全之XSS攻击.md)

[前端安全之 CSRF 攻击](../_posts/2019-02-19-前端安全之CSRF攻击.md)

[内容安全策略](../_posts/2018-11-01-内容安全策略.md)

## var let const 作用域和变量提升

[Javascript 作用域和变量提升](../_posts/2017-04-11-Javascript作用域和变量提升.md)

## vue 相关

父子组件通信生命周期数据响应(数据劫持)

数据响应的实现由两部分构成: 观察者( watcher ) 和 依赖收集器( Dep )，其核心是 defineProperty 这个方法，它重写属性的 get 与 set 方法，从而完成监听数据的改变。

一般会要求从解析到收集依赖到通知一套工作原理比较熟悉。我是大概理解，跟着读了一些源码，但是还是没有讲很清楚，遗憾没有表现好。

虚拟 dom、dom diff nextTick

vue 和 react 谈谈区别和选型考虑

vue 的 nextTick 实现原理以及应用场景

vuex, mobx, redux 各自的特点和区别

virtual dom 有哪些好处

Vue 响应式原理

vue 具体的双向数据绑定，具体实现

key 的作用

hooks

react 和 vue 更新机制的区别

Vue3 proxy 优缺点，解决了哪些问题？

Vue 组件间通信性能优化

vue 和 react 组件通信

## webpack 相关

loader plugin 的区别，一开始被问到还有点惊讶，不同作用的功能被问到一起。

tree-shaking 的工作原理

code splitting 用的是什么插件

如何提高 webpack 构建速度

利用 DllPlugin 预编译资源模块使用

Happypack 加速代码构建

webpack 的 plugins 和 loaders 的实现原理

如何编写 loaders 和 plugins 性能优化

webpack 热更新原理

## cookie session

一般会问两者的差别，以及引申到 sessionStorage, localStorage, cookie 区别

[localStorage、sessionStorage、Cookie 的区别及用法](../_posts/2018-01-04-localStorage、sessionStorage、Cookie的区别及用法.md)

---

三次握手和四次挥手详细介绍

TCP 有哪些手段保证可靠交付

URL 从输入到页面渲染全流程

如何预防中间人攻击

DNS 解析会出错吗，为什么

ES6 的 Set 内部实现

如何应对流量劫持

算法：top-K 问题，分成 top-1,top-2,top-K 三小问

事件循环机制，node 和浏览器的事件循环机制区别

单元测试编写有哪些原则

一个大型项目如何分配前端开发的工作

typescript 有什么好处

选择器优先级

nginx 负载均衡配置

301 302 307 308 401 403

细节场景题：一个气球从右上角移动到中间，然后抖动，如何实现

场景题：一个关于外边距合并的高度计算

算法：实现 setter(obj, 'a.b.c' ,val)

手写冒泡排序

JWT 细节，适用场景，优缺点

方案题：不同前端技术栈的项目，如何实现一套通用组件方案？

闭包和 this 一起谈谈

serviceworker 如何保证离线缓存资源更新

发布订阅模式和观察者模式的异同

图片懒加载实现

canvas 优化绘制性能

事件循环如何解决同步调用代码耗时太高的问题

CI/CD 整体流程

symbol 应用

dns 解析流程

贝塞尔曲线

ssr 优缺点,性能优化，node 中间层细节处理

谈谈 eleme 框架源码

css

1. 三栏布局

float (set middle area overflow is hidden) position: absolute 双飞翼布局 flex table

2. 垂直居中

个人感觉这个问很多，我一般就是答以下几种：

line-height: height 有被问到该值是不是等于高度设置的值，这个没有答好，回来测试发现是跟盒模型相关的，需要是 computed height absolute + transform 居中为什么要使用 transform（为什么不使用 marginLeft / Top），这是一道重绘重排的问题。 flex + align-items: center 我会对 flex 容器以及 flex 项目的每个 css 属性都了解一遍，并且写了一些小 demo。

3. 盒模型

4. BFC

概念如何触发怎么应用

5. CSS 预处理器

预处理器机制

一般回答 变量 / 嵌套 / 自动前缀 / 条件语句 / 循环语句

我是一直很欣赏张鑫旭大神对 CSS 研究到非常透彻的境界，但是总结下来，对 CSS 一般不会考得很深，业界对 CSS 的专注度其实不够，包括我个人也是没投入很多时间精力在 CSS 上，如果有更深入的理解当然是更好的。

JS

1. 原型

其实之前刚毕业的时候就在啃高级程序设计，三年后还是在考这个点。

闭包 / 作用域 / this 指向 实现 继承 es5 实现 class es5 实现 new

3. 实现 promise

面 tx 的时候有让我手写实现 promise，因为有看过一点 bluebird 的源码，所以对我来说还好。写了一半就让我停下来，我一般会边写边讲解，一上来先把框架搭好，例如

class Promise { constructor(executor) { // 设置属性 status value resolveCbs rejectCbs } then(onResolved, onRejected) {} catch (cb) { return this.then(null, cb) } } 然后再慢慢填充，这种做法会一上来让人感觉你是有思路的，而且了解 promise 的语法。

4. promise 链式

例如 promises = []，实现必须上一个异步完成后再去跑下一个任务。我是写出两种方案：

// 1. const template = Promise.resolve(); promises.forEach((p) => { template = template.then(p) }) // 2. 使用 await 个人感觉对 promise、async/await 都问比较多，包括比较火的问打印顺序那种题还有捕获异常的问题我也遇到过，只要对语法非常熟悉加上稍微了解实现细节都是没问题。

5. 实现 bind

6. 实现事件系统 eventEmitter

跟 promise class 一样，先搭建一个框架：

class EventEmitter { constructor() { this.events = {} } emit (eventName, args) {} on (eventName, callback) {} off (eventName, callback?) {} } 之前有写过事件系统，但是没有考虑 once 之类的 method，也是面试官说了需求再一点点补充的。

7. 手写 Proxy / Object.defineProperty

8. 事件委托

9. Event Loop

JS 执行是单线程的，它是基于事件循环的。事件循环大致分为以下几个步骤：

（1）所有同步任务都在主线程上执行，形成一个执行栈。

（2）主线程之外，还存在一个"任务队列"。只要异步任务有了运行结果，就在"任务队列"之中放置一个事件。

（3）一旦"执行栈"中的所有同步任务执行完毕，系统就会读取"任务队列"，看看里面有哪些事件。那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行。

（4）主线程不断重复上面的第三步。

event loop 基本每次都会被问到，一般就是说微任务、宏任务，怎么样的运行过程，以上是比较书面一点的回答，我自己也没记得。

11. 前端性能优化

一般我会分为以下几个方面来回答，一般会引申到网络、缓存方面的问题：

server：

使用 cdn 减少不必要的数据返回使用 gzip 缓存 （etag / expires ...） content：

减少 http 请求 (css sprites / inline image) 不同资源放在不同域下 (http1.1) 延迟加载 / 延迟执行(立即下载，延迟执行[before DOMContentLoaded]defer) / 预加载(preload) async，该布尔属性指示浏览器是否在允许的情况下异步执行该脚本。该属性对于内联脚本无作用 (即没有 src 属性的脚本）。 defer，这个布尔属性被设定用来通知浏览器该脚本将在文档完成解析后，触发 DOMContentLoaded 事件前执行。精简 HTML 结构压缩资源 css:

in head 较少的层级（之前被问到过是否有统计过层级多与少对性能的实质影响，实际上我是没有做过此类研究，所以知道结论而不懂过程还是欠缺的） js:

before 减少 dom 访问（在 body 内放置的 JS 代码是否可以访问到 body 标签） webpack:

tree shaking 去除没有使用的代码提取公共包，有被问到拆分模块，按需加载优化图片，使用 base64 代替小图 file name with hash (etag)

HTTP

1. 跨域

基本都被问同源策略以及引申到跨域来，一般我会说 CORS 以及 jsonp，CORS 会从简单请求跟非简单请求区分开，再讲 options 请求的意义。

2. HTTP 报文

请求行 + 头部信息 + 空白行 + body 有被问到说空白行的意义，我一直以为就是纯粹来标识 headers 的结束，但是面试官说不止这个功能，我后面看了 HTTP 权威指南 也没有找到，Stack Overflow 也没找到。。。希望有人知道可以跟我说一下。不过有可能是我听错了题目，毕竟是电话面试。

4. 从输入 URL 到页面加载全过程

一般我会答链接的大部分步骤，按照理解来，这里面我被问到的点有：

缓存，分为强缓存、协议缓存，一般会问到 304 的表现，以及再引申到 301 302 的区别，我会再说 307 的区别。三次握手 HTTPS 的工作原理 CDN 的工作原理，以及刷新缓存的原理。浏览器渲染的步骤重绘重排的概念，以及最佳实践。一直都知道应该用 transform 代替 margin，但是一被问原理，就不太清楚，查了资料是对 translate3d 的元素进行 GPU 加速。会因为 JS 是单线程而问到阻塞的问题，引申到 async defer 等属性。 status code 有哪些，我们是严格按照 restful 的规范来设计接口，所以这个问题我一直觉得很简单，但是被问到不少次。我记得趣头条的笔试就有，我会把用过的按照 2xx(200, 201, 204, 206) 3xx(301, 302, 304, 307) 4xx(400, 401, 403, 405) 5xx(500, 502, 504) 来分类，我偶尔写写 rails，所以对对应的名词都比较熟悉 贴一篇 list of rails status codes DNS 解析过程

6. sse( server sent event)

因为写过一个 sse 相关的插件，所以被问到过，是如何使用以及 EventSource 的 API。

感觉前端对网络、安全方面要求不是很高，没被问过 HTTP2 或者长连接更多内容，之前看脉脉上一个后端被问从浏览器里访问一个地址，从网络的 tcp/ip 协议、聊到操作系统 io、内存管理、进程管理和文件管理，再聊到负载均衡、限流算法、分布式事务，相比之下前端真的简单很多，不过知识储备多肯定是有用的。

算法

层次遍历一棵二叉树 (这是唯一一道剑指 offer 上的题目了，最简单的 😂 )

字符串中找出最长最多重复的子串

https://m.imooc.com/article/274197?mc_marking=e006a03025dbb036dda59ada344c96c2&mc_channel=weibo

https://m.imooc.com/article/80250?mc_marking=a0c56328db5ab64ff63fa7875e8953c7&mc_channel=weibo

https://segmentfault.com/a/1190000018155877?utm_medium=hao.caibaojian.com&utm_source=hao.caibaojian.com&share_user=1030000000178452#articleHeader72

https://juejin.im/post/5c62ea95e51d457ffe60c084

登录安全权限设置

Node express koa 实现

Commons es6 import

exce match

V8

你的优缺点是什么？

优点：对技术的热爱和追求,对各个技术方向都非常有兴趣缺点：比较懒，遇到一些重复和麻烦的工作，喜欢找一些插件或自己做一些脚本提高效率

你为什么选择我们公司？

公司福利挺不错的，技术也没得说，相比于其他公司更有情怀

你有什么想问我的？

技术栈，主要产品，公司技术氛围，薪资

为什么做这个系统？这个系统的价值是什么？

Im,即时通讯（Instant Messaging），结合已有的机器人产品，拓展业务线，平台 pass

这个系统有哪些功能？

机器人对话，人工客服实时通讯，im 通用功能模块（工单、留言、现场会话监控）

优缺点有哪些？

如果让你重新设计这个系统你会如何设计？

Vuex 管理混乱，模块化、按规范来写（mutation 修改状态、action 提交 mutation）

明确你的项目的整体架构，在面试的时候能够清楚地画给面试官看并且清楚地指出从哪里调用到哪里、使用什么方式调用?

坐席、管理员用户端（web、h5、sdk） Nodes BFF(backends for frontends)层 处理业务逻辑，权限控制 c++ 通讯后台 Java 数据后台 专注于提供统一的数据模式，更加通用的接口，减少修改产品平台 客服客服组权限配置

明确你的模块在整个项目中所处的位置及作用?

明确你的模块用到了哪些技术，更好一些的可以再了解一下整个项目用到了哪些技术?

端对端测试：Cypress、puppeteer 代码审查软件：gerrit 自动化部署：jenkins 日志分析系统: elk 告警系统：sentry 线上更新：双机蓝绿部署 、docker 部署私有 npm 仓库 verdaccio

谈一下你在项目中解决过的比较复杂的问题?

js

http://www.cnblogs.com/TomXu/archive/2011/12/15/2288411.html

vue 源码：

https://github.com/muwoo/blogs/blob/master/src/Vue/1.md

https://juejin.im/post/5b38830de51d455888216675

https://juejin.im/post/5b50760f5188251ad06b61be

https://segmentfault.com/a/1190000007484936

https://juejin.im/book/5a36661851882538e2259c0f

设计模式：

https://juejin.im/post/5a6dd4dd51882573385ffa8e

https://juejin.im/post/5a77211b6fb9a0635774d61a

cdn原理

斐波那契数列(递归、非递归)

## 1nd
1. 继承的几种方式(原型，构造函数继承，混合，…)
2. set和map的区别
3. 数组去重的几种方式
4. 找出连续字符最长的字符
            ‘aabbaaaac’ => {a: 4}
5. 如何打平一个数组
6. 箭头函数和普通函数的区别(prototype, arguments)
## 2nd
1. Es6 新特性
2. promise的原理
3. Async await的原理
4. Promise.all如何实现
5. bfc
6. vuex
7. 为什么要用mutation而不能直接改变值？
8. weakmap和map的区别
9. svg和cavans
## 3nd
  1. 项目中比较难的点
  2. 音频流
