---
layout: post
title: 深入Chrome扩展开发
subtitle: Chrome扩展(插件)开发全攻略
date: 2023-07-24
author: Li Yucang
catalog: true
tags:
  - Chrome扩展
  - 浏览器
---

# 深入Chrome扩展开发

## 前言

近几年，随着 IE 浏览器的落幕，Chrome（包括使用Chrome内核的浏览器）其实质上已经垄断整个浏览器行业了，就连微软的 Edge 都用上了 Chrome 内核。

可以说，Chrome 的标准，事实上就可以看做是行业标准了。可以预见，Chrome 的发展前景将会非常广阔。

而提到 Chrome 就绕不开它的扩展，或者叫插件（Chrome Extension）。

本篇文章主要是从开发者角度来对其进行介绍，帮助开发者深入了解 Chrome 开发方式。

## 获取插件

扩展的来源及安装使用的多种方式。

**1、其中最常用的就是直接官网安装了。**

此为主流方式，就是直接从应用商店进行安装，这种方式最为安全，因为能上应用商店的插件都经过官方审核了的。

![](/img/localBlog/9ad03b20bcbf6b304b8a76c2f7eab170.png)

**2、也可以从其它渠道获取，然后打开开发者模式，直接加载解压代码包。**

这种方式也是我们在开发调试过程中的使用方式。

自己开发的或者受信任的朋友给予的插件文件代码包，通常是一个包含js、html、css、json文件的文件夹。

非官方渠道或者未上架的插件需要自己能够判断其安全性，插件是否有违规行为。

插件地址，直接在chrome浏览器地址栏输入地址： chrome://extensions/

![](/img/localBlog/adcd84bb14b34575fbdfaa5e52c65f5d.png)

**3、除了上述两种外，还有一种就是“野生插件”了。**

野生插件风险较大，非专业人员或非可信来源的插件使用需谨慎。

野生插件包括从网上各大公司官网、网上论坛、或其它地方下载的插件(注意辨别，安全风险较大)。

下载下来的文件名有的是以 “.crx” 为结尾的压缩包。这是官方插件格式的安装包，可以直接拖拽至 Chrome 插件页安装使用。

如果拖拽安装失败，也可以将其后缀手动改为 “.zip”，然后使用unzip解压软件进行解压，再通过开发者模式进行加载。

最后，插件虽好，但是要注意使用安全。

非专业人员，不要加载不明来源、未知功能的插件

## 插件工作方式

Chrome 扩展开发所用到的技术栈就是html/js/css。可以说就是纯“前端开发”，其界面是用 html+css 画的。

事件、行为、逻辑交互是用 javascript，就连数据请求也是用的前端最新异步请求API fetch 发起的。

所以说，Chrome 扩展开发并不是什么新鲜玩意儿，只是一个挂载到 Chrome 浏览器上的一个“扩展”模块。

**这不就是网页应用吗？**

插件是基于Web技术构建的，例如HTML、JavaScript和CSS。它们在单独的沙盒执行环境中运行并与Chrome浏览器进行交互。

我们的确可以把他看做是网页应用，当然，相比于纯网页页面他也有自己的特点：

1、有独立的入口，可以在浏览器右边的“插件”区域点击打开。

2、相比也网页有更多的功能特性，支持调用 Chrome 浏览器原生API，可跨浏览器 Tab 运行，生命周期不会不随着页面关闭而结束。

3、独立应用，无需部署，可发布到 Chrome 应用商店，作为一个独立的应用供其它用户使用。

**交互界面与组成模块**

一个扩展的组成模块如下图所示，整个 Chrome 扩展主要包含六个模块：扩展图标、插件弹窗、选项页、单独页、注入页面脚本、后台脚本。

各个模块互通信、协作、配合，就构成了一个完整的 Chrome 扩展。

![](/img/localBlog/0122c6372d557f3dbb54487e8e24bd9f.png)

当然，除了上面的六大模块，还有一个非常非常重要的组成部分，那就是 manifest.json。

这是整个 Chrome 扩展的核心，包含了整个插件的配置，也可以看做是整个插件的入口。
一个插件有什么功能，需要用到哪些文件，需要什么权限等都可以在配置里面体现出来。

```
/** 配置举例 */
{
  "name": "myFirstPlugin",
  "version": "0.1",
  "manifest_version": 3,
  "description": "我的第一个插件",
  "action": {
    "default_popup": "popup.html",
    "default_title": "apihelper",
    "default_icon": "images/icon.png"
  },
  "permissions": [
    "scripting",
    "storage"
  ],
  "content_scripts": [
    {
      "matches": ["https://www.epoos.com/*"],
      "js": ["content-script.js"],
      "css": ["content-css.css"]
    }
  ],
  "background": {
    "service_worker": "background.js"
  },
  "options_page": "options.html"
}
```

**1、扩展图标**

![](/img/localBlog/c695b5588de6e1b598f14eeb993446c9.png)

扩展图标即扩展在浏览器扩展区域显示的 logo，可以自定义，也可以缺省，缺省时默认使用插件名的缩写。

在如上 manifest.json 文件中的 action.default_icon 字段中配置，支持配置多个规格（数组）。

**2、扩展弹窗**

扩展弹窗的显示时机为当用户点击扩展图标之后弹出。

![](/img/localBlog/4b9a1ab6124bc5c9f36769d9bca59242.png)

在如上 manifest.json 文件中的 action.default_popup 字段中配置。

其值是一个 html 文件，html文件内部可引用js/css等资源，可看做是一个独立页面。

其中 js 资源可调用浏览器原生 API。

**3、选项页**

选项页的显示时机为当用户在扩展图标上右键-选项可打开，点击之后打开新 Tab 页。

![](/img/localBlog/e06c4657d1549f4391c3d201f9fac562.png)

在如上 manifest.json 文件中的 options_page 字段中配置。

其值也是一个 html 文件，可以看做是独立页面，html 文件内部同样可以引用 js/css 等资源，多用做扩展的用户自定义配置。

其中 js 资源也可调用浏览器原生 API。

**4、单独页**

所谓单独页其实就是可以单独打开的页面，如上选项页其实就是一个单独页，只不过 Chrome 在右键菜单加了一个“选项”入口。除了选项页也可以是其它html页面，其路径拼接方式为：chrome-extension://id/{pageName}.html，id 为插件 id，pageName 为插件代码中的 html 文件名。可以用作插件的首页、介绍页、配置页等等。

**5、注入页面脚本**

注入脚本在如上 manifest.json 文件中的 content_scripts 字段中配置，其内容会被直接注入到目标网页的页面内容中去。

matches 字段表示需要注入脚本的网站地址规则，js和css字段分别表示注入页面的 js 代码和 css 代码。

注入的 js 代码能够操作页面 DOM，可以调用浏览器原生API，可以发起页面请求，但是它具有独立的执行空间，也就是说注入的 js 和页面本身的js脚本不能够直接互相调用。

可以同时在一个页面注入多个脚本，也可以在不同的页面注入多个不同的脚本。

**6、后台脚本**

后台脚本在如上 manifest.json 文件中的 background.service_worker 字段中配置。

从名字就可以看出来，这是一个运行在浏览器后台的脚本文件，其运行生命周期页面无关，浏览器打开多个 Tab 都只会共用同一个 background 脚本。

## API 文档

前面说了，扩展应用其实就是特殊的 h5 前端应用，相比于传统的 h5 的功能， 扩展最大的优势就在于他可以直接调用 chrome 原生Api。

Chrome 扩展提供了许多特殊用途的 Api，囊括了本地存储、定时任务、Tab切换、网络请求、书签、屏幕截图、历史记录、文件下载、devTools信息、页面性能等在内的 100+ 个Api。

这里就不做一一说明，可以参考[API 官方文档](https://developer.chrome.com/docs/extensions/reference/)。

官方文档是英文版的，国内也有好心人做了中文版的翻译版[API 非官方中文翻译](https://doc.yilijishu.info/chrome/getstarted.html)

在了解了大致功能之后，以后在开发过程中需要用到什么功能动态去查即可。

## 一个简单的小插件

Chrome插件并没有很严格的项目结构要求，比如src、public、components等等，因此我们如果去看很多插件的源码，会发现每个插件的项目结构，甚至项目下的文件名称都大相径庭；

但是在根目录下我们都会找到一个manifest.json文件，这是插件的配置文件，说明了插件的各种信息；它的作用等同于小程序的app.json和前端项目的package.json。

我们在项目中创建一个最简单的manifest.json配置文件：

```
{
    // 插件名称
    "name": "Hello Extensions",
    // 插件的描述
    "description" : "Base Level Extension",
    // 插件的版本
    "version": "1.0",
    // 配置插件程序的版本号，主流版本是2，最新是3
    "manifest_version": 2
}
```

我们经常会点击右上角插件图标时弹出一个小窗口的页面，焦点离开时就关闭了，一般做一些临时性的交互操作；在配置文件中新增browser_action字段，配置popup弹框：

```
{
    "name": "Hello Extensions",
    "description" : "Base Level Extension",
    "version": "1.0",
    "manifest_version": 2,
    // 新增popup弹框
    "browser_action": {
      "default_popup": "popup.html",
      "default_icon": "popup.png"
    }
}
```

然后创建我们的弹框页面popup.html：

```
<html>
  <body>
    <h1>Hello Extensions</h1>
  </body>
</html>
```

点击图标后，插件显示popup.html。

![](/img/localBlog/load3.png)

为了用户方便点击，我们还可以在manifest.json中设置一个键盘快捷键的命令，通过快捷键来弹出popup页面：

```
{
  "name": "Hello Extensions",
  "description" : "Base Level Extension",
  "version": "1.0",
  "manifest_version": 2,
  "browser_action": {
    "default_popup": "popup.html",
    "default_icon": "popup.png"
  },
  // 新增命令
  "commands": {
    "_execute_browser_action": {
      "suggested_key": {
        "default": "Ctrl+Shift+F",
        "mac": "MacCtrl+Shift+F"
      },
      "description": "Opens popup.html"
    }
  }
}
```

这样我们的插件就可以通过按键盘上的Ctrl+Shift+F来弹出。

**加载及调试插件**

我们开发的插件需要在浏览器里面运行，打开插件标签页，打开开发者模式，点击加载已解压的扩展程序，选择项目文件夹，就可将开发中的插件加载进来。

![](/img/localBlog/load1.png)

开发中更改了代码，点击插件右下角刷新按钮即可重新加载

如果我们的代码中有错误，加载插件后，会显示红色的错误按钮：

![](/img/localBlog/load-error.png)

点击错误按钮以查看错误的日志：

![](/img/localBlog/error-detail.png)

**后台background**

我们的插件安装后，popup页面也运行了；但是我们也发现了，popup页面只能做临时性的交互操作，用完就关了，不能存储信息或者和其他标签页进行交互等等；

这时就需要用到background（后台），它是一个常驻的页面，它的生命周期是插件中所有类型页面中最长的；它随着浏览器的打开而打开，随着浏览器的关闭而关闭，所以通常把需要一直运行的、启动就运行的、全局的代码放在background里面。

background也是需要在manifest.json中进行配置，可以通过page指定一张网页，或者通过scripts直接指定一个js数组，Chrome会自动为js生成默认网页：

```
{
  "background": {
    // "page": "background.html",
    "scripts": ["background.js"],
    "persistent": true
  }
}
```

需要注意的是，page属性和scripts属性只需要配置一个即可，如果两个同时配置，则会报以下错误信息：

```
Only one of 'background.page', 'background.scripts', and 'background.service_worker' can be specified.
```

我们给background设置一个监听事件，当插件安装时打印日志：

```
// background.js
chrome.runtime.onInstalled.addListener(function () {
  console.log("插件已被安装");
});
```

点击查看视图旁边的背景页，看到我们设置的background：

![](/img/localBlog/background.png)

**storage存储**

我们在插件安装时在storage中设置一个值，这将允许多个插件组件访问该值并进行更新操作：

```
//background.js
chrome.runtime.onInstalled.addListener(function () {
  // storage中设置值
  chrome.storage.sync.set({ color: "#3aa757" }, function () {
    console.log("storage init color value");
  });
  // 为特定的网址显示图标
  chrome.declarativeContent.onPageChanged.removeRules(undefined, function () {
    chrome.declarativeContent.onPageChanged.addRules([
      {
        conditions: [
          new chrome.declarativeContent.PageStateMatcher({
            pageUrl: { hostEquals: "baidu.com" },
          }),
        ],
        actions: [new chrome.declarativeContent.ShowPageAction()],
      },
    ]);
  });
});
```

chrome.declarativeContent用于精确地控制什么时候显示我们的页面按钮，或者需要在用户单击它之前更改它的外观以匹配当前标签页。

这里调用的chrome.storage和我们常用的localStorage和sessionStorage不是一个东西；由于调用到了storage和declarativeContent的API，因此我们需要在manifest中给插件注册使用的权限：

```
{
  // 新增
  "permissions": ["storage", "declarativeContent"],
  "background": {
    "scripts": ["background.js"],
    "persistent": true
  }
}
```

再次查看背景页的视图，我们就能看到打印的日志了；既然可以存储，那也能取出来，我们在popup中添加事件进行获取，首先我们新增一个触发的button：

```
<!-- popup.html -->
<html>
  <head>
    <style>
      button {
        width: 60px;
        height: 30px;
        outline: none;
      }
    </style>
  </head>
  <body>
    <button id="changeColor">change</button>
    <script src="popup.js"></script>
  </body>
</html>
```

我们再创建一个popup.js的文件，用来从storage存储中拿到颜色值，并将此颜色作为按钮的背景色：

```
let changeColor = document.getElementById("changeColor");

changeColor.onclick = function (el) {
  chrome.storage.sync.get("color", function (data) {
    changeColor.style.backgroundColor = data.color;
  });
};
```

>如果需要调试popup页面，可以在弹框中右击 => 检查，在DevTools中进行调试查看。

我们多次打开popup页面，发现页面每次点开按钮都会恢复最开始的默认状态。

![](/img/localBlog/storage.gif)

**获取浏览器tabs**

现在，我们获取到了storage中的值，需要逻辑来进一步与用户交互；更新popup.js中的交互代码：

```
// popupjs
changeColor.onclick = function (el) {
  chrome.storage.sync.get("color", function (data) {
    let { color } = data;
    chrome.tabs.query({ active: true, currentWindow: true }, function (tabs) {
      chrome.tabs.executeScript(tabs[0].id, {
        code: 'document.body.style.backgroundColor = "' + color + '";',
      });
    });
  });
};
```

chrome.tabs的API主要是和浏览器的标签页进行交互，通过query找到当前的激活中的tab，然后使用executeScript向标签页注入脚本内容。

manifest同样需要activeTab的权限，来允许我们的插件使用tabs的API。

```
{
  "name": "Hello Extensions",
  // ...
  "permissions": ["storage", "declarativeContent", "activeTab"],
}
```

重新加载插件，我们点击按钮，会发现当前页面的背景颜色已经变成storage中设置的色值了；但是某些用户可能希望使用不同的色值，我们给用户提供选择的机会。

**颜色选项页面**

现在我们的插件功能还比较单一，只能让用户选择唯一的颜色；我们可以在插件中加入选项页面，以便用户更好的自定义插件的功能。

在程序目录新增一个options.html文件：

```
<!DOCTYPE html>
<html>
  <head>
    <style>
      button {
        height: 30px;
        width: 30px;
        outline: none;
        margin: 10px;
      }
    </style>
  </head>
  <body>
    <div id="buttonDiv"></div>
    <div>
      <p>选择一个不同的颜色</p>
    </div>
  </body>
  <script src="options.js"></script>
</html>
```

然后添加选择页面的逻辑代码options.js：

```
let page = document.getElementById("buttonDiv");
const kButtonColors = ["#3aa757", "#e8453c", "#f9bb2d", "#4688f1"];
function constructOptions(kButtonColors) {
  for (let item of kButtonColors) {
    let button = document.createElement("button");
    button.style.backgroundColor = item;
    button.addEventListener("click", function () {
      chrome.storage.sync.set({ color: item }, function () {
        console.log("color is " + item);
      });
    });
    page.appendChild(button);
  }
}
constructOptions(kButtonColors);
```

上面代码中预设了四个颜色选项，通过onclick事件监听，生成页面上的按钮；当用户单击按钮时，将更新storage中存储的颜色值。

options页面完成后，我们可以将其在manifest的options_page进行注册：

```
{
  "name": "Hello Extensions",
  //...
  "options_page": "options.html",
  //...
  "manifest_version": 2
}
```

重新加载我们的插件，点击详情，滚动到底部，点击扩展程序选项来查看选项页面。

![](/img/localBlog/options.png)

或者可以在浏览器右上角插件图标上右击 => 选项。

## 插件功能进阶
