---
layout: post
title: git文件夹探索
subtitle: 探究版本控制之源
date: 2019-11-15
author: Li Yucang
catalog: true
tags:
  - git
  - 版本控制
---

# git文件夹探索

git是一款分布式代码版本管理工具，通过git能够更加高效地协同编程。了解git的工作原理将有助于我们使用git工具更好地管理项目。通过了解.git文件夹中的文件组成，我们可以从一个角度去窥探git的实现原理。

学习知识需要找到知识的源头，git学习也不例外，首先我们找到[git官方文档](https://git-scm.com/book/zh/v2/%E8%B5%B7%E6%AD%A5-%E5%85%B3%E4%BA%8E%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6)，对git了解不够的小伙伴可以先阅读文档补充知识。我们主要对`.git`文件夹下的相关文件进行逐一分析，了解他们的作用，最后结合实际项目介绍一下相关运用。

## git简单介绍

1、git的三个区域
1、Git 的工作目录

2、暂存区域

3、以及本地仓库

2、文件的三种状态
对于任何一个文件，在 Git 内都只有三种状态：

1、已修改（modified）    --> Git 的工作目录

2、已暂存（staged）        -->暂存区域

3、已提交（committed） -->本地仓库

已修改表示修改了某个文件，但还没有提交保存；

已暂存表示把已修改的文件放在下次提交时要保存的清单中。

已提交表示该文件已经被安全地保存在本地数据库中了；


## .git文件夹

首先我们随便找一个git项目，打开`.git`文件夹：

![](/img/localBlog/1578709803359.jpg)

### hooks文件夹

![](/img/localBlog/1578711467638.jpg)

用于存储shell脚本，当执行某些git指令后，会触发存储在该文件夹下指定的shell脚本

### logs文件夹

![](/img/localBlog/1578711770233.jpg)

用于记录分支提交记录

保存所有更改的引用记录，继续打开logs文件夹，有refs文件夹和HEAD文件

**HEAD文件**

主要记录每次的变更操作，所有类型的变更都会记录的哦，

git reflog命令查询出的列表就是HEAD中存储的列表

**refs文件夹**

继续打开refs文件夹，可以看到heads文件夹、remotes文件夹和stash文件

I : stash文件存储的是所有你使用git stash命令暂存的记录，是一个列表。使用git stash list时，查询出的列表就是从stash中取出来的。

II：heads文件里面存储的是一系列的本地分支的对象，每个对象的文件名就是本地的一个分支名，使用git branch查看本地分支命令时，查询出的所有本地分支就是取的heads文件夹下所有文件的名称。

III：remotes文件夹里存储的是远端的一系列分支的对象，每个对象的文件名称就是远端的一个分支名称，使用git branch -a查看远端分支命令时，查询出的所有本地分支就是取的remotes文件夹下所有文件的名称。

### objects文件夹

![](/img/localBlog/1578711982720.jpg)

在讨论objects文件夹的内容之前，我们需要明确存在于git系统中的三个实体，即“提交结点”、“节点内容”、“文件内容”。

objects可以认为是一种“key-value数据库”，之所以将数据库打引号，是因为这个“git的数据库”不具备数据库的基本功能，而仅仅具备可以通过key值能够找到与之对应的value。

提交结点实体，是整个git中的核心实体，提交节点中描述了提交节点之间的继承关系，即本次提交的内容是基于哪个或哪几个之前的提交的内容，提交结点实体之间的关系形成了一个DAG图，通过这个DAG图可以清晰地理顺整个项目的发展脉络，提交节点的内容如下：

```
tree <SHA1-signature>
[
    parent <SHA1-signature>
    ...
]
author <author name> <\<author email\>> <timestamp> <time zone>
committer <committer name> <\<committer email\>> <timestamp> <time zone>

<commit message>
```

tree用于指向与该提交结点实体关联的节点内容实体。parent用于指向该提交节点实体所基于的之前的提交结点实体，可以看到，parent可以是多个。author用于记录本次提交的作者姓名、作者邮箱、作者所添加的内容时间以及时区。committer用于记录本次提交的提交者姓名、邮箱等内容。commit message用于记录当前提交的消息日志。

节点内容实体，用于记录本次提交时，提交中所包含的所有文件名，以及文件名所对应的key值，值得注意的是，可能由于查询性能的缘故，并非是仅记录本次提交时修改的文件，而是记录本次提交时所有的文件。另有一点值得注意的是，即便项目仓库中的文件不变，仅改变某个或某几个文件内容的前后两次提交，生成的前后两次提交节点中的tree值是不同的，换句话说，节点内容与提交节点是逻辑上的一对一关系。随着之后的讨论我们会很自然地得出这样的结论，这种一对一关系也同样是必须的，尽管在实际情况中允许两个不同的提交节点实体指向相同的节点内容实体。

文件内容实体，用于记录具体的文件内容。也就是说，在一个git仓库中，并非只有程序员们所能看到的当前项目文件夹下的代码版本，包括所有的历史代码都会在.git文件夹中有一个备份。

在objects文件夹中，三种数据实体无差别的以key-value的形式进行存储。因此一次提交操作，在objects文件夹中至少生成两个文件。存储时采用deflate算法对原始文件内容进行压缩，而key值是根据原始文件内容、文件大小等数据生成的消息摘要，在当前版本的git中，消息摘要生成算法采用SHA1算法，生成过程是将文件格式与文件长度组成头部，将文件内容作为尾部，由头部和尾部拼接后作为原文，经过SHA1算法计算之后得到该文件的160位长的SHA1签名。为防止一个文件夹内的文件数量过多，将签名每四位用字符表示十六进制数，于是得到一个长度为40的字符串，将字符串的前两个字符作为文件夹，后38个字符作为文件名进行存储。

观察仔细的同学可以发现，在三个实体的内容里，没有任何一个字段提供分支概念的信息。


该目录存放所有的Git对象，对象的SHA1哈希值（一共40位）的前两位是文件夹名称，后38位作为存在相应文件夹下对象的文件名。

比如0b这个文件夹，它里面有一系列git对象（也就是文件），里面所有文件的38位的名称加上0b，就组成原来的40位的哈希值了。

更近一步说，我们每次提交新文件到git上时，这时会根据该文件内容计算生成一个40位的哈希值,假如生成的是0c7bcc3f8f1c5311d06e3067f7f7dddecb8668fe，这个文件的存储方式就是先截取0c作为文件夹名称，然后后面的38位7bcc3f8f1c5311d06e3067f7f7dddecb8668fe作为文件名称，存储在0c文件夹下。

如果这时你又提交了一个文件或者修改了一个文件碰巧又生成一个以0c开通的哈希值，那么这个时候就会直接截取该哈希值的后38位作为该次生成的git对象的文件名，存储在原来已经存在的0c文件夹下。

### refs文件夹

![](/img/localBlog/1578712139411.jpg)

引用（Refs）是一种间接引用commit的方式。它是一种对用户来说更亲和的commit哈希的别名。使Git表示分支与标签的内部机制。

heads目录描述了了在你仓库中所有的本地分支。每一个文件名对应了相应的分支，在文件夹内部的文件中你会看他对应的commit哈希。这个哈希是现在的分支最末端的那个commit的哈希。

remotes文件夹将所有由git remote命令创建的所有远程分支存储为单独的子目录。在每个子目录中，可以发现被fetch进仓库的对应的远程分支。

要更改主分支的位置就必须要改到refs/heads/master的内容。同样地，创建一个新的分支就是把commit哈希写入新文件这样简单。这也是为何Git与SVN相比是如此轻量的部分原因。

tag文件夹实际上以同样的方式工作着，只是其中存放的是tag而非分支。当使用git tag v1.0给当前分支，打上标签时，就会在tags文件夹下，生成对应文件，文件里存储的是当前分支所对应的哈希值，以后就可以使用v1.0这个标签来代替分支名称，通常发布稳定的线上版本时，使用这种做法。方便以后查询，因为使用标签容易记，更简洁。

**stash文件**

该文件夹是使用git stash命令时，会将生成的git对象的哈希值存储到stash文件里，更进一步说stash文件中，就存了一个40位的哈希值。对应的git对象在objects文件夹里。使用git stash pop时，会先去stash文件中，找到该哈希值（或者也可以认为是指针），然后到对应的objects文件夹下，查找对应的git对象，将其中的数据取出来，转换成我们能看懂的代码

![](/img/localBlog/1578710848641.jpg)

### COMMIT_EDITMSG文件

![](/img/localBlog/1578719104081.jpg)

最新提交的一次Commit Message，git系统不会用到，给用户一个参考

### config文件

![](/img/localBlog/1578719573952.jpg)

记录着仓库的配置信息

Refspecs

每个refspec都会创建一个本地仓库分支到远程仓库分支的映射。这让通过本地Git命令操作远程分支成为可能，并且配置一些高级的git push与git fetch行为。

refspec被表示为`[+]<src>:<dst>`。`<src>`参数表示本地仓库的分支，`<src>`参数表示远程仓库的目标分支，可选参数+表示是否让远程仓库执行non-fast-forward更新。

Refspec可与git push命令联合使用来为远程分支添加不同的名字。例如，以下命令推送主分支到远程分支与寻常git push命令无二，所不同的是使用了qa-master作为分支名。这样的做法常用于需要将自己的分支推送到远程仓库的QA团队中。

```
git push origin master:refs/heads/qa-master
```

你也可以通过refspecs来删除远程分支。在使用特性分支工作流的团队里，将特性分支推送到远程仓库是一个很常见的场景（例如出于备份的目的）。远程特性分支在本地分支从仓库中删除后会依旧存在于远程仓库中，这意味着随着你项目的推进死分支的数量会一直叠加。可以通过以下命令来删除他们：

```
git push origin :some-feature
```

这是非常方便的，因为你不需要登录到远程仓库去手动删除远程分支。请注意，在Git v1.7.0你可以使用--delete来替代上述方法。下面的命令具有同样的效果：

```
git push origin --delete some-feature
```

通过添加几行代码到Git配置文件中，你可以使用refspec来改变git fetch命令的行为。通常，git fetch命令会获取远程仓库所有分支，由于.git/confi文件中的一下部分：

```
[remote "origin"]
    url = https://git@github.com:mary/example-repo.git
    fetch = +refs/heads/*:refs/remotes/origin/*
```

fetch一行告诉git fetch从源仓库下载所有分支。但是在一些工作流中，你并不需要把他们都下载下来。例如，许多持续集成的工作流只关注主分支。为了只获取主分支，可将fetch行修改为：

```
[remote "origin"]
    url = https://git@github.com:mary/example-repo.git
    fetch = +refs/heads/master:refs/remotes/origin/master
```

你可以用相同的方式来配置git push。例如你总是想要将本地的qa-master推送至远程（像前问所述），你可以按下述方式修改配置文件：

```
[remote "origin"]
    url = https://git@github.com:mary/example-repo.git
    fetch = +refs/heads/master:refs/remotes/origin/master
    push = refs/heads/master:refs/heads/qa-master
```

Refspecs提供了各种能在仓库间转移分支的Git命令的一个全面控制。有了这些命令你可以重命名或删除本地仓库中的分支，通过别名提交／获取分支，控制git push和git fetch命令作用于你指定的分支。

### info文件夹

用于存储该项目仓库的相关信息

### description文件

仓库的描述信息，主要给gitweb等git托管系统使用

### index文件

暂存区（stage），一个二进制文件

### HEAD文件

![](/img/localBlog/1578721466537.jpg)

HEAD引用有可能是一个指向其他引用的象征性的引用，也可能是一个commit哈希。当你在主分支下，查看你的HEAD文件内容：

```
git checkout master
cat .git/HEAD
```

你将看到ref: refs/heads/master，这意味着HEAD指向refs/heads/master的引用。这就是为什么Git能获悉当前主分支被检出了的原因。如果切换到其他分支，HEAD的内容将被更新为指向那个分支。

但是如果你在commit的层面使用check out而非分支层面，HEAD的内容将会是一个commit哈希而非引用。这就是为什么Git能获悉它处在独立的状态的原因。

多数情况，HEAD仅仅是一个你可以直接使用的引用。其他仅仅在使用Git内部工作的底层脚本时才会用到。

### FETCH_HEAD文件

是一个版本链接，指向着目前已经从远程仓库取下来的分支的末端版本

```
git fetch
```

这将更新git remote 中所有的远程repo 所包含分支的最新commit-id, 将其记录到FETCH_HEAD文件中

### ORIG_HEAD文件

针对某些 危险操作 ，Git通过记录HEAD指针的上次所在的位置ORIG_HEAD提供了回退的功能。当你发现某些操作失误了，比如错误的reset到了一个很早很早的版本，可以使用 git reset --hard ORIG_HEAD回退到上一次reset之前。

Git在1.8.5版本之后，加入了HEAD@{}功能，它通过一个链表记录HEAD的移动路径。

输入 git reflog，结果类似于：

```
$ git reflog
ea34578 HEAD@{0}: reset: moving to HEAD^
d628164 HEAD@{1}: commit: xxx
ea34578 HEAD@{2}: commit: xxxx
cb926e7 HEAD@{3}: commit: xxxx
```

每一次移动HEAD指针，Git都会将移动的路径通过链表串起来，链表头部的HEAD@{0}即HEAD指针。

但是HEAD@{1}并不一定是ORIG_HEAD！注意到，ORIG_HEAD仅仅是当进行 危险操作 （比如merge）时才会变更为HEAD指针的原值，而HEAD@{}链表则记录了每次HEAD的移动（包括commit）。

考虑以下情况：

1.commit -> 2.merge -> 3.commit

此时，HEAD@{0}、HEAD@{1}、HEAD@{2}分别指向3、2、1，而ORIG_HEAD指向的是1而非2。

显然，有了reflog命令后HEAD链表比不知道什么变过的ORIG_HEAD更好用，因此如果你使用的是1.8.5版本之后的Git，推荐使用HEAD{}链表来代替ORIG_HEAD指针。

### packed-refs文件

对于大型仓库，Git将会周期性地运行垃圾回收将移除不必需要的对象，并将引用压缩至单个文件中，来提高性能。你可以执行下面命令来强制启动这一过程：

```
git gc
```

这将把在refs文件夹所有单独的分支与标签文件移动到在.git根目录中的一个叫做packed-refs的文件。

当查找一个引用时，git首先在refs目录下查找，如果未找到则到packed-refs文件中去查找。

如果你打开这个文件，你将会发现commit哈希与引用映射表：

```
00f54250cf4e549fdfcafe2cf9a2c90bc3800285 refs/heads/feature
0e25143693cfe9d5c2e83944bbaf6d3c4505eb17 refs/heads/master
bb883e4c91c870b5fed88fd36696e752fb6cf8e6 refs/tags/v0.9
```

垃圾回收对于正常的Git功能并不会有任何影响。但是，如果你想知道你的.git/refs文件为什么是空的话，现在你知道答案了。

## 相关运用

