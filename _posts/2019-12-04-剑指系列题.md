---
layout: post
title: 剑指系列题
subtitle: 对常见算法了然于胸
date: 2019-12-04
author: Li Yucang
catalog: true
tags:
  - 算法
---

# 剑指系列题

程序代码使用c++编写，如果对c++基本语法还不熟悉，建议先去了解，这样有助于更快的理解代码。

## 数组中重复的数字

**找出数组中重复的数字**

题目：在一个长度为n的数组里的所有数字都在`0～n-1`的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。例如，如果输入长度为7的数组{2,3,1,0,2,5,3}，那么对应的输出是重复的数字2或者3。

传统思路：

1. 先排序，再从头到尾扫描，时间复杂度O(nlogn)，空间复杂度O(1)
2. 使用哈希表，从头到尾扫描，表中不存在则加入，存在则找到该数，时间复杂度O(n)，空间复杂度O(n)

新思路：

在数组长度(n)>=数组值的范围(`0~n-1`)时，说明每个数组值(m)都可以放置到其值对应的数组序号(`[m] = m`)中，所以我们只需从头到尾扫描数组，将每个元素交换到其值对应的序号位置，如果对应的序号位置存在值且为m，那我们就找到了重复的数字。

```
bool duplicate(int numbers[], int length, int* duplication)
{
    if(numbers == nullptr || length <= 0)
        return false;

    for(int i = 0; i < length; ++i)
    {
        if(numbers[i] < 0 || numbers[i] > length - 1)
            return false;
    }

    for(int i = 0; i < length; ++i)
    {
        while(numbers[i] != i) // 注意：这里会一直找到当前序号对应的值
        {
            if(numbers[i] == numbers[numbers[i]])
            {
                *duplication = numbers[i];
                return true;
            }

            int temp = numbers[i];
            numbers[i] = numbers[temp];
            numbers[temp] = temp;
        }
    }

    return false;
}
```

代码中尽管有一个两重循环，但每个数字最多只要交换两次就能找到属于自己的位置，因此时间复杂度为O(n)。另外，所以的操作步骤都是在输入数组上进行的，不需要额外分配内存，因此，空间复杂度为O(1)。

**不修改数组找出重复的数字**

题目：在一个长度为n+1的数组里的所有数字都在`1～n`的范围内，所以数组中至少有一个数字是重复的。请找出数组中任意一个重复的数字，但不能修改输入的数组。例如，如果输入长度为8的数组{2,3,5,4,3,2,6,7}，那么对应的输出是重复的数字2或者3。

传统思路：

1. 使用哈希表，从头到尾扫描，表中不存在则加入，存在则找到该数，时间复杂度O(n)，空间复杂度O(n)

新思路：

假如没有重复的数字，那么在从1~n的范围里只有n个数字。由于数组里包含超过n个数字，所以一定包含里重复的数字。

我们把从`1~n`的数字从中间的数字m分为两部分，前面一半为`1~m`，后面一半为`m+1~n`。如果`1~m`的数字的数目超过m，那么这一半的区间一定包含重复的数字。否则，另一半`m+1~n`的区间里一定包含重复的数字。我们可以继续把包含重复数字的区间一分为二，直到找到一个重复的数字。这个过程和二分查找算法很类似，只是多了一步统计区间里数字的数目。

```
int countRange(const int* numbers, int length, int start, int end);

int getDuplication(const int* numbers, int length)
{
    if(numbers == nullptr || length <= 0)
        return -1;

    int start = 1;
    int end = length - 1;
    while(end >= start)
    {
        int middle = ((end - start) >> 1) + start;
        int count = countRange(numbers, length, start, middle);
        if(end == start)
        {
            if(count > 1)
                return start;
            else
                break;
        }

        if(count > (middle - start + 1))
            end = middle;
        else
            start = middle + 1;
    }
    return -1;
}

int countRange(const int* numbers, int length, int start, int end)
{
    if(numbers == nullptr)
        return 0;

    int count = 0;
    for(int i = 0; i < length; i++)
        if(numbers[i] >= start && numbers[i] <= end)
            ++count;
    return count;
}
```

时间复杂度O(nlogn)，空间复杂度O(1)，和传统思路相比，是以时间换空间。而且这种方法没法保证找出所以重复的数字，因为下面两种情况会都认为区间内不存在重复数字：

1. 在一个区间内所有数字都只出现一次
2. 在一个区间内有的数字出现多次有的数字没有出现但总个数与区间长度相同

## 二维数组中的查找

题目：在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。

传统思路：

从数组选取一个数字，分3种情况来分析查找。选取数字和查找数字相等，结束查处。如果选取数字小于查找数字，要查找的数字应该在当前选取位置的右边或者下边。同样，如果选取的数字大于要查找的数字，那么要查找的数字应该在选取位置的上边或者左边：

![](/img/localBlog/1580193684787.jpg)

在这种分析中，由于要查找的数字相对于当前选取位置有可能在两个区域中出现，而且这两个区域还有重叠，这问题看起来就复杂了。

新思路：

如果我们从数组的一个角上选取数字来和要查找的数字进行比较，那么情况是不是变简单了呢？我们以选取数组右上角的数字为例，目标数字为7：

![](/img/localBlog/1580193925413.jpg)

我们发现每一步都可以缩小查找范围，直到找到要查找的数字。

```
bool Find(int* matrix, int rows, int columns, int number)
{
    bool found = false;

    if(matrix != nullptr && rows > 0 && columns > 0)
    {
        int row = 0;
        int column = columns - 1;
        while(row < rows && column >=0)
        {
            if(matrix[row * columns + column] == number)
            {
                found = true;
                break;
            }
            else if(matrix[row * columns + column] > number)
                -- column;
            else
                ++ row;
        }
    }

    return found;
}
```

## 替换空格

题目：请实现一个函数，把字符串中的每个空格替换成"%20"。例如输入“We are happy.”，则输出“We%20are%20happy.”。

传统思路：

这里我们假设我们可以在原来的字符串上进行替换，并保证输入字符串后面有足够多的空余内存。从头到尾扫描字符串，每次碰到空格字符的时候进行替换。由于是把一个字符替换成3个字符，我们必须要把空格后的所以字符都后移2个字节。

![](/img/localBlog/1580200002126.jpg)

时间复杂度是O(n^2)。

新思路：

先遍历一次字符串，统计出空格的总数，并由此计算出替换之后的字符串的总长度。我们从字符串后面开始复制和替换，准备两个指针：P1和P2，P1指向原始字符串的末尾，而P2指向替换之后的字符串的末尾。

![](/img/localBlog/1580200238829.jpg)

```
/*length 为字符数组str的总容量，大于或等于字符串str的实际长度*/
void ReplaceBlank(char str[], int length)
{
    if(str == nullptr && length <= 0)
        return;

    /*originalLength 为字符串str的实际长度*/
    int originalLength = 0;
    int numberOfBlank = 0;
    int i = 0;
    while(str[i] != '\0')
    {
        ++ originalLength;

        if(str[i] == ' ')
            ++ numberOfBlank;

        ++ i;
    }

    /*newLength 为把空格替换成'%20'之后的长度*/
    int newLength = originalLength + numberOfBlank * 2;
    if(newLength > length)
        return;

    int indexOfOriginal = originalLength;
    int indexOfNew = newLength;
    while(indexOfOriginal >= 0 && indexOfNew > indexOfOriginal)
    {
        if(str[indexOfOriginal] == ' ')
        {
            str[indexOfNew --] = '0';
            str[indexOfNew --] = '2';
            str[indexOfNew --] = '%';
        }
        else
        {
            str[indexOfNew --] = str[indexOfOriginal];
        }

        -- indexOfOriginal;
    }
}
```

相关题目：有两个排序的数组A1和A2，内存在A1的末尾有足够多的空余空间容纳A2。请实现一个函数，把A2中的所有数字插入A1中，并且所有的数字是排序的。

和前面的例题一样，我们可以从尾到头比较A1和A2中的数字，并把较大的数字复制到A1中的合适位置。

## 从尾到头打印链表

题目：输入一个链表的头结点，从尾到头反过来打印出每个结点的值。

```
struct ListNode
{
    int       m_nValue;
    ListNode* m_pNext;
};
```

1，将链表中链接节点的指针翻转过来，改变链表的方向，就可以从来到尾输出量。但这会改变原来链表但结构。

2，假设不能改变链表结构，使用栈来实现“后进先出”的顺序：

```
#include <stack>

void PrintListReversingly_Iteratively(ListNode* pHead)
{
    std::stack<ListNode*> nodes;

    ListNode* pNode = pHead;
    while(pNode != nullptr)
    {
        nodes.push(pNode);
        pNode = pNode->m_pNext;
    }

    while(!nodes.empty())
    {
        pNode = nodes.top();
        printf("%d\t", pNode->m_nValue);
        nodes.pop();
    }
}
```

3，既然想到了用栈来实现，而递归本质上就是一个栈结构，于是很自然又想到用递归来实现。要实现反过来输出链表，我们每访问一个节点时，先递归输出它后面的节点，再输出该节点自身：

```
void PrintListReversingly_Recursively(ListNode* pHead)
{
    if(pHead != nullptr)
    {
        if (pHead->m_pNext != nullptr)
        {
            PrintListReversingly_Recursively(pHead->m_pNext);
        }
 
        printf("%d\t", pHead->m_nValue);
    }
}
```

递归代码看起来很简洁，但有一个问题：当链表非常长的时候，就会导致函数调用的层级很深，有可能导致函数调用栈溢出。显然用栈基于循环实现的代码鲁棒性要好一些。

## 重建二叉树

题目：输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2, 4, 7, 3, 5, 6, 8}和中序遍历序列{4, 7, 2, 1, 5, 3, 8, 6}，则重建出二叉树并输出它的头结点，如图所示：

![](/img/localBlog/1580284597700.jpg)

二叉树节点定义如下：

```
struct BinaryTreeNode 
{
    int                    m_nValue; 
    BinaryTreeNode*        m_pLeft;  
    BinaryTreeNode*        m_pRight; 
};
```

二叉树的前序遍历序列中，第一个数字总是树的根结点的值。但在中序遍历序列中，根结点但值在序列的中间，左子树的节点位于根结点的值的左边，而右子树的节点位于根结点的值的右边：

![](/img/localBlog/1580284386421.jpg)

我们可以找到左、右子树的前序遍历序列和中序遍历序列，接着通过递归用同样的方法分别构建左、右子树：

```

BinaryTreeNode* ConstructCore(int* startPreorder, int* endPreorder, int* startInorder, int* endInorder);

BinaryTreeNode* Construct(int* preorder, int* inorder, int length)
{
    if(preorder == nullptr || inorder == nullptr || length <= 0)
        return nullptr;

    return ConstructCore(preorder, preorder + length - 1,
        inorder, inorder + length - 1);
}

BinaryTreeNode* ConstructCore
(
    int* startPreorder, int* endPreorder, 
    int* startInorder, int* endInorder
)
{
    // 前序遍历序列的第一个数字是根结点的值
    int rootValue = startPreorder[0];
    BinaryTreeNode* root = new BinaryTreeNode();
    root->m_nValue = rootValue;
    root->m_pLeft = root->m_pRight = nullptr;

    if(startPreorder == endPreorder)
    {
        if(startInorder == endInorder && *startPreorder == *startInorder)
            return root;
        else
            throw std::exception("Invalid input.");
    }

    // 在中序遍历中找到根结点的值
    int* rootInorder = startInorder;
    while(rootInorder <= endInorder && *rootInorder != rootValue)
        ++ rootInorder;

    if(rootInorder == endInorder && *rootInorder != rootValue)
        throw std::exception("Invalid input.");

    int leftLength = rootInorder - startInorder;
    int* leftPreorderEnd = startPreorder + leftLength;
    if(leftLength > 0)
    {
        // 构建左子树
        root->m_pLeft = ConstructCore(startPreorder + 1, leftPreorderEnd, 
            startInorder, rootInorder - 1);
    }
    if(leftLength < endPreorder - startPreorder)
    {
        // 构建右子树
        root->m_pRight = ConstructCore(leftPreorderEnd + 1, endPreorder,
            rootInorder + 1, endInorder);
    }

    return root;
}
```

## 二叉树的下一个结点

题目：给定一棵二叉树和其中的一个结点，如何找出中序遍历顺序的下一个结点？树中的结点除了有两个分别指向左右子结点的指针以外，还有一个指向父结点的指针。

我们以下图这棵树（中序遍历序列是{d,b,h,e,i,a,f,c,g}）来分析如何找出二叉树的下一个节点：

![](/img/localBlog/1580287361076.jpg)

1，如果一个节点有右子树，那么它的下一个节点就是它的右子树中最左子节点。也就是说，从右子节点出发一直沿着指向左子节点的指针，我们就可以找到它的下一个节点。图中节点b的下一个节点是h，节点a的下一个节点是f。

2，接着我们分析一个节点没有右子树的情形。如果节点是它父节点的左子节点，那么它的下一个节点就是它的父节点。图中节点d的下一个节点是b，节点f的下一个节点是c。

3，如果一个节点既没有右子树，并且它还是它父节点的右子节点，那么这种情形就比较复杂。我们可以沿着指向父节点的指针一直向上遍历，直到找到一个是它父节点的左子节点的节点。如果这样的节点存在，那么这个节点就是我们要找的下一个节点。如果不存在，则没有下一个节点。

```
struct BinaryTreeNode
{
    int                    m_nValue;
    BinaryTreeNode*        m_pLeft;
    BinaryTreeNode*        m_pRight;
    BinaryTreeNode*        m_pParent;
};

BinaryTreeNode* GetNext(BinaryTreeNode* pNode)
{
    if(pNode == nullptr)
        return nullptr;

    BinaryTreeNode* pNext = nullptr;
    if(pNode->m_pRight != nullptr)
    {
        BinaryTreeNode* pRight = pNode->m_pRight;
        while(pRight->m_pLeft != nullptr)
            pRight = pRight->m_pLeft;

        pNext = pRight;
    }
    else if(pNode->m_pParent != nullptr)
    {
        BinaryTreeNode* pCurrent = pNode;
        BinaryTreeNode* pParent = pNode->m_pParent;
        while(pParent != nullptr && pCurrent == pParent->m_pRight)
        {
            pCurrent = pParent;
            pParent = pParent->m_pParent;
        }

        pNext = pParent;
    }

    return pNext;
}
```