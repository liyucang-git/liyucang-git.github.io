---
layout: post
title: 微前端技术原理
subtitle: 微前端之背景与实践
date: 2023-08-04
author: Li Yucang
catalog: true
tags:
  - 微前端
  - 架构
---

# 微前端技术原理

## 背景

微前端是一种架构理念，它将较大的前端应用拆分为若干个可以独立交付的前端应用。这样的好处是每个应用大小及复杂度相对可控。在合理拆分应用的前提下，微前端能降低应用之间的耦合度，提升每个团队的自治能力。

目前市面有各类不同的微前端方案，但没有完美的解决方案。微前端方案通常需要考虑：应用加载机制、通信机制、代码隔离机制等问题。

![](/img/localBlog/149610173-ea936a56-98a1-416f-a2e5-9058574b32cb.png)

**核心价值**

微前端架构具备以下几个核心价值：

* **技术栈无关**：主框架不限制接入应用的技术栈，微应用具备完全自主权

* **独立开发、独立部署**：微应用仓库独立，前后端可独立开发，部署完成后主框架自动完成同步更新

* **增量升级**：在面对各种复杂场景时，我们通常很难对一个已经存在的系统做全量的技术栈升级或重构，而微前端是一种非常好的实施渐进式重构的手段和策略

* **独立运行时**：每个微应用之间状态隔离，运行时状态不共享

**使用场景**

前端工程化中，一个前端项目常以组件或模块的粒度进行代码拆分，然后通过 script 标签、npm 包、submodules 或者动态加载（Dynamic import）等形式将代码集成到项目中。而微前端则是以更大的粒度对代码进行上下文划分，将较庞大的应用拆分成多个技术栈独立的应用，再通过技术手段将若干应用集成在一个容器内。

如果项目中存在以下问题，可参考微前端架构进行优化：

* **存量系统如何渐进式地拥抱新技术**：存量系统的技术栈老旧，重构和开发成本高。在做新的功能开发时可以考虑采用与老项目不同的技术栈，通过微前端的方案将新的功能与老系统进行集成。同时微前端架构也给老旧系统的技术升级和平滑迁移提供保障。

* **大型系统的开发及沟通成本上升**：通过分析业务功能，将系统拆分成多个独立子系统，使每个子系统能独立开发、运行及部署。将工程复杂度拆分并限制在子系统单元内。避免随需求迭代，项目维护成本增大，跨部门沟通困难导致效率低下等问题。

**为什么不用 iframe**

iframe 最大的特性就是提供了浏览器原生的硬隔离方案，不论是样式隔离、js 隔离这类问题统统都能被完美解决。但他的最大问题也在于他的隔离性无法被突破，导致应用间上下文无法被共享，随之带来的开发体验、产品体验的问题。

1、**url 不同步**。浏览器刷新 iframe url 状态丢失、后退前进按钮无法使用。

2、**UI 不同步，DOM 结构不共享**。想象一下屏幕右下角 1/4 的 iframe 里来一个带遮罩层的弹框，同时我们要求这个弹框要浏览器居中显示，还要浏览器 resize 时自动居中..

3、**全局上下文完全隔离，内存变量不共享**。iframe 内外系统的通信、数据同步等需求，主应用的 cookie 要透传到根域名都不同的子应用中实现免登效果。

4、**慢**。每次子应用进入都是一次浏览器上下文重建、资源重新加载的过程。

其中有的问题比较好解决(问题1)，有的问题我们可以睁一只眼闭一只眼(问题4)，但有的问题我们则很难解决(问题3)甚至无法解决(问题2)，而这些无法解决的问题恰恰又会给产品带来非常严重的体验问题， 最终导致我们舍弃了 iframe 方案。


## 核心实现

### 应用加载

**JS Entry 和 Html Entry**

entry意为入口。无论是qiankun还是garfish都需要子应用在入口js中提供生命周期钩子，以供主应用在合适的时机调用。比如qiankun需要子应用至少导出 bootstrap、mount、unmount 三个生命周期钩子；garifsh需要子应用导出provider生命周期钩子。

通常有两种entry: JS Entry 和 Html Entry。

Js Entry 的缺点是：

* 子应用更新打包后的 js bundle 名称会变化，主应用需要保证每次获取都是最新的 js bundle。

* 子应用所有资源打包到一个文件中，会失去 css 提取、静态资源并行加载、首屏加载(体积巨大)等优化。

* 需要在子应用打包过程中，修改相应的配置以补全子应用 js 资源的路径。

因此需要使用 html entry，你只需要指定子应用的 html 入口即可，微前端框架在加载 html 字符串后，从中提取出 css、js 资源，运行子应用时，安装样式、执行脚本，运行脚本中提供的生命周期钩子。因此优点也很明显：

* 无需关心应用打包后的 js 名称变化的问题。

* 仍然可以享受 css提取、静态资源并行加载（内部使用 Promise.all 并行发出请求资源）、首屏加载等优化。

* 请求资源时，自动补全资源路径。

解析 html 字符串的流程如下：

![](/img/localBlog/WX20230804-040602.png)

不难发现该流程中没有马上执行 script 标签内的脚本，这是因为 script 标签内的脚本需要等到 JS 沙箱创建完后才执行，JS 沙箱相关内容将在后面的小节介绍。

### 路由管理

一般我们使用 Hash 或者 History 模式来对路由进行监听，如 hashchange 或 popstate 事件。

目前常见的微前端解决方案主要是路由驱动的。在微前端的基座，进行子应用的路由注册，如 { path: '/microA/*' } ，基座根据路由匹配情况，按需挂载子应用。具体路由跳转规则由子应用接管响应。

1、无论是qiankun 还是 garfish ，都要子应用注册的时候，提供子应用激活规则 (路由字符串 或 函数)。因此，监听 hashchange 和 popstate 事件，在事件回调函数中，根据注册的子应用激活规则，卸载/激活子应用。

2、以 Vue-Router 的 history 模式为例，在切换路由时，通常会做三件重要事情：执行一连串的 hook 函数、更新url、router-view 更新，其中更新 url，就是通过 pushState/replaceState 的形式实现的。因此重写并增强 history.pushState 和 history.replaceState 方法，在执行它们的时候，可以拿到执行前、执行后的 url，对比是否有变化，如果有，根据注册的子应用激活规则，卸载/激活子应用。

### 隔离机制

支持样式隔离和 JS 沙箱机制，以保证应用之间的样式或全局变量、事件等互不干扰。在应用卸载时，应当对子应用中产生的事件、全局变量、样式表等进行卸载。

对于新的项目，做好样式隔离的方式包括采用 CSS Module、CSS in JS 或规范使用命名空间等。对于已有项目的 CSS 隔离，可以在打包阶段利用工具（如 postcss）自动对样式添加前缀。

实现 JS 沙箱机制可以借助 Proxy 和 with 的能力，分别做对 Window 对象的访问进行拦截和修改子应用作用域的操作。不支持 Proxy 的宿主环境，可以采用快照的思路：对进入子应用前的 Window 对象进行快照，用于后续卸载子应用时还原 Window 对象；在卸载子应用时对 Window 对象进行快照，用于后续再次加载子应用时还原 Window 对象。

#### JS 隔离

Js 沙箱做的事情可以用两句话概括：

1、为每一个子应用创建一个专属的 “window 对象” (不是真的 window 对象，下面会解释)；

2、执行子应用时，将新建的 “window 对象” 作为子应用脚本的全局变量，子应用对全局变量的读写操作都作用到这个 “window 对象”中。

##### 沙箱

先介绍沙箱，沙箱通常有三种：

**1、LegacySandbox（依赖 Proxy)**

![](/img/localBlog/WX20230804-042549.png)

缺点：虽然子应用之间的状态是隔离的，但是父子应用都会修改同一个 window 对象，互相污染。

**2、ProxySandbox （依赖 Proxy）**

稳定后会取代 LegacySandbox。

**3、SnapshotSandbox**

对于不支持 Proxy 的浏览器， SnapshotSandbox 是一种替代方案。

##### 劫持全局方法

除了 JS 沙箱，还需要劫持一些全局方法，如 计时器、 window 事件监听、window.history 事件监听、动态向 Head/Body元素添加子元素方法(如 appendChild、insertBefore)。

这里重点介绍一下 计时器劫持 和 动态添加子元素方法的劫持：

**1、计时器劫持**

我们知道，setInterval() 调用后会返回一个非零数值，用来标识通过setInterval()创建的计时器，这个值可以用来作为clearInterval()的参数来清除对应的计时器 。

因此，原理很简单：

1、在子应用运行时调用 setInterval()，可以把返回的定时器标识收集在一个数组中(假设数组名叫 intervals)，在子应用失活时通过调用 clearInterval() 取消这些定时器；

2、在子应用运行时调用 clearInterval(某个定时器标识)，从intervals中删除该定时器标识。

![](/img/localBlog/WX20230804-042749.png)

**2、动态添加子元素方法的劫持**

主要劫持了：

* HTMLHeadElement.prototype.appendChild

* HTMLHeadElement.prototype.removeChild

* HTMLBodyElement.prototype.appendChild

* HTMLBodyElement.prototype.removeChild

* HTMLHeadElement.prototype.insertBefore

* Document.prototype.createElement

以上劫持仅处理动态添加的 link、style、script 标签。

**createElement**

子应用调用 createElement，会触发 sandbox proxy 对象上的 get 拦截器，从而可以判断某个元素是否由子应用创建，如果是，这个元素才可以被 appendChild、insertBefore 的劫持处理。

**appendChild、insertBefore**

添加 link、style 标签

会做 css 隔离相关处理(下一小节介绍)。如果是 link 标签，会使用 fetch 获取到样式表内容字符串，外包一层 style 标签，插入进子应用的 DOM 中。动态添加的样式标签会被收集起来 (假设收集到一个名为 dynamicStyleSheetElements 的数组中)。


添加 script 标签

1、对于外部 script 脚本，先使用 fetch 获取到脚本内容字符串。

2、得到脚本后，指定 js 沙箱的 proxy 对象为全局对象，执行脚本内容，同时触发 load 和 error 两个事件。

3、将 script 标签以注释的形式添加到子应用容器中。

**removeChild**

判断如果是子应用创建的link、style、script 标签，就从子应用容器中移除它们。


#### CSS 隔离

**基本的隔离方法**

上一小节中介绍了，子应用创建的样式标签会添加到子应用容器下，那么在子应用卸载的时候，样式表也能跟着一起被卸载，从而避免子应用之间的样式污染。

**Shadow DOM 样式隔离**

给子应用容器节点挂载一个 shadow DOM，已实现父子应用、多个子应用之间的样式隔离。


**Scoped 样式隔离**

一句话理解，就是给子应用的所有样式规则添加一个 scope（类似 Vue 中的 )。

这里以 qiankun 的实现来讲解原理：

1、创建子应用容器节点后，通过 document.querySelectorAll('style') 找到所有 style 元素

2、对于普通样式规则，通过 for 循环遍历 style.sheet.cssRules，转换 css 样式。

```
// 假如子应用名字叫 child
// 转换前
.app-main {
    font-size: 14px;
}
// 转换后
div[data-qiankun="child"] .app-main {
    font-size: 14px;
}
```

3、对于@media、@supports

```
// 转换前
@media screen and (max-width: 300px) {
    div {
        font-size: 14px
    }
}

// 转换后
@media screen and (max-width: 300px) {
    div[data-qiankun="child"] div {
        font-size: 14px
    }
}
```

4、对于每个 style 元素，注册一个 MutationObserver 监听元素的变化，变化的时候对元素内容也做上述转换

```
const mutator = new MutationObserver((mutations) => {
  for (let i = 0; i < mutations.length; i += 1) {
    const mutation = mutations[i];
    if (mutation.type === 'childList') {
        // 转换操作
    }
  }
});
mutator.observe(styleNode, { childList: true });
```

注：对于通过动态 appendChild 到 head 或 body 元素 / 动态 insertBefore 到 head 元素的样式节点，也会做上述转换。

### 消息通信

合理划分应用，可以避免频繁的跨应用通信。同时应当避免子应用之间直接通信。

常见的消息通信机制可以通过原生 CustomEvent 类实现，子应用通过 dispatchEvent 和 addEventListener 来对自定义事件进行下发和监听。除此之外，借助 props 通过主应用向子应用传参，达到通信目的也是常见方法。

应用之间的通信能通过发布订阅模实现，无论是 qiankun 还是 garfish 的通信 API，本质原理都类似 EventEmitter。

### 依赖管理

常见的微前端框架中，基座应用统一对子应用的状态进行管理。根据路由和子应用状态，按需触发生命周期函数，做请求加载、渲染、卸载等动作。而多个子应用间可能存在一些公共库的依赖。

为减少这类资源的重复加载，通常可以借助 webpack5 的 Module Federation 在构建时进行公共依赖的配置，实现运行时依赖共享的能力。除了使用打包工具的能力，也可以从代码层面通过实现类 external 功能对公共依赖进行管理。

### 子应用预加载

在第一小节介绍 Html Entry 的时候，我们知道解析 html 包含了几个步骤：通过 fetch 获取 html 字符串、将外部样式表 url 放入 styles 数组中、将内联和外部 js 放入 scritps 数组中。

因此，预加载的时候可以通过遍历需要预加载的应用对应的 styles 和 scripts 数组，在 requestIdelCallback 中使用 fetch 获取其中的外部资源，并将它们缓存下来。这样在下次获取这些资源时，就能从缓存中直接拿到。

值得一提的是，这里所说的“缓存”是指存在代码中的全局变量中，所以，即使将 Chrome Devtools 中 Network 的 Disable cache 选项打开，只要资源预加载成功、页面没有重新刷新，也是会走“缓存”。


