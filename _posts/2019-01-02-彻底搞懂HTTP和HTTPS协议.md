---
layout: post
title: 彻底搞懂HTTP和HTTPS协议
subtitle: 探讨http和https的发展史
date: 2019-01-02
author: Li Yucang
catalog: true
tags:
    - web安全
    - http
    - https
---

# 彻底搞懂HTTP和HTTPS协议

## HTTP发展历史

http协议(超文本传输协议)，是一个基于请求与响应，无状态的，应用层的协议，常基于TCP/IP协议传输数据，互联网上应用最为广泛的一种网络协议,所有的WWW文件都必须遵守这个标准。设计HTTP的初衷是为了提供一种发布和接收HTML页面的方法。

设计HTTP最初的目的是为了将超文本标记语言(HTML)文档从Web服务器传送到客户端的浏览器。也是说对于前端来说，我们所写的HTML页面将要放在我们的 web 服务器上，用户端通过浏览器访问url地址来获取网页的显示内容；

随着web2.0的到来，我们的网站从单纯的html网页模式向内容更丰富、更加注重交互并以用户为中心的应用创新，出现了如blog，sns等产品，同时我们的 HTML 页面有了 CSS，Javascript，随着Ajax的出现和大量使用，更是提升了我们对于网站交互的体验，以上这些其实都是基于 HTTP 协议的；

同样到了移动互联网时代，我们页面可以跑在手机端浏览器里面，但是和 PC 相比，手机端的网络情况更加复杂，这使得我们开始了不得不对 HTTP 进行深入理解并不断优化过程中。

http协议发展历史：

版本|产生时间|内容|发展现状
-|-|-|-
HTTP/0.9|1991年|不涉及数据包传输，规定客户端和服务器之间通信格式，只能GET请求|没有作为正式的标准
HTTP/1.0|1996年|传输内容格式不限制，增加PUT、PATCH、HEAD、 OPTIONS、DELETE命令|正式作为标准
HTTP/1.1|1997年|持久连接(长连接)、节约带宽、HOST域、管道机制、分块传输编码|2015年前使用最广泛
HTTP/2|2015年|多路复用、服务器推送、头信息压缩、二进制协议等|逐渐覆盖市场

### HTTP 0.9

HTTP 是基于 TCP/IP 协议的应用层协议，最早版本是1991年发布的0.9版。该版本极其简单：

1. 只接受 GET 一种请求方法，且不支持请求头。
2. 协议规定，服务器只能回应HTML格式的字符串，不能回应别的格式。
3. 由于该版本不支持 POST 方法，所以客户端无法向服务器传递太多信息。

````
客户端请求格式
GET /index.html

服务器响应格式
<html>
  <body>Hello World</body>
</html>
````

### HTTP1.0

HTTP1.0最早在网页中使用是在1996年，那个时候只是使用一些较为简单的网页上和网络请求上。这是第一个在通讯中指定版本号的HTTP 协议版本，至今仍被广泛采用，特别是在代理服务器中。

1. 首先，任何格式的内容都可以发送。这使得互联网不仅可以传输文字，还能传输图像、视频、二进制文件。这为互联网的大发展奠定了基础。

2. 其次，除了GET命令，还引入了POST命令和HEAD命令，丰富了浏览器与服务器的互动手段。

3. 再次，HTTP请求和回应的格式也变了。除了数据部分，每次通信都必须包括头信息（HTTP header），用来描述一些元数据。

4. 其他的新增功能还包括状态码（status code）、多字符集支持、多部分发送（multi-part type）、权限（authorization）、缓存（cache）、内容编码（content encoding）等。

````
客户端请求格式
GET /index.html HTTP/1.0
User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_5)
Accept: */*

服务器响应格式
HTTP/1.0 200 OK 
Content-Type: text/plain
Content-Length: 137582
Expires: Thu, 05 Dec 1997 16:00:00 GMT
Last-Modified: Wed, 5 August 1996 15:55:28 GMT
Server: Apache 0.84

<html>
  <body>Hello World</body>
</html>
````

回应的格式是"头信息 + 一个空行（\r\n） + 数据"。其中，第一行是"协议版本 + 状态码（status code） + 状态描述"。

#### Content-Type 字段

关于字符的编码，1.0版规定，头信息必须是 ASCII 码，后面的数据可以是任何格式。因此，服务器回应的时候，必须告诉客户端，数据是什么格式，这就是Content-Type字段的作用。

下面是一些常见的Content-Type字段的值：

````
text/plain
text/html
text/css
image/jpeg
image/png
image/svg+xml
audio/mp4
video/mp4
application/javascript
application/pdf
application/zip
application/atom+xml
````

这些数据类型总称为MIME type，每个值包括一级类型和二级类型，之间用斜杠分隔。

除了预定义的类型，厂商也可以自定义类型。

`application/vnd.debian.binary-package`

上面的类型表明，发送的是Debian系统的二进制数据包。

MIME type还可以在尾部使用分号，添加参数。

`Content-Type: text/html; charset=utf-8`

上面的类型表明，发送的是网页，而且编码是UTF-8。

客户端请求的时候，可以使用Accept字段声明自己可以接受哪些数据格式。

`Accept: */*`

上面代码中，客户端声明自己可以接受任何格式的数据。

MIME type不仅用在HTTP协议，还可以用在其他地方，比如HTML网页。

````
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />等同于 <meta charset="utf-8" />
````

#### Content-Encoding 字段

由于发送的数据可以是任何格式，因此可以把数据压缩后再发送。Content-Encoding字段说明数据的压缩方法。

````
Content-Encoding: gzip
Content-Encoding: compress
Content-Encoding: deflate
````

客户端在请求时，用Accept-Encoding字段说明自己可以接受哪些压缩方法。

`Accept-Encoding: gzip, deflate`

#### 局限性

HTTP/1.0 版的主要缺点是，每个TCP连接只能发送一个请求。发送数据完毕，连接就关闭，如果还要请求其他资源，就必须再新建一个连接。

TCP连接的新建成本很高，因为需要客户端和服务器三次握手，并且开始时发送速率较慢（slow start）。所以，HTTP 1.0版本的性能比较差。随着网页加载的外部资源越来越多，这个问题就愈发突出了。

为了解决这个问题，有些浏览器在请求时，用了一个非标准的Connection字段。

`Connection: keep-alive`

这个字段要求服务器不要关闭TCP连接，以便其他请求复用。服务器同样回应这个字段。

`Connection: keep-alive`

一个可以复用的TCP连接就建立了，直到客户端或服务器主动关闭连接。但是，这不是标准字段，不同实现的行为可能不一致，因此不是根本的解决办法。

### HTTP1.1

1997年1月，HTTP/1.1 版本发布，只比 1.0 版本晚了半年。它进一步完善了 HTTP 协议，一直用到了20年后的今天，直到现在还是最流行的版本。 持久连接被默认采用，并能很好地配合代理服务器工作。还支持以管道方式同时发送多个请求，以便降低线路负载，提高传输速度。

#### 持久连接

1.1 版的最大变化，就是引入了持久连接（persistent connection），即TCP连接默认不关闭，可以被多个请求复用，不用声明`Connection: keep-alive`

客户端和服务器发现对方一段时间没有活动，就可以主动关闭连接。不过，规范的做法是，客户端在最后一个请求时，发送Connection: close，明确要求服务器关闭TCP连接。目前，对于同一个域名，大多数浏览器允许同时建立6个持久连接。

#### 管道机制

1.1 版还引入了管道机制（pipelining），即在同一个TCP连接里面，客户端可以同时发送多个请求。这样就进一步改进了HTTP协议的效率。

举例来说，客户端需要请求两个资源。以前的做法是，在同一个TCP连接里面，先发送A请求，然后等待服务器做出回应，收到后再发出B请求。管道机制则是允许浏览器同时发出A请求和B请求，但是服务器还是按照顺序，先回应A请求，完成后再回应B请求。

#### Content-Length 字段

一个TCP连接现在可以传送多个回应，势必就要有一种机制，区分数据包是属于哪一个回应的。这就是Content-length字段的作用，用于声明本次回应的数据长度。

`Content-Length: 3495`

上面代码告诉浏览器，本次回应的长度是3495个字节，后面的字节就属于下一个回应了。

在1.0版中，Content-Length字段不是必需的，因为浏览器发现服务器关闭了TCP连接，就表明收到的数据包已经全了。

#### 分块传输编码

使用Content-Length字段的前提条件是，服务器发送回应之前，必须知道回应的数据长度。

对于一些很耗时的动态操作来说，这意味着，服务器要等到所有操作完成，才能发送数据，显然这样的效率不高。更好的处理方法是，产生一块数据，就发送一块，采用"流模式"（stream）取代"缓存模式"（buffer）。
因此，1.1版规定可以不使用Content-Length字段，而使用"分块传输编码"（chunked transfer encoding）。只要请求或回应的头信息有`Transfer-Encoding`字段，就表明回应将由数量未定的数据块组成。

`Transfer-Encoding: chunked`

每个非空的数据块之前，会有一个16进制的数值，表示这个块的长度。最后是一个大小为0的块，就表示本次回应的数据发送完了。下面是一个例子。

````
HTTP/1.1 200 OK
Content-Type: text/plain
Transfer-Encoding: chunked

25
This is the data in the first chunk

1C
and this is the second one

3
con

8
sequence

0
````

#### 缓存处理

在HTTP1.0中主要使用header里的If-Modified-Since,Expires来做为缓存判断的标准，HTTP1.1则引入了更多的缓存控制策略例如Entity tag，If-Unmodified-Since, If-Match, If-None-Match等更多可供选择的缓存头来控制缓存策略。

#### Range 和 Content-Range 字段

HTTP1.1则在请求头引入了Range和 Content-Range 头域，它允许只请求资源的某个部分，即返回码是206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接，把一个大的文件切割成小的文件块传输，产生了我们所谓的断点续传功能；

Range用于请求头中，指定第一个字节的位置和最后一个字节的位置，一般格式：

`Range:(unit=first byte pos)-[last byte pos]`

`Content-Range`用于响应头，指定整个实体中的一部分的插入位置，他也指示了整个实体的长度。在服务器向客户返回一个部分响应，它必须描述响应覆盖的范围和整个实体长度。一般格式：

`Content-Range: bytes (unit first byte pos) - [last byte pos]/[entity legth]`

#### 错误通知的管理

在HTTP1.1中新增了24个错误状态响应码，如409（Conflict）表示请求的资源与资源的当前状态发生冲突；410（Gone）表示服务器上的某个资源被永久性的删除。

#### 增加了多种请求方法

1.1版还新增了许多动词方法：PUT、PATCH、HEAD、 OPTIONS、DELETE

方法|说明|支持的http协议版本
-|-|-
GET|获取资源|1.0、1.1
POST|传输实体主体|1.0、1.1
PUT|传输文件|1.0、1.1
HEAD|获取报文首部|1.0、1.1
DElETE|删除文件|1.0、1.1
OPTIONS|询问支持的方法|1.1
TRACE|追踪路径|1.1
CONNECT|要求用隧道协议连接代理|1.1
LINK|建立和资源的连接|1.0
UNLINK|断开连接关系|1.0

#### Host头处理

客户端请求的头信息新增了Host字段，用来指定服务器的域名。

`Host: www.example.com`

在HTTP1.0中认为每台服务器都绑定一个唯一的IP地址，因此，请求消息中的URL并没有传递主机名（hostname）。但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机（Multi-homed Web Servers），并且它们共享一个IP地址。HTTP1.1的请求消息和响应消息都应支持Host头域，且请求消息中如果没有Host头域会报告一个错误（400 Bad Request）。

作者：似水牛年
链接：https://www.jianshu.com/p/1eb384ea0aef
来源：简书
简书著作权归作者所有，任何形式的转载都请联系作者获得授权并注明出处。

#### 局限性

虽然1.1版允许复用TCP连接，但是同一个TCP连接里面，所有的数据通信是按次序进行的。服务器只有处理完一个回应，才会进行下一个回应。要是前面的回应特别慢，后面就会有许多请求排队等着。这称为"队头堵塞"（Head-of-line blocking）。

为了避免这个问题，只有两种方法：一是减少请求数，二是同时多开持久连接。这导致了很多的网页优化技巧，比如合并脚本和样式表、将图片嵌入CSS代码、域名分片（domain sharding）等等。如果HTTP协议设计得更好一些，这些额外的工作是可以避免的。

### SPDY 协议

2009年，谷歌公开了自行研发的 SPDY 协议，主要解决 HTTP/1.1 效率不高的问题。

SPDY（读作“SPeeDY”）是Google开发的基于TCP的应用层协议，用以最小化网络延迟，提升网络速度，优化用户的网络使用体验。SPDY并不是一种用于替代HTTP的协议，而是对HTTP协议的增强。新协议的功能包括数据流的多路复用、请求优先级以及HTTP报头压缩。

互联网工程任务组（IETF）对谷歌提出的SPDY协议进行了标准化，于2015年5推出了类似于SPDY协议的 HTTP 2.0 协议标准（简称HTTP/2）。谷歌因此宣布放弃对SPDY协议的支持，转而支持HTTP/2。此外，著名的开源HTTP服务器软件 Nginx 也于2015年9月移除了对SPDY的支持，转而支持HTTP/2。因此，建议新的网站不要部署SPDY，转为部署HTTP/2。

所以，从历史上来看，SPDY协议只是 HTTP/2 的基础，其主要特性都在 HTTP/2 之中得到继承。鉴于此，我们不必要过多了解这个协议的具体内容了。

### HTTP/2

2015年，HTTP/2 发布。它不叫 HTTP/2.0，是因为标准委员会不打算再发布子版本了，下一个新版本将是 HTTP/3。

#### 二进制协议

HTTP/1.1 版的头信息肯定是文本（ASCII编码），数据体可以是文本，也可以是二进制。HTTP/2 则是一个彻底的二进制协议，头信息和数据体都是二进制，并且统称为"帧"（frame）：头信息帧和数据帧。

二进制协议的一个好处是，可以定义额外的帧。HTTP/2 定义了近十种帧，为将来的高级应用打好了基础。如果使用文本实现这种功能，解析数据将会变得非常麻烦，二进制解析则方便得多。

既然又要保证HTTP的各种动词，方法，首部都不受影响，那就需要在应用层(HTTP2.0)和传输层(TCP or UDP)之间增加一个二进制分帧层。

![](/img/localBlog/11224747-a446336fd842f0d8.jpg)

在二进制分帧层上， HTTP/2 会将所有传输的信息分割为更小的消息和帧,并对它们采用二进制格式的编码 ，其中HTTP1.x的首部信息会被封装到Headers帧，而我们的request body则封装到Data帧里面。

#### 头信息压缩

HTTP 协议不带有状态，每次请求都必须附上所有信息。所以，请求的很多字段都是重复的，比如Cookie和User Agent，一模一样的内容，每次请求都必须附带，这会浪费很多带宽，也影响速度。

HTTP/2 对这一点做了优化，引入了头信息压缩机制（header compression）。一方面，头信息使用gzip或compress压缩后再发送；另一方面，客户端和服务器同时维护一张“首部表”来跟踪和存储之前发送的键-值对，对于相同的数据，不再通过每次请求和响应发送；通信期间几乎不会改变的通用键-值对(User Agent、Accept等等) 只需发送一次。

事实上,如果请求中不包含首部(例如对同一资源的轮询请求),那么 首部开销就是零字节。此时所有首部都自动使用之前请求发送的首部。

如果首部发生变化了，那么只需要发送变化了数据在Headers帧里面，新增或修改的首部帧会被追加到“首部表”。首部表在 HTTP 2.0 的连接存续期内始终存在,由客户端和服务器共同渐进地更新 。

#### 多路复用

上面我们说过了HTTP1.1协议的"队头堵塞"问题，在HTTP1.1的协议中，我们传输的request和response都是基本于文本的，这样就会引发一个问题：所有的数据必须按顺序传输，比如需要传输：hello world，只能从h到d一个一个的传输，不能并行传输，因为接收端并不知道这些字符的顺序，所以并行传输在HTTP1.1是不能实现的。

![](/img/localBlog/11224747-ff848a6b5c8422ab.png)

然而HTTP/2协议中，我们可以复用TCP连接，在一个连接里，客户端和浏览器都可以同时发送多个请求或回应，而且不用按照顺序一一对应，这样就避免了"队头堵塞"。

![](/img/localBlog/11224747-5524e4873545d682.png)

举例来说，在一个TCP连接里面，服务器同时收到了A请求和B请求，于是先回应A请求，结果发现处理过程非常耗时，于是就发送A请求已经处理好的部分， 接着回应B请求，完成后，再发送A请求剩下的部分。

由于多路复用，HTTP/2 协议比HTTP1.1协议省去了DNS Lookup,Initial connection,SSL这些建立连接的步骤，大大提升了网站响应时间。

#### 数据流 Stream

因为 HTTP/2 的数据包是不按顺序发送的，同一个连接里面连续的数据包，可能属于不同的回应。因此，必须要对数据包做标记，指出它属于哪个回应。

HTTP/2 将每个请求或回应的所有数据包，称为一个数据流（stream）。每个数据流都有一个独一无二的编号。数据包发送的时候，都必须标记数据流ID，用来区分它属于哪个数据流。另外还规定，客户端发出的数据流，ID一律为奇数，服务器发出的，ID为偶数。

![](/img/localBlog/11224747-1b386591f6cd8a25.jpg)

数据流发送到一半的时候，客户端和服务器都可以发送信号（RST_STREAM帧），取消这个数据流。1.1版取消数据流的唯一方法，就是关闭TCP连接。这就是说，HTTP/2 可以取消某一次请求，同时保证TCP连接还打开着，可以被其他请求使用。

客户端还可以指定数据流的优先级。优先级越高，服务器就会越早回应。

#### 服务器推送

HTTP/2 允许服务器未经请求，主动向客户端发送资源，这叫做服务器推送（server push）。

常见场景是客户端请求一个网页，这个网页里面包含很多静态资源。正常情况下，客户端必须收到网页后，解析HTML源码，发现有静态资源，再发出静态资源请求。其实，服务器可以预期到客户端请求网页后，很可能会再请求静态资源，所以就主动把这些静态资源随着网页一起发给客户端了。

## HTTPS

HTTPS（全称：Hyper Text Transfer Protocol over Secure Socket Layer），是以安全为目标的HTTP通道，简单讲是HTTP的安全版。即HTTP下加入SSL层，HTTPS的安全基础是SSL，用于安全的HTTP数据传输。，信息的加密过程就是在SSL中完成的

![](/img/localBlog/11224747-177e2d19dc407ab6.png)

### https出现的背景

首先，我们用wireshark对http协议下网络通讯进行抓包，效果如下图：

![](/img/localBlog/1555763779109.jpg)

有没有感觉这个的信息传输是完全暴露在互联网上面，你请求的所有信息都可以被窥测到，是不是感觉心一凉，不过不用担心，我们的安全信息现在都是采用https的传输，后面讲到https的时候大家心里会顿时轻松。https协议下的请求如下图所示：

![](/img/localBlog/1555763818780.jpg)

可以看到，http的信息传输中，信息很容易被劫持，更有甚者，黑客可以伪装服务器将篡改后的信息返回给用户，试想一下，如果劫持的是你的银行信息，是不是很可怕。所以对于http传出存在的问题可以总结如下：

（1）信息篡改：修改通信的内容

（2）信息劫持：拦截到信息通信的内容

这些是http不安全的体现，说完http，我们回到本文的主题https，看下人家是怎么保护信息的，所有的请求信息都采用了TLS加密，如果没有秘钥是无法解析传输的是什么信息

### https加密方法

当客户端发送Hello字符串的时候，在进行信息传输前，采用加密算法（上图中的秘钥S）将hello加密程JDuEW8&*21!@#进行传输，即使中间被劫持了，如果没有对应的秘钥S也无法知道传出的信息为何物。

![](/img/localBlog/1555765643776.jpg)

在上图中信息的加密和解密都是通过同一个秘钥进行的，对于这种加密我们称之为**对称加密**，只要A和B之间知道加解密的秘钥，任何第三方都无法获取秘钥S，则在一定条件下，基本上解决了信息通信的安全问题。但实际的通讯模型远比上图复杂，下图为实际的通信模型：

![](/img/localBlog/1555765875638.jpg)

由于server和所有的client都采用同一个秘钥S，则黑客们作为一个client也可以获取到秘钥S，此地无银三百两。所以在实际的通讯中，一般不会采用同一个秘钥，而是采用不同的秘钥加解密，如下图:

![](/img/localBlog/1555766150563.jpg)

如上图，A和server通信采用对称加密A算法，B和server通信采用对称秘钥B算法，因此可以很好的解决了不同的客户端采用相同的秘钥进行通讯的问题。

那现在又存在问题了，A通过明文传输和server协商采用了加密算法A，但这条信息本身是没有加密的，因此×××们还是可以窃取到秘钥的，整个的通讯仍然存在风险。那该如何处理呢？有人说，把这条信息（协调秘钥的过程）再次加密，那是不是还要协商加密秘钥，如此反复，永无止境。从根本上无法解决信息通讯的安全问题。

#### 如何对协商过程进行加密?

![](/img/localBlog/1534258138493233.png)

在密码学跟对称加密一起出现的，应用最广的加密机制**非对称加密**，如上图，特点是私钥加密后的密文，只要是公钥，都可以解密，但是反过来公钥加密后的密文，只有私钥可以解密。私钥只有一个人有，而公钥可以发给所有的人。

基于上述的特点，我们可以得出如下结论：

（1）公钥是开放给所有人的，但私钥是需要保密的，存在于服务端

（2）服务器端server向client端（A、B.....）的信息传输是不安全的：因为所有人都可以获取公钥

（3）但client端（A、B.....）向server端的信息传输确实安全的：因为私钥只有server端存在

因此，如何协商加密算法的问题，我们解决了，非对称加密算法进行对称加密算法协商过程。

![](/img/localBlog/1534251782432794.png)

信息通信采用http是不安全的，存在信息劫持、篡改的风险，https是加密传输，是安全的通信，对于https加密的过程，我们首先介绍的对称加密，采用对称加密进行通信存在秘钥协商过程的不安全性，因此我们采用了非对称加密算法解决了对协商过程的加密，因此https是集对称加密和非对称加密为一体的加密过程。

#### 如何安全的获取公钥？

细心的人可能已经注意到了如果使用非对称加密算法，我们的客户端A，B需要一开始就持有公钥，要不没法开展加密行为啊。

这下，我们又遇到新问题了，如何让A、B客户端安全地得到公钥？

![](/img/localBlog/1555767114667.jpg)

client获取公钥最最直接的方法是服务器端server将公钥发送给每一个client用户，但这个时候就出现了公钥被劫持的问题，如上图，client请求公钥，在请求返回的过程中被劫持，那么我们将采用劫持后的假秘钥进行通信，则后续的通讯过程都是采用假秘钥进行，数据库的风险仍然存在。

在获取公钥的过程中，我们又引出了一个新的话题：**如何安全的获取公钥，并确保公钥的获取是安全的**， 那就需要用到终极武器了：SSL 证书（需要购买）和CA机构。

![](/img/localBlog/1534251965821525.png)

如上图所示，在第 ② 步时服务器发送了一个SSL证书给客户端，SSL 证书中包含的具体内容有证书的颁发机构、有效期、公钥、证书持有者、签名，通过第三方的校验保证了身份的合法，解决了公钥获取的安全性

以浏览器为例说明如下整个的校验过程：

（1）首先浏览器读取证书中的证书所有者、有效期等信息进行一一校验

（2）浏览器开始查找操作系统中已内置的受信任的证书发布机构CA，与服务器发来的证书中的颁发者CA比对，用于校验证书是否为合法机构颁发 

（3）如果找不到，浏览器就会报错，说明服务器发来的证书是不可信任的。

（4）如果找到，那么浏览器就会从操作系统中取出  颁发者CA  的公钥，然后对服务器发来的证书里面的签名进行解密

（5）浏览器使用相同的hash算法计算出服务器发来的证书的hash值，将这个计算的hash值与证书中签名做对比

（6）对比结果一致，则证明服务器发来的证书合法，没有被冒充

（7）此时浏览器就可以读取证书中的公钥，用于后续加密了


HTTPS要使客户端与服务器端的通信过程得到安全保证，必须使用对称加密算法，但是协商对称加密算法的过程，需要使用非对称加密算法来保证安全，然而直接使用非对称加密的过程本身也不安全，会有中间人篡改公钥的可能性，所以客户端与服务器不直接使用公钥，而是使用数字证书签发机构颁发的证书来保证非对称加密过程本身的安全。这样通过这些机制协商出一个对称加密算法，就此双方使用该算法进行加密解密。从而解决了客户端与服务器端之间的通信安全问题。

### 获取证书

#### CA证书

现如今不比以前了，云服务的概念不仅从理论上深入到了互联网应用，而且变成了一个社会的基础设施工作，世界云服务3A：亚马逊AWS、微软Azure、阿里云，阿里云作为国人的骄傲跻身世界三大云服务厂商，且在国内，阿里云的市场份过半，且阿里云的操作系统“飞天系统”为自主研发，而不是采用开源的OpenStack。因此这些云服务厂商都提供了友好的CA证书申请流程，本文只以腾讯云、AlphaSSL为例进行说明申请的流程

##### 基本分类

根据证书的安全级别，可分为：

（1） DV SSL证书是只验证网站域名所有权的简易型（Class 1级）SSL证书，可10分钟快速颁发，能起到加密传输的作用，但无法向用户证明网站的真实身份。

目前市面上的免费证书都是这个类型的，只是提供了对数据的加密，但是对提供证书的个人和机构的身份不做验证。

（2） OV SSL,提供加密功能,对申请者做严格的身份审核验证,提供可信×××明。

和DV SSL的区别在于，OV SSL 提供了对个人或者机构的审核，能确认对方的身份，安全性更高。

所以这部分的证书申请是收费的~

（3）EV SSL，超安=EV=最安全、最严格 超安EV SSL证书遵循全球统一的严格身份验证标准，是目前业界安全级别最高的顶级 (Class 4级)SSL证书。

金融证券、银行、第三方支付、网上商城等，重点强调网站安全、企业可信形象的网站，涉及交易支付、客户隐私信息和账号密码的传输。

这部分的验证要求最高，申请费用也是最贵的。

根据保护域名的数量需求，SSL证书又分为：

1. 单域名版：只保护一个域名，例如 www.abc.com 或者 login.abc.com 之类的单个域名

2. 多域名版：一张证书可以保护多个域名，例如同时保护 www.abc.com , www.bcd.com, pay.efg.com 等

3. 通配符版：一张证书保护同一个主域名下同一级的所有子域名，不限个数，形如 *.abc.com 。注意，通配符版只有 DVSSL 和 OVSSL 具有， EVSSL 不具有通配符版本。

阿里云目前已经不提供免费的SSL证书，即DV SSL，但目前国内可以提供免费的SSL证书的云厂商有腾讯云，至于什么时候收费，笔者暂时不太清楚，但至少这个时期是OK的

##### 腾讯云

登录腾讯云控制台，找到SSL证书，进入购买页面，找到域名型免费性（DV），点击“免费申请”:

![](/img/localBlog/1534254080488224.png)

进入域名验证环节，需要注意：通用域名必须是指定的一个明确的域名地址，不能是通配域名，其次私钥密码在申请的过程中是选填，但在国外网站申请的时候确实必填。

![](/img/localBlog/1555768084524.jpg)

选择验证方式，笔者一般会通过文件的方式，直接通过nginx创建一个文件目录，进行通信就可以完成身份的验证，具体的验证过程可以参考腾讯云的详细说明。

等待审核通过，一般在1-3小时的时间。具笔者计算，一个统配域名在国外买在1800人民币的样子，但在国内购买需要2500以上。接下来重点介绍AlphaSSL购买流程

##### AlphaSSL

申请网址：https://www.alphassl.com/ssl-certificates/select-region/

（1）：选择所在区域，此处选择other（国外没有将Asia作为一个明确的区域标识气愤，但谁让我们技不如人呢）

![](/img/localBlog/1555768630043.jpg)

（2）产品详情：此处注意购买统配的域名，这个买起来更划算。

![](/img/localBlog/1534254986299273.png)

![](/img/localBlog/1534255100613573.png)

（3）基本信息的填写，没有什么需要注意的

![](/img/localBlog/1534255262961999.png)

（4）CSR这个步骤是最容易出错，且不太能让人理解的地方，笔者在这里做个简单的普及。

![](/img/localBlog/1534255293733955.png)

CSR(证书请求文件) 包含申请证书所需要的相关信息，其中最重要的是域名，填写的域名必须是你要https方式访问的那个域名。如abc.com 或 web.abc.com，其中CSR生成的方式很多，笔者直接用了网上的一个生成网站：https://myssl.com/csr_create.html

填写好相关的信息，尤其是域名信息一定要正确，可以根据生成的方式进行生成，生成之后产生了2个文件，一个为CSR文件，用来向CA机构申请的文件，一般以CSR结尾，一个是KEY文件，这个文件一定要保存好，这个文件就是对应第一章节将的server端的私钥，这个信息首先是重要，如果这个KEY文件没有保存好，是无法找回的，因为KEY生成的过程不可逆，即使填写的过程都一样，生成的KEY是不通的，具有随机性。

将生成的CRS粘贴进入第四步点击下一步就进入了付款环节，由于是国外购买，所以必须使用VISA的信用卡。一般付款之后，6小时左右证书就可以下来。当然笔者在申请的过程中就把KEY文件给丢了，导致找客服（英文对话，核实身份），其实如果申请存在问题，7天内是可以申请退款，其次如果你把KEY文件丢失了，可以通过找客服进行更新，详细可以参考：https://support.globalsign.com/customer/portal/articles/1223116

#### 自证证书

### 配置WEB服务支持https

在nginx的配置文件中，新增如下配置项，在这个地方有一个参数：ssl on，如果这个参数开启，http和https将不能共存。里面对应的信息都可以通过CA机构获取到:

````
listen 443 ssl;
ssl_certificate     /iyunwen/server/ssl/20180731.cer;
ssl_certificate_key /iyunwen/server/ssl/20180731.key;
ssl_prefer_server_ciphers on;
ssl_session_timeout 10m;
ssl_session_cache shared:SSL:10m;
ssl_protocols TLSv1 TLSv1.1 TLSv1.2;
ssl_ciphers "EECDH+ECDSA+AESGCM EECDH+aRSA+AESGCM EECDH+ECDSA+SHA384 EECDH+ECDSA+SHA256 EECDH+aRSA+SHA384 EECDH+aRSA+SHA256 EECDH+aRSA+RC4 EECDH EDH+aRSA !aNULL !eNULL !LOW !3DES !MD5 !EXP !PSK !SRP !DSS !RC4";
````

这里给出了阿里云SSL在主流apache、nginx的配置文档：https://help.aliyun.com/video_detail/54216.html?spm=a2c4g.11186623.4.1.WbwjQN

腾讯云SSL配置文档：https://cloud.tencent.com/document/product/400/4143