---
layout: post
title: vue 源码分析
subtitle: 源码探索之旅
date: 2019-09-10
author: Li Yucang
catalog: true
tags:
  - vue
  - 源码解析
---

# vue 源码分析

本文将从几个方面入手一步步带大家解读vue源码，对应vue源码版本v2.6.10。

## 深入响应式原理

Vue 最独特的特性之一，是其非侵入性的响应式系统。数据模型仅仅是普通的 JavaScript 对象。而当你修改它们时，视图会进行更新。这使得状态管理非常简单直接，不过理解其工作原理同样重要，这样你可以避开一些常见的问题。

响应式更新主要涉及到Watcher，Dep，Observer这几个主要类。

![](/img/localBlog/1572711774506.jpg)

本文直接从新建Vue实例入手，一步一步揭开Vue的响应式原理，假设有以下简单的Vue代码：

````
var vue = new Vue({
    el: "#app",
    data: {
        counter: 1
    },
    watch: {
        counter: function(val, oldVal) {
            console.log('counter changed...')
        }
    }
})
````

### Vue实例初始化

从Vue的生命周期可知，首先进行init初始化操作，这部分代码在instance/init.js中。

src/core/instance/init.js

````
    initLifecycle(vm) // vm生命周期相关变量初始化操作
    initEvents(vm) // vm事件相关初始化
    initRender(vm) // 模板解析相关初始化
    callHook(vm, 'beforeCreate') // 调用beforeCreate钩子函数
    initInjections(vm) // resolve injections before data/props
    initState(vm) // vm状态初始化(重点在这里)
    initProvide(vm) // resolve provide after data/props
    callHook(vm, 'created') // 调用created钩子函数
````

上述源码中的initState(vm)是要研究的重点，里面实现了props，methods，data，computed，watch的初始化操作。这里根据上述例子，重点看data和watch，源码位置在instance/state.js

src/core/instance/state.js

````
export function initState (vm: Component) {
  vm._watchers = []
  const opts = vm.$options
  if (opts.props) initProps(vm, opts.props)
  if (opts.methods) initMethods(vm, opts.methods)
  if (opts.data) {
    initData(vm) // 对vm的data进行初始化，主要是通过Observer设置对应getter/setter方法
  } else {
    observe(vm._data = {}, true /* asRootData */) // 如果没有data, _data效果一样, 只是没做代理
  }
  if (opts.computed) initComputed(vm, opts.computed)
  if (opts.watch && opts.watch !== nativeWatch) {
    initWatch(vm, opts.watch)
  }
}
````

### initData

initData做了两件事: proxy, observe。

src/core/instance/state.js

````
function initData (vm: Component) {
  let data = vm.$options.data
  data = vm._data = typeof data === 'function' // 如果data是函数, 用vm作为this执行函数的结果作为data
    ? getData(data, vm)
    : data || {}
  if (!isPlainObject(data)) { // 过滤乱搞, data只接受对象, 如果乱搞会报警并且把data认为是空对象
    data = {}
    process.env.NODE_ENV !== 'production' && warn(
      'data functions should return an object:\n' +
      'https://vuejs.org/v2/guide/components.html#data-Must-Be-a-Function',
      vm
    )
  }
  // proxy data on instance
  const keys = Object.keys(data)
  const props = vm.$options.props
  const methods = vm.$options.methods
  let i = keys.length
  while (i--) {
    const key = keys[i]
    if (process.env.NODE_ENV !== 'production') {
      if (methods && hasOwn(methods, key)) { // 判断是否和methods重名
        warn(
          `Method "${key}" has already been defined as a data property.`,
          vm
        )
      }
    }
    if (props && hasOwn(props, key)) { // 判断是否和props重名
      process.env.NODE_ENV !== 'production' && warn(
        `The data property "${key}" is already declared as a prop. ` +
        `Use prop default value instead.`,
        vm
      )
    } else if (!isReserved(key)) { // 判断key是否以_或$开头
      proxy(vm, `_data`, key) // 代理data
    }
  }
  // observe data
  observe(data, true /* asRootData */)
}
````

我们来看一下proxy和observe是干嘛的，其实就是把vm.key的setter和getter都代理到vm._data.key, 效果就是vm.a实际实际是vm._data.a, 设置vm.a也是设置vm._data.a.：

```
const sharedPropertyDefinition = {
  enumerable: true,
  configurable: true,
  get: noop,
  set: noop
}

// 在initData中调用: proxy(vm, `_data`, key)
// target: vm, sourceKey: _data, key: key. 这里的key为遍历data的key
// 举例: data为{a: 'a value', b: 'b value'}
// 那么这里执行的target: vm, sourceKey: _data, key: a
export function proxy (target: Object, sourceKey: string, key: string) {
  sharedPropertyDefinition.get = function proxyGetter () {
    return this[sourceKey][key] // getter: vm._data.a
  }
  sharedPropertyDefinition.set = function proxySetter (val) {
    this[sourceKey][key] = val // setter: vm._data.a = val
  }
  Object.defineProperty(target, key, sharedPropertyDefinition) // 用Object.defineProperty来设置getter, setter
}
```

代理完成之后就是关键的函数, initData最后调用了observe(data, true)，来实现数据的响应式。

observe方法其实是一个滤空和单例的入口, 最后行为是创建一个observe对象放到observe目标的__ob__属性里, 代码如下:

src/core/observer/index.js

````
/**
 * Attempt to create an observer instance for a value,
 * returns the new observer if successfully observed,
 * or the existing observer if the value already has one.
 */
export function observe (value: any, asRootData: ?boolean): Observer | void {
  if (!isObject(value) || value instanceof VNode) {
    return
  }
  let ob: Observer | void
  if (hasOwn(value, '__ob__') && value.__ob__ instanceof Observer) {
    ob = value.__ob__
  } else if (
    shouldObserve &&
    !isServerRendering() &&
    (Array.isArray(value) || isPlainObject(value)) &&
    Object.isExtensible(value) &&
    !value._isVue
  ) {
    ob = new Observer(value) // 重点在这里，响应式的核心所在
  }
  if (asRootData && ob) {
    ob.vmCount++
  }
  return ob
}
````

这里只关注new Observer(value)，这是该方法的核心所在，通过Observer类将vue的data变成响应式。下面就具体看看Observer类。

### Observer

首先看看该类的构造方法，new Observer(value)首先执行的是该构造方法。作者的注释说了，Observer Class将每个目标对象的键值（即data中的数据）转换成getter/setter形式，用于进行依赖收集和通过依赖通知更新。

src/core/observer/index.js

````
export class Observer {
  value: any;
  dep: Dep;
  vmCount: number; // number of vms that have this object as root $data

  constructor (value: any) {
    this.value = value // 保存值
    this.dep = new Dep() // dep对象
    this.vmCount = 0
    def(value, '__ob__', this) // 自己的副本, 放到__ob__属性下, 作为单例依据的缓存
    if (Array.isArray(value)) { // 判断是否为数组, 如果是数组的话劫持一些数组的方法, 在调用这些方法的时候进行通知.
      if (hasProto) {
        protoAugment(value, arrayMethods)
      } else {
        copyAugment(value, arrayMethods, arrayKeys)
      }
      this.observeArray(value) // 遍历数组, 继续监察数组的每个元素
    } else {
      // 遍历data对象中{counter : 1, ..} 中的每个键值（如counter），设置其setter/getter方法
      this.walk(value)  // 直到不再是数组(是对象了), 遍历对象, 劫持每个对象来发出通知
    }
  }

  /**
   * Walk through all properties and convert them into
   * getter/setters. This method should only be called when
   * value type is Object.
   */
  walk (obj: Object) {
    const keys = Object.keys(obj)
    for (let i = 0; i < keys.length; i++) {
      defineReactive(obj, keys[i])
    }
  }

  /**
   * Observe a list of Array items.
   */
  observeArray (items: Array<any>) {
    for (let i = 0, l = items.length; i < l; i++) {
      observe(items[i])
    }
  }
}
````
 
做了几件事:

1. 建立内部Dep对象. (作用是之后在watcher中递归的时候把自己添加到依赖中)

2. 把目标的__ob__属性赋值成Observe对象, 作用是上面提过的单例.

3. 如果目标是数组, 进行方法的劫持. (下面来看)

4. 如果是数组就observeArray, 否则walk.
 
那么我们接着看observeArray和walk方法。

我们发现, observeArray的作用是递归调用, 最后调用的方法是defineReactive, 可以说这个方法是最终的核心了.

下面我们先看一下数组方法劫持的目的和方法, 之后再看defineReactive的做法。

#### array劫持

之后会知道defineReactive的实现劫持的方法是Object.defineProperty来劫持对象的getter, setter, 那么数组的变化不会触发这些劫持器, 所以vue劫持了数组的一些方法。

最后的结果就是: array.prototype.push = function () {…}, 被劫持的方法有['push', 'pop', 'shift', 'unshift', 'splice', 'sort', 'reverse'], 也就是调用这些方法也会触发响应. 具体劫持以后的方法是:

```
const arrayProto = Array.prototype
export const arrayMethods = Object.create(arrayProto)

const methodsToPatch = [
  'push',
  'pop',
  'shift',
  'unshift',
  'splice',
  'sort',
  'reverse'
]

/**
 * Intercept mutating methods and emit events
 */
methodsToPatch.forEach(function (method) {
  // cache original method
  const original = arrayProto[method]
  def(arrayMethods, method, function mutator (...args) {
    const result = original.apply(this, args) // 调用原生的数组方法
    const ob = this.__ob__ // 获取observe对象
    let inserted
    switch (method) {
      case 'push':
      case 'unshift':
        inserted = args
        break
      case 'splice':
        inserted = args.slice(2)
        break
    }
    if (inserted) ob.observeArray(inserted) // 继续递归
    // notify change
    ob.dep.notify() // 出发notify
    return result
  })
})
```

做了两件事:

1. 递归调用

2. 触发所属Dep的notify()方法.

接下来就说最终的核心方法, defineReactive, 这个方法最后也调用了notify().

#### defineReactive

````
/**
 * Define a reactive property on an Object.
 */
export function defineReactive (
  obj: Object,
  key: string,
  val: any,
  customSetter?: ?Function,
  shallow?: boolean
) {
  // dep 为当前数据的依赖实例
  // dep 维护着一个subs列表，保存依赖与当前数据(此时是当前数据是counter)的观察者(或者叫订阅者)。观察者即是Watcher实例。
  const dep = new Dep()

  const property = Object.getOwnPropertyDescriptor(obj, key)
  if (property && property.configurable === false) { // 判断当前key的操作权限
    return
  }

  // cater for pre-defined getter/setters
  // 获取对象本来的getter setter
  const getter = property && property.get
  const setter = property && property.set
  if ((!getter || setter) && arguments.length === 2) {
    val = obj[key]
  }

  let childOb = !shallow && observe(val) // childOb是val的监察对象(就是new Observe(val), 也就是递归调用)
  Object.defineProperty(obj, key, {
    enumerable: true,
    configurable: true,
    get: function reactiveGetter () {
      const value = getter ? getter.call(obj) : val // 如果本身有getter, 先调用
      // 如果有Dep.target, 进行依赖收集，最后返回value, if里的代码我们之后去dep的代码中研究
      if (Dep.target) {
        dep.depend()
        if (childOb) {
          childOb.dep.depend()
          if (Array.isArray(value)) {
            dependArray(value)
          }
        }
      }
      // 依赖收集完后返回值
      return value
    },
    set: function reactiveSetter (newVal) {
      const value = getter ? getter.call(obj) : val // 如果本身有getter, 先调用
      /* eslint-disable no-self-compare */
      // 如果值不变就不去做通知了, (或是某个值为NaN)
      if (newVal === value || (newVal !== newVal && value !== value)) {
        return
      }
      /* eslint-enable no-self-compare */
      if (process.env.NODE_ENV !== 'production' && customSetter) {
        customSetter()
      }
      // #7981: for accessor properties without setter
      if (getter && !setter) return
      // 这里对数据的值进行修改
      if (setter) { // 如果本身有setter, 先调用, 没的话就直接赋值
        setter.call(obj, newVal)
      } else {
        val = newVal // 因为传入参数的时候其实是'obj[keys[i]]', 所以就等于是'obj[key] = newVal'了
      }
      childOb = !shallow && observe(newVal) // 重新建立子监察
      dep.notify() // 通过dep实例通知观察者我的数据更新了, 可以说是劫持的核心步骤
    }
  })
}
````

解释都在注释中了, 总结一下这个方法的做的几件重要的事:

1. 建立Dep对象. (下面会说调用的Dep的方法的具体作用)

2. 递归调用. 可以说很大部分代码都在递归调用, 分别在创建子observe对象, setter, getter中.

3. getter中: 调用原来的getter, 收集依赖(Dep.depend(), 之后会解释收集的原理), 同样也是递归收集.

4. setter中: 调用原来的setter, 并判断是否需要通知, 最后调用dep.notify().

总结一下, 总的来说就是, 进入传入的data数据会被劫持, 在get的时候调用Dep.depend(), 在set的时候调用Dep.notify(). 那么Dep是什么, 这两个方法又干了什么, 带着疑问去看Dep对象.

### Dep

上图中关联Observer和Watcher类的是Dep，那么Dep是什么呢？

现在看下Dep的源码：

core/observer/dep.js

```
let uid = 0

/**
 * A dep is an observable that can have multiple
 * directives subscribing to it.
 */
export default class Dep {
  static target: ?Watcher;
  id: number;
  subs: Array<Watcher>;

  constructor () {
    this.id = uid++
    this.subs = [] // 保存观察者watcher实例的数组
  }

  // 添加观察者
  addSub (sub: Watcher) {
    this.subs.push(sub)
  }

  // 移除观察者
  removeSub (sub: Watcher) {
    remove(this.subs, sub)
  }

  // 进行依赖收集
  depend () {
    if (Dep.target) {
      Dep.target.addDep(this)
    }
  }

  // 通知观察者数据有变化
  notify () {
    // stabilize the subscriber list first
    const subs = this.subs.slice()
    if (process.env.NODE_ENV !== 'production' && !config.async) {
      // subs aren't sorted in scheduler if not running async
      // we need to sort them now to make sure they fire in correct
      // order
      subs.sort((a, b) => a.id - b.id)
    }
    for (let i = 0, l = subs.length; i < l; i++) {
      subs[i].update()
    }
  }
}

// The current target watcher being evaluated.
// This is globally unique because only one watcher
// can be evaluated at a time.
// 这是一个队列, 因为不允许有多个watcher的get方法同时调用
Dep.target = null
const targetStack = []

export function pushTarget (target: ?Watcher) {
  // 设置target, 把旧的放进stack
  targetStack.push(target)
  Dep.target = target
}

export function popTarget () {
  // 从stack拿一个作为当前的
  targetStack.pop()
  Dep.target = targetStack[targetStack.length - 1]
}
```

Dep类比较简单，对应方法也非常直观，这里最主要的就是维护了保存有观察者实例watcher的一个数组subs。

首先来分析变量:

* 全局Target. 这个其实是用来跟watcher交互的, 也保证了普通get的时候没有target就不设置依赖, 后面会解释.

* id. 这是用来在watcher里依赖去重的, 也要到后面解释.

* subs: 是一个watcher数组. sub应该是subscribe的意思, 也就是当前dep(依赖)的订阅者列表.

再来看方法:

* 构造: 设uid, subs. addSub: 添加wathcer, removeSub: 移除watcher. 这3个好无聊.

* depend: 如果有Dep.target, 就把自己添加到Dep.target中(调用了Dep.target.addDep(this)).

那么什么时候有Dep.target呢, 就由pushTarget()和popTarget()来操作了, 这些方法在Dep中没有调用, 后面会分析是谁在操作Dep.target.(这个是重点)

* notify: 这个是setter劫持以后调用的最终方法, 做了什么: 把当前Dep订阅中的每个watcher都调用update()方法.

Dep看完了, 我们的疑问都转向了Watcher对象了. 现在看来有点糊涂, 看完Watcher就都明白了.

### Watcher

我们先从构造函数看起:：

core/observer/watcher.js

```
let uid = 0

/**
 * A watcher parses an expression, collects dependencies,
 * and fires callback when the expression value changes.
 * This is used for both the $watch() api and directives.
 */
export default class Watcher {
  vm: Component;
  expression: string;
  cb: Function;
  id: number;
  deep: boolean;
  user: boolean;
  lazy: boolean;
  sync: boolean;
  dirty: boolean;
  active: boolean;
  deps: Array<Dep>;
  newDeps: Array<Dep>;
  depIds: SimpleSet;
  newDepIds: SimpleSet;
  before: ?Function;
  getter: Function;
  value: any;

  constructor (
    vm: Component,
    expOrFn: string | Function,
    cb: Function,
    options?: ?Object,
    isRenderWatcher?: boolean
  ) {
    this.vm = vm // 保存vm
    if (isRenderWatcher) {
      vm._watcher = this
    }
    vm._watchers.push(this) // 把watcher存到vm里
    // options
    // 读取配置 或 设置默认值
    if (options) {
      this.deep = !!options.deep
      this.user = !!options.user
      this.lazy = !!options.lazy
      this.sync = !!options.sync
      this.before = options.before
    } else {
      this.deep = this.user = this.lazy = this.sync = false
    }
    this.cb = cb // 保存传入的回调函数
    this.id = ++uid // uid for batching
    this.active = true
    this.dirty = this.lazy // for lazy watchers
    this.deps = [] // 保存观察数据当前的dep实例对象
    this.newDeps = [] // 保存观察数据最新的dep实例对象
    this.depIds = new Set()
    this.newDepIds = new Set()
    this.expression = process.env.NODE_ENV !== 'production'
      ? expOrFn.toString()
      : ''
    // parse expression for getter
    // 设置getter, parse字符串, 并滤空滤错，对于计算属性, expOrFn为函数
    if (typeof expOrFn === 'function') {
      this.getter = expOrFn
    } else {
      // 通过parsePath方法获取观察对象expOrFn的get方法
      this.getter = parsePath(expOrFn)
      if (!this.getter) {
        this.getter = noop
        process.env.NODE_ENV !== 'production' && warn(
          `Failed watching path: "${expOrFn}" ` +
          'Watcher only accepts simple dot-delimited paths. ' +
          'For full control, use a function instead.',
          vm
        )
      }
    }
    // 调用get获得值
    this.value = this.lazy
      ? undefined
      : this.get()
  }

  /**
   * Evaluate the getter, and re-collect dependencies.
   */
  get () {
    // 进入队列, 把当前watcher设置为Dep.target
    // 这样下面调用getter的时候出发的dep.append() (最后调用Dep.target.addDep()) 就会调用这个watcher的addDep.
    pushTarget(this)
    let value
    const vm = this.vm
    try {
      // 调用getter的时候会走一遍表达式,
      // 如果是 this.a + this.b , 会在a和b的getter中调用Dep.target.addDep(), 最后结果就调用了当前watcher的addDep,
      // 当前watcher就有了this.a的dep和this.b的dep
      // addDep把当前watcher加入了dep的sub(subscribe)里, dep的notify()调用就会运行本watcher的run()方法.
      value = this.getter.call(vm, vm)
    } catch (e) {
      if (this.user) {
        handleError(e, vm, `getter for watcher "${this.expression}"`)
      } else {
        throw e
      }
    } finally {
      // "touch" every property so they are all tracked as
      // dependencies for deep watching
      // 走到这里已经通过了getter获得到了value, 或者失败为undefined, 这个值返回作为watcher的valule
      // 处理deep选项
      if (this.deep) {
        traverse(value)
      }
      // 此时观察数据的依赖已经收集完
      popTarget() // 移除队列
      this.cleanupDeps() // 清理依赖(addDep加到newDep数组, 这步做整理动作)
    }
    return value
  }

  /**
   * Add a dependency to this directive.
   */
  addDep (dep: Dep) {
    const id = dep.id
    if (!this.newDepIds.has(id)) {
      this.newDepIds.add(id)
      this.newDeps.push(dep)
      if (!this.depIds.has(id)) {
        dep.addSub(this)
      }
    }
  }

  /**
   * Clean up for dependency collection.
   */
  cleanupDeps () {
    let i = this.deps.length
    while (i--) {
      const dep = this.deps[i]
      if (!this.newDepIds.has(dep.id)) {
        dep.removeSub(this)
      }
    }
    let tmp = this.depIds
    this.depIds = this.newDepIds
    this.newDepIds = tmp
    this.newDepIds.clear()
    tmp = this.deps
    this.deps = this.newDeps
    this.newDeps = tmp
    this.newDeps.length = 0
  }

  /**
   * Subscriber interface.
   * Will be called when a dependency changes.
   */
  update () {
    /* istanbul ignore else */
    if (this.lazy) {
      this.dirty = true
    } else if (this.sync) {
      this.run()
    } else {
      queueWatcher(this)
    }
  }

  /**
   * Scheduler job interface.
   * Will be called by the scheduler.
   */
  run () {
    if (this.active) {
      const value = this.get()
      if (
        value !== this.value ||
        // Deep watchers and watchers on Object/Arrays should fire even
        // when the value is the same, because the value may
        // have mutated.
        isObject(value) ||
        this.deep
      ) {
        // set new value
        const oldValue = this.value
        this.value = value
        if (this.user) {
          try {
            this.cb.call(this.vm, value, oldValue)
          } catch (e) {
            handleError(e, this.vm, `callback for watcher "${this.expression}"`)
          }
        } else {
          this.cb.call(this.vm, value, oldValue)
        }
      }
    }
  }

  /**
   * Evaluate the value of the watcher.
   * This only gets called for lazy watchers.
   */
  evaluate () {
    this.value = this.get()
    this.dirty = false
  }

  /**
   * Depend on all deps collected by this watcher.
   */
  depend () {
    let i = this.deps.length
    while (i--) {
      this.deps[i].depend()
    }
  }

  /**
   * Remove self from all dependencies' subscriber list.
   */
  teardown () {
    if (this.active) {
      // remove self from vm's watcher list
      // this is a somewhat expensive operation so we skip it
      // if the vm is being destroyed.
      if (!this.vm._isBeingDestroyed) {
        remove(this.vm._watchers, this)
      }
      let i = this.deps.length
      while (i--) {
        this.deps[i].removeSub(this)
      }
      this.active = false
    }
  }
}
```

注释都写了, 我来高度总结一下构造器做了什么事:

1. 处理传入的参数并设置成自己的属性.

2. parse表达式. watcher表达式接受2种: 方法/字符串. 如果是方法就设为getter, 如果是字符串会进行处理:

core/util/lang.js

```
export const unicodeRegExp = /a-zA-Z\u00B7\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u037D\u037F-\u1FFF\u200C-\u200D\u203F-\u2040\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD/

/**
 * Parse simple path.
 */
const bailRE = new RegExp(`[^${unicodeRegExp.source}.$_\\d]`)  // 匹配不符合包含下划线的任意单词数字组合的字符串
export function parsePath (path: string): any {
  // 非法字符串直接返回
  if (bailRE.test(path)) {
    return
  }
  // 这里是vue如何分析watch的, 就是接受 '.' 分隔的变量.
  // 如果键是'a.b.c', 也就等于function () {return this.a.b.c}
  return function (obj) {
    for (let i = 0; i < segments.length; i++) {
      if (!obj) return
      obj = obj[segments[i]]
    }
    return obj
  }
}
```

Watcher构造方法的最后一步，调用了this.get()方法。

get()方法是核心, 看完了就能把之前的碎片都串起来了，注释都在代码中了, 这段理解了就对整个响应系统理解了.

我来总结一下: (核心, 非常重要)

* dep与Watcher关系: Watcher的get方法建立了双方关系:
把自己设为target, 运行watcher的表达式(即调用相关数据的getter), 因为getter有钩子, 调用了Watcher的addDep, addDep方法把dep和Watcher互相推入互相的属性数组(分别是deps和subs)

* dep与Watcher建立了多对多的关系: dep含有订阅的watcher的数组, watcher含有所依赖的变量的数组

* 当dep的数据调动setter, 调用notify, 最终调用Watcher的update方法.

* 前面提到dep与Watcher建立关系是通过get()方法, 这个方法在3个地方出现: 构造方法, run方法, evaluate方法. 也就是说, notify了以后会重新调用一次get()方法. (所以在lifycycle中调用的时候把依赖和触发方法都写到getter方法中了).

那么接下来要看一看watcher在什么地方调用的.

找了一下, 一共三处:

1. initComputed的时候: (state.js)

```
watchers[key] = new Watcher( vm, getter || noop, noop, computedWatcherOptions )
```

2. $watch api: (state.js)

```
new Watcher(vm, expOrFn, cb, options)
```

3. lifecycle的mount阶段: (lifecycle.js)

```
new Watcher(vm, updateComponent, noop)
```

### initWatch

initWatch源码如下：

src/core/instance/state.js

```
function initWatch (vm: Component, watch: Object) {
  for (const key in watch) {
    // handler 是观察对象的回调函数
    // 如例子中counter的回调函数
    const handler = watch[key]
    if (Array.isArray(handler)) {
      for (let i = 0; i < handler.length; i++) {
        createWatcher(vm, key, handler[i])
      }
    } else {
      createWatcher(vm, key, handler)
    }
  }
}
```

createWatcher(vm, key, handler)是根据入参构建Watcher实例信息，源码如下：

```
function createWatcher (
  vm: Component,
  expOrFn: string | Function,
  handler: any,
  options?: Object
) {
  // 判断是否是对象，是的话提取对象里面的handler方法
  if (isPlainObject(handler)) {
    options = handler
    handler = handler.handler
  }
  // 判断handler是否是字符串，是的话说明是vm实例上的一个方法
  // 通过vm[handler]获取该方法
  // 如 handler='sayHello', 那么handler = vm.sayHello
  if (typeof handler === 'string') {
    handler = vm[handler]
  }
  // 最后调用vm原型链上的$watch(...)方法创建Watcher实例
  return vm.$watch(expOrFn, handler, options)
}
```

$watch是定义在Vue原型链上的方法，源码如下：

core/instance/state.js

```
Vue.prototype.$watch = function (
  expOrFn: string | Function,
  cb: any,
  options?: Object
): Function {
  const vm: Component = this
  if (isPlainObject(cb)) {
    return createWatcher(vm, expOrFn, cb, options)
  }
  options = options || {}
  options.user = true
  const watcher = new Watcher(vm, expOrFn, cb, options)
  if (options.immediate) {
    try {
      cb.call(vm, watcher.value)
    } catch (error) {
      handleError(error, vm, `callback for immediate watcher "${watcher.expression}"`)
    }
  }
  // 该方法返回一个函数的引用，直接调用该函数就会调用watcher对象的teardown()方法，从它注册的列表中(subs)删除自己。
  return function unwatchFn () {
    watcher.teardown()
  }
}
```

经过一系列的封装，这里终于看到了创建Watcher实例对象了。

下面给出一个Observer，Watcher类之间的关联关系，图中还是以我们的例子进行描述：

![](/img/localBlog/1572712672789.jpg)

* 红色箭头：Watcher类实例化，调用watcher实例的get()方法，并设置Dep.target为当前watcher实例，触发观察对象的getter方法。

* 蓝色箭头：counter对象的getter方法被触发，调用dep.depend()进行依赖收集并返回counter的值。依赖收集的结果：1.counter闭包的dep实例的subs添加观察它的watcher实例w1；2. w1的deps中添加观察对象counter的闭包dep。

* 橙色箭头：当counter的值变化后，触发subs中观察它的w1执行update()方法，最后实际上是调用w1的回调函数cb。

### initComputed

我们找到initComputed的定义：

```
const computedWatcherOptions = { lazy: true }

function initComputed (vm: Component, computed: Object) {
  // $flow-disable-line
  const watchers = vm._computedWatchers = Object.create(null)
  // computed properties are just getters during SSR
  const isSSR = isServerRendering()

  for (const key in computed) {
    // 循环每个computed
    // 格式滤错滤空
    const userDef = computed[key]
    const getter = typeof userDef === 'function' ? userDef : userDef.get
    if (process.env.NODE_ENV !== 'production' && getter == null) {
      warn(
        `Getter is missing for computed property "${key}".`,
        vm
      )
    }

    if (!isSSR) {
      // create internal watcher for the computed property.
      // 为computed建立wathcer
      watchers[key] = new Watcher(
        vm,
        getter || noop,
        noop, // noop是定义的一个空方法，这里没有回调函数用noop代替
        computedWatcherOptions // { lazy: true }
      )
    }

    // component-defined computed properties are already defined on the
    // component prototype. We only need to define computed properties defined
    // at instantiation here.
    // 因为没有被代理, computed属性是不能通过vm.xx获得的, 如果可以获得说明重复定义, 抛出异常.
    if (!(key in vm)) {
      defineComputed(vm, key, userDef)
    } else if (process.env.NODE_ENV !== 'production') {
      if (key in vm.$data) {
        warn(`The computed property "${key}" is already defined in data.`, vm)
      } else if (vm.$options.props && key in vm.$options.props) {
        warn(`The computed property "${key}" is already defined as a prop.`, vm)
      }
    }
  }
}
```

已注释, 总结为:

1. 遍历每个computed键值, 过滤错误语法.

2. 遍历每个computed键值, 为他们建立watcher, options为{ lazy: true}.

3. 遍历每个computed键值, 调用defineComputed.

那么继续看defineComputed.

```
export function defineComputed (
  target: any,
  key: string,
  userDef: Object | Function
) {
  const shouldCache = !isServerRendering()
  // 因为computed除了function还有get set 字段的语法, 下面的代码是做api的兼容
  if (typeof userDef === 'function') {
    sharedPropertyDefinition.get = shouldCache
      ? createComputedGetter(key)
      : createGetterInvoker(userDef)
    sharedPropertyDefinition.set = noop
  } else {
    sharedPropertyDefinition.get = userDef.get
      ? shouldCache && userDef.cache !== false
        ? createComputedGetter(key)
        : createGetterInvoker(userDef.get)
      : noop
    sharedPropertyDefinition.set = userDef.set || noop
  }
  // 除非设置setter, computed属性是不能被修改的, 抛出异常 (evan说改变了自由哲学, 要控制低级用户)
  if (process.env.NODE_ENV !== 'production' &&
      sharedPropertyDefinition.set === noop) {
    sharedPropertyDefinition.set = function () {
      warn(
        `Computed property "${key}" was assigned to but it has no setter.`,
        this
      )
    }
  }
  // 其实核心就下面这步... 上面步骤的作用是和data一样添加一个getter, 增加append动作. 现在通过vm.xxx可以获取到computed属性啦!
  Object.defineProperty(target, key, sharedPropertyDefinition)
}

function createComputedGetter (key) {
  return function computedGetter () {
    const watcher = this._computedWatchers && this._computedWatchers[key]
    if (watcher) {
      if (watcher.dirty) {
        watcher.evaluate()
      }
      if (Dep.target) {
        watcher.depend()
      }
      return watcher.value
    }
  }
}
```

因为computed可以设置getter, setter, 所以computed的值不一定是function, 可以为set和get的function, 很大部分代码是做这些处理, 核心的事情有2件:

1. 使用Object.defineProperty在vm上挂载computed属性.

2. 为属性设置getter, getter做了和data一样的事: depend. 但是多了一步: watcher.evalueate().

看到这里, computed注册核心一共做了两件事:

1. 为每个computed建立watcher(lazy: true)

2. 建立一个getter来depend, 并挂到vm上.

那么dirty成了疑问, 我们回到watcher的代码中去看, lazy和dirty和evaluate是干什么的.

精选相关代码:

* (构造函数中)

this.dirty = this.lazy

* (构造函数中)

this.value = this.lazy ? undefined : this.get()

* (evaluate函数)

``` evaluate () { this.value = this.get() this.dirty = false } ```

到这里已经很清楚了. 因为还没设置getter, 所以在建立watcher的时候不立即调用getter, 所以构造函数没有马上调用get, 在设置好getter以后调用evaluate来进行依赖注册.

总结: computed是watch+把属性挂到vm上的行为组合.

#### 实例

这里看一个计算属性的例子：

```
var vue = new Vue({
    el: "#app",
    data: {
        counter: 1
    },
    computed: {
        result: function() {
            return 'The result is :' + this.counter + 1;
        }
    }
})
```

示意图如下所示：

![](/img/localBlog/1572713210736.jpg)

这里计算属性result因为依赖于this.counter，因此设置一个watcher用来观察result的值。随后通过definedComputed(vm, key, userDef)来定义计算属性。在计算获取result的时候，又会触发this.counter的getter方法，这样使得result的值依赖于this.counter的值。

### 总结

到这里，主要的三个类都研究完了。

Q1：Watcher，Dep，Observer这几个类之间的关系？

A1：Watcher是观察者观察经过Observer封装过的数据，Dep是Watcher和观察数据间的纽带，主要起到依赖收集和通知更新的作用。

Q2：Dep中的subs存储的是什么？

A2: subs存储的是观察者Watcher实例。

Q3：Watcher中的deps存储的是什么？

A3：deps存储的是观察数据闭包中的dep实例。

Q4：Dep.target是什么， 该值是何处赋值的？

A4：Dep.target是全局变量，保存当前的watcher实例，在new Watcher()的时候进行赋值，赋值为当前Watcher实例。