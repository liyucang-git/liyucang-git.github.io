---
layout: post
title: vue 源码分析
subtitle: 源码探索之旅
date: 2019-09-10
author: Li Yucang
catalog: true
tags:
  - vue
  - 源码解析
---

# vue 源码分析

本文将从几个方面入手一步步带大家解读vue源码，对应vue源码版本v2.6.10。

## 深入响应式原理

Vue 最独特的特性之一，是其非侵入性的响应式系统。数据模型仅仅是普通的 JavaScript 对象。而当你修改它们时，视图会进行更新。这使得状态管理非常简单直接，不过理解其工作原理同样重要，这样你可以避开一些常见的问题。

### 双向数据绑定

MVVM中，M 即 model，指的是模型，也就是数据；V 即view，指的是视图，也就是页面展现的部分。

双向数据绑定大概概括为：每当数据有变更时，会进行渲染，从而更新视图，使得视图与数据保持一致（model到view层）；而另一方面，页面也会通过用户的交互，产生状态、数据的变化，这个时候，这时需要将视图对数据的更新同步到数据（view到model层）。

不同的前端 MV* 框架对于这种 Model 和 View 间的数据同步有不同的处理，如：
脏值检查（angular.js）
数据劫持 + 观察者者模式（Vue）

Vue的数据响应式原理其实就是实现数据到视图更新原理，而视图到数据的更新，其实就是此基础上给可表单元素（input等）添加了change等事件监听，来动态修改model和 view。

Vue 采用数据劫持结合观察者模式的方式来实现数据的响应式，通过Object.defineProperty来劫持数据的setter，getter，在数据变动时发布消息给订阅者，订阅者收到消息后进行相应的处理。

响应式更新主要涉及到Watcher，Dep，Observer这几个主要类。

![](/img/localBlog/1572711774506.jpg)

vue中的观察者模式：第一步当然是通过 observer 进行数据劫持，然后在需要订阅的地方（如：模版编译），添加观察者（watcher），并立刻通过取值操作触发指定属性的 getter 方法，从而将观察者添加进 Dep （利用了闭包的特性，进行依赖收集），然后在 Setter 触发的时候，进行 notify，通知给所有观察者并进行相应的 update。

### Vue实例初始化

从Vue的生命周期可知，首先进行init初始化操作，这部分代码在instance/init.js中。

src/core/instance/init.js

````
    initLifecycle(vm) // vm生命周期相关变量初始化操作
    initEvents(vm) // vm事件相关初始化
    initRender(vm) // 模板解析相关初始化
    callHook(vm, 'beforeCreate') // 调用beforeCreate钩子函数
    initInjections(vm) // resolve injections before data/props
    initState(vm) // vm状态初始化(重点在这里)
    initProvide(vm) // resolve provide after data/props
    callHook(vm, 'created') // 调用created钩子函数
````

上述源码中的initState(vm)是要研究的重点，里面实现了props，methods，data，computed，watch的初始化操作。源码位置在instance/state.js

src/core/instance/state.js

````
export function initState (vm: Component) {
  vm._watchers = []
  const opts = vm.$options
  if (opts.props) initProps(vm, opts.props)
  if (opts.methods) initMethods(vm, opts.methods)
  if (opts.data) {
    initData(vm) // 对vm的data进行初始化，主要是通过Observer设置对应getter/setter方法
  } else {
    observe(vm._data = {}, true /* asRootData */) // 如果没有data, _data效果一样, 只是没做代理
  }
  if (opts.computed) initComputed(vm, opts.computed)
  if (opts.watch && opts.watch !== nativeWatch) {
    initWatch(vm, opts.watch)
  }
}
````

### initData

initData做了两件事: proxy, observe。

src/core/instance/state.js

````
function initData (vm: Component) {
  let data = vm.$options.data
  data = vm._data = typeof data === 'function' // 如果data是函数, 用vm作为this执行函数的结果作为data
    ? getData(data, vm)
    : data || {}
  if (!isPlainObject(data)) { // 过滤乱搞, data只接受对象, 如果乱搞会报警并且把data认为是空对象
    data = {}
    process.env.NODE_ENV !== 'production' && warn(
      'data functions should return an object:\n' +
      'https://vuejs.org/v2/guide/components.html#data-Must-Be-a-Function',
      vm
    )
  }
  // proxy data on instance
  const keys = Object.keys(data)
  const props = vm.$options.props
  const methods = vm.$options.methods
  let i = keys.length
  while (i--) {
    const key = keys[i]
    if (process.env.NODE_ENV !== 'production') {
      if (methods && hasOwn(methods, key)) { // 判断是否和methods重名
        warn(
          `Method "${key}" has already been defined as a data property.`,
          vm
        )
      }
    }
    if (props && hasOwn(props, key)) { // 判断是否和props重名
      process.env.NODE_ENV !== 'production' && warn(
        `The data property "${key}" is already declared as a prop. ` +
        `Use prop default value instead.`,
        vm
      )
    } else if (!isReserved(key)) { // 判断key是否以_或$开头
      proxy(vm, `_data`, key) // 代理data
    }
  }
  // observe data
  observe(data, true /* asRootData */)
}
````

我们来看一下proxy是干嘛的，其实就是把`vm.key`的setter和getter都代理到`vm._data.key`, 效果就是`vm.a`实际实际是`vm._data.a`, 设置`vm.a`也是设置`vm._data.a.`：

```
const sharedPropertyDefinition = {
  enumerable: true,
  configurable: true,
  get: noop,
  set: noop
}

// 在initData中调用: proxy(vm, `_data`, key)
// target: vm, sourceKey: _data, key: key. 这里的key为遍历data的key
// 举例: data为{a: 'a value', b: 'b value'}
// 那么这里执行的target: vm, sourceKey: _data, key: a
export function proxy (target: Object, sourceKey: string, key: string) {
  sharedPropertyDefinition.get = function proxyGetter () {
    return this[sourceKey][key] // getter: vm._data.a
  }
  sharedPropertyDefinition.set = function proxySetter (val) {
    this[sourceKey][key] = val // setter: vm._data.a = val
  }
  Object.defineProperty(target, key, sharedPropertyDefinition) // 用Object.defineProperty来设置getter, setter
}
```

代理完成之后调用了`observe(data, true)`，来实现数据的响应式。

observe方法其实是一个滤空和单例的入口, 最后行为是创建一个observe对象放到observe目标的`__ob__`属性里, 代码如下:

src/core/observer/index.js

````
/**
 * Attempt to create an observer instance for a value,
 * returns the new observer if successfully observed,
 * or the existing observer if the value already has one.
 */
export function observe (value: any, asRootData: ?boolean): Observer | void {
  if (!isObject(value) || value instanceof VNode) {
    return
  }
  let ob: Observer | void
  if (hasOwn(value, '__ob__') && value.__ob__ instanceof Observer) {
    ob = value.__ob__
  } else if (
    shouldObserve &&
    !isServerRendering() &&
    (Array.isArray(value) || isPlainObject(value)) &&
    Object.isExtensible(value) &&
    !value._isVue
  ) {
    //如果数据没有被observe过，且数据是array或object类型，那么将数据转化为observer类型，所以observer类接收的是对象和数组。
    ob = new Observer(value) // 重点在这里，响应式的核心所在
  }
  //如果是RootData，即咱们在新建Vue实例时，传到data里的值，只有RootData在每次observe的时候，会进行计数。
  if (asRootData && ob) {
    ob.vmCount++
  }
  return ob
}
````

我在这里说一下vmCount属性：vmCount属性是用来记录该实例被创建的次数，我们看下面的代码，调用了两次my-component组件，这个时候vmCount为2.

```
<div >
    <div id="example">
      <my-component></my-component>
      <my-component></my-component>
    </div>
</div>
    <script src="./vue.js"></script>
    <script>
    var data = { counter: 1 }
    Vue.component('my-component', {
      template: '<div>{{ counter }}</div>',
      data: function () {
        return data
      }
    })
    // 创建根实例
    var app2 = new Vue({
      el: '#example'
    })
</script>
```

效果：

![](/img/localBlog/1572757167182.jpg)

这里重点关注`new Observer(value)`，这是该方法的核心所在，通过Observer类将vue的data变成响应式。下面就具体看看Observer类。

### Observer

首先看看该类的构造方法，Observer 将每个目标对象的键值（即data中的数据）转换成getter/setter形式，用于进行依赖收集和通过依赖通知更新。

src/core/observer/index.js

````
export class Observer {
  value: any;
  dep: Dep;
  vmCount: number; // number of vms that have this object as root $data

  constructor (value: any) {
    this.value = value // 保存值
    this.dep = new Dep() // dep对象
    this.vmCount = 0
    //def是定义的函数，使用Object.defineProperty()给value添加不可枚举的属性,__ob__是一个对象被observe的标志。
    def(value, '__ob__', this) // 自己的副本, 放到__ob__属性下, 作为单例依据的缓存
    if (Array.isArray(value)) { // 判断是否为数组, 如果是数组的话劫持一些数组的方法, 在调用这些方法的时候进行通知.
      if (hasProto) {
        protoAugment(value, arrayMethods)
      } else {
        copyAugment(value, arrayMethods, arrayKeys)
      }
      this.observeArray(value) // 遍历数组, 继续监察数组的每个元素
    } else {
      // 对于对象，遍历对象，并用Object.defineProperty转化为getter/setter，便于监控数据的get和set
      this.walk(value) 
    }
  }

  /**
   * Walk through all properties and convert them into
   * getter/setters. This method should only be called when
   * value type is Object.
   */
  //遍历对象，调用defineReactive将每个属性转化为getter/setter
  walk (obj: Object) {
    const keys = Object.keys(obj)
    for (let i = 0; i < keys.length; i++) {
      defineReactive(obj, keys[i])
    }
  }

  /**
   * Observe a list of Array items.
   */
  //observe每个数组元素(observe会生成Observer类)
  observeArray (items: Array<any>) {
    for (let i = 0, l = items.length; i < l; i++) {
      observe(items[i])
    }
  }
}
````

做了几件事:

1. 建立内部Dep对象。

2. 把目标的`__ob__`属性赋值成Observe对象。

3. 如果目标是数组, 进行方法的劫持。

4. 如果是数组就observeArray, 对象walk。

下面我们先看一下defineReactive。

#### defineReactive

````
/**
 * Define a reactive property on an Object.
 */
export function defineReactive (
  obj: Object,
  key: string,
  val: any,
  customSetter?: ?Function,
  shallow?: boolean
) {
  // dep 维护着一个subs列表，保存依赖与当前数据(此时是当前数据是counter)的观察者(或者叫订阅者)。观察者即是Watcher实例。
  const dep = new Dep()

  const property = Object.getOwnPropertyDescriptor(obj, key)
  if (property && property.configurable === false) { // 判断当前key的操作权限
    return
  }

  // cater for pre-defined getter/setters
  // 获取对象本来的getter setter
  const getter = property && property.get
  const setter = property && property.set
  if ((!getter || setter) && arguments.length === 2) {
    val = obj[key]
  }

  //注意下面这行代码，设置getter/setter之前，会observe该属性对应的值（val）
  let childOb = !shallow && observe(val)
  Object.defineProperty(obj, key, {
    enumerable: true,
    configurable: true,
    get: function reactiveGetter () {
      //获取属性的值，如果这个属性在转化之前定义过getter，那么调用该getter得到value的值，否则直接返回val。
      const value = getter ? getter.call(obj) : val
      // 调用get的情况有两种，一是Watcher收集依赖的时候（此时Dep收集订阅者），二是模板或js代码里用到这个值，这个时候是不需要收集依赖的，只要返回值就可以了。
      if (Dep.target) {
        dep.depend()
        if (childOb) {
          childOb.dep.depend()
          //如果是数组，那么数组中的每个值都添加到依赖列表里
          if (Array.isArray(value)) {
            dependArray(value)
          }
        }
      }
      // 依赖收集完后返回值
      return value
    },
    set: function reactiveSetter (newVal) {
      const value = getter ? getter.call(obj) : val // 如果本身有getter, 先调用
      /* eslint-disable no-self-compare */
      // 如果值不变就不去做通知了, (或是某个值为NaN)
      if (newVal === value || (newVal !== newVal && value !== value)) {
        return
      }
      /* eslint-enable no-self-compare */
      if (process.env.NODE_ENV !== 'production' && customSetter) {
        customSetter()
      }
      // #7981: for accessor properties without setter
      if (getter && !setter) return
      // 这里对数据的值进行修改
      if (setter) { // 如果本身有setter, 先调用, 没的话就直接赋值
        setter.call(obj, newVal)
      } else {
        val = newVal // 因为传入参数的时候其实是'obj[keys[i]]', 所以就等于是'obj[key] = newVal'了
      }
      //当为属性设置了新的值，是需要observe的
      childOb = !shallow && observe(newVal)
      //set的时候数据变化了，通知更新数据
      dep.notify()
    }
  })
}

/**
 * Collect dependencies on array elements when the array is touched, since
 * we cannot intercept array element access like property getters.
 */
function dependArray (value: Array<any>) {
  for (let e, i = 0, l = value.length; i < l; i++) {
    e = value[i]
    e && e.__ob__ && e.__ob__.dep.depend()
    if (Array.isArray(e)) {
      dependArray(e)
    }
  }
}
````

解释都在注释中了, 总结一下这个方法的做的几件重要的事:

1. 建立Dep对象. 

2. 递归调用. 可以说很大部分代码都在递归调用, 分别在创建子observe对象, setter, getter中.

3. getter中: 调用原来的getter, 收集依赖`Dep.depend()`, 同样也是递归收集.

4. setter中: 调用原来的setter, 并判断是否需要通知, 最后调用`dep.notify()`.

总结一下, 总的来说就是, 传入的data数据会被劫持, 在get的时候调用Dep.depend(), 在set的时候调用Dep.notify(). 

#### Vue.set 、 Vue.delete 

使用`Object.defineProperty`定义getter/setter方法拦截数据的不足：

当对象增删的时候，是监控不到的。比如：

`data={a:"a"}` 

这个时候如果我们设置 `data.test="test"` 是监控不到的。

因为在observe data的时候，会遍历已有的每个属性（比如a），添加getter/setter，而后面设置的test属性并没有机会设置getter/setter，所以检测不到变化。

同样的，删除对象属性的时候，getter/setter会跟着属性一起被删除掉，拦截不到变化。

因此，Vue官方给出了`vm.$set/Vue.set`和`vm.$delete/Vue.delete`这样的api来解决这个问题：

```
/**
 * Set a property on an object. Adds the new property and
 * triggers change notification if the property doesn't
 * already exist.
 */
export function set (target: Array<any> | Object, key: any, val: any): any {
  if (process.env.NODE_ENV !== 'production' &&
    (isUndef(target) || isPrimitive(target))
  ) {
    warn(`Cannot set reactive property on undefined, null, or primitive value: ${(target: any)}`)
  }
  // 对于数组的处理，调用变异方法splice，这个时候数组的Dep会发布更新消息
  if (Array.isArray(target) && isValidArrayIndex(key)) {
    target.length = Math.max(target.length, key)
    target.splice(key, 1, val)
    return val
  }
  //如果set的是对象已经有的属性，那么该属性已经有getter/setter函数了，此时直接修改即可
  if (key in target && !(key in Object.prototype)) {
    target[key] = val
    return val
  }
  const ob = (target: any).__ob__
  if (target._isVue || (ob && ob.vmCount)) {
    process.env.NODE_ENV !== 'production' && warn(
      'Avoid adding reactive properties to a Vue instance or its root $data ' +
      'at runtime - declare it upfront in the data option.'
    )
    return val
  }
  if (!ob) {
    target[key] = val
    return val
  }
  //如果是对象没有的属性，则添加getter/setter
  defineReactive(ob.value, key, val)
  //注意此处，对象的Dep会发布更新
  ob.dep.notify()
  return val
}

/**
 * Delete a property and trigger change if necessary.
 */
export function del (target: Array<any> | Object, key: any) {
  if (process.env.NODE_ENV !== 'production' &&
    (isUndef(target) || isPrimitive(target))
  ) {
    warn(`Cannot delete reactive property on undefined, null, or primitive value: ${(target: any)}`)
  }
  if (Array.isArray(target) && isValidArrayIndex(key)) {
    target.splice(key, 1)
    return
  }
  const ob = (target: any).__ob__
  if (target._isVue || (ob && ob.vmCount)) {
    process.env.NODE_ENV !== 'production' && warn(
      'Avoid deleting properties on a Vue instance or its root $data ' +
      '- just set it to null.'
    )
    return
  }
  if (!hasOwn(target, key)) {
    return
  }
  delete target[key]
  if (!ob) {
    return
  }
  ob.dep.notify()
}

export function stateMixin (Vue: Class<Component>) {
  ...
  Vue.prototype.$set = set
  Vue.prototype.$delete = del
  ...
}
```

上面的代码比较简单，看过注释应该就能明白，我不做过多解释。我们着重注意下这句代码：

`ob.dep.notify()`，对象的Dep发布更新。可是这个dep是在什么地方收集的订阅者呢？

还记得defineReactive函数里让大家注意的这句代码吗：`childOb.dep.depend()`,这句代码就是在收集订阅者。

仔细阅读Observer相关的代码，我们会发现，**dep实例化有两种类型**：

**第一种： 是在defineReactive函数里，每次调用这个函数的时候都会创建一个新的Dep实例，存在在getter/setter闭包函数的作用域链上，是为对象属性服务的。在Watcher获取属性的值的时候收集订阅者，在设置属性值的时候发布更新。**

**第二种： 是在observe函数中，此时的dep挂在被observe的数据的`__obj__`属性上，他是为对象或数组服务的，在Watcher获取属性的值的时候，如果值被observe后返回observer对象（对象和数组才会返回observer），那么就会在此时收集订阅者，在对象或数组增删元素时调用`$set`等api时发布更新的；**

defineReactive函数的getter函数里这段代码就是在收集订阅者：

```
get: function reactiveGetter () {
  var value = getter ? getter.call(obj) : val;
  if (Dep.target) {
    dep.depend();

    if (childOb) {
      //注意这里，此处的dep就是在执行var childOb = observe(val)时产生的，是用来收集childOb的订阅者的
      childOb.dep.depend()
      //如果是数组，那么数组中的每个值都添加到依赖列表里
      if (Array.isArray(value)) {
        dependArray(value)
      }
    }
  }
}
```

#### 实例分析

我们来看个例子:

```
<div id="example">
  <div>{{testA}}</div>
  <div>{{testB}}</div>
  <div>{{testC}}</div>
  <div>{{testD}}</div>
</div>

<script>
// 我们的数据对象
var data = {
  key1: {
    key2: 2,
    key3: {
      key4: 4,
      key5: [5],
    },
    key6: [6]
  },
  key7: [7, {
    key8: 8
  }],
  key9: 9
}
  
// 该对象被加入到一个 Vue 实例中
var vm = new Vue({
  el: '#example',
  data: data,
  computed: {
    testA() {
      console.log('changeA')
      return this.key1.key3.key5;
    },
    testB() {
      console.log('changeB')
      return this.key7;
    },
    testC() {
      console.log('changeC')
      return this.key7.map(o => o.key8);
    },
    testD() {
      console.log('changeD')
      return JSON.stringify(this.key7);
    },
  }
})

document.documentElement.addEventListener("click", function(){
  vm.$set(vm.key7[1], "newkey", "newval")
  // vm.key7[1].key8 += 1;
});
```

经过`observe(data)`设置dep后，数据结构中的dep如下图所示：

![](/img/localBlog/1572771632847.jpg)

其中 dep1、dep2、dep3、dep4、dep5、dep6、dep7、dep8、dep9都属于第一种dep实例化类型，而dep0、dep1'、dep3'、dep5'、dep6'、dep7'、dep7''属于第二种dep实例化类型。

testA会收集dep1、dep1'、dep3、dep3'、dep5、dep5'，下面这些操作都会触发testA的update：

```
this.key1 = 1; // 触发dep1
this.$set(this.key1, "newkey", "newval") // 触发dep1'
this.key1.key3 = 1; // 触发dep3
this.$set(this.key1.key3, "newkey", "newval") // 触发dep3'
this.key1.key3.key5 = 1; // 触发dep5
this.key1.key3.key5.push('newval') // 触发dep5'
this.key1.key3.key5.splice(0, 1, 'newval') // 触发dep5'
```

testB会收集dep7、dep7'、dep7''，下面这些操作都会触发testB的update：

```
this.key7 = 1; // 触发dep7
this.key7.push('newval') // 触发dep7'
this.key7.splice(0, 1, 'newval') // 触发dep7'
this.$set(vm.key7[1], "newkey", "newval") // 触发dep7''
```

testC会收集dep7、dep7'、dep7''、dep8，下面这些操作都会触发testC的update：

```
this.key7 = 1; // 触发dep7
this.key7.push('newval') // 触发dep7'
this.key7.splice(0, 1, 'newval') // 触发dep7'
this.$set(vm.key7[1], "newkey", "newval") // 触发dep7''
this.key7[1].key8 = 1; // 触发dep8
```

testD与testC相同，这里不再叙述。

**这里vue渲染函数会依赖testA、testB、testC、testD中所有的dep，如果它们返回的对象需要用来渲染页面，那么还会触发这些对象中属性的get。** 比如这里如果这样改：

```
<div id="example">
  <div>{{key7}}</div>
</div>
<script>
  // 我们的数据对象
  var data = {
    key1: {
      key2: 2,
      key3: {
        key4: 4,
        key5: [5],
      },
      key6: [6]
    },
    key7: [7, {
      key8: 8
    }],
    key9: 9
  }
  
  // 该对象被加入到一个 Vue 实例中
  var vm = new Vue({
    el: '#example',
    data: data,
    watch: {
      key7: function() {
        console.log('key7change')
      }
    },

  })
document.documentElement.addEventListener("click", function(){
  vm.key7[1].key8 += 1; // 触发dep8 update
});
```

我们点击页面依旧能触发视图渲染函数执行，视图更新，但对key7对watch回调不会执行，因为渲染函数有依赖dep8，key7的watch没有依赖dep8。

#### array劫持

我们先来考虑下数组修改有哪几种情况:

1. 当你利用索引直接设置一个项时

比如：

`data={arr:[1,2,3]}`，这个时候我设置`this.arr[0] = 4`,会发现数据改变了，但是视图没有更新，Vue根本没有检测到变化。

这个时候可能你会说，observeArray的时候不是会遍历数组，observe每个元素吗？

可是Observe数据的时候是会判断数据类型的，只会处理数组和对象，而this.arr里面的元素是字符串，所以无法转化成observer类，也就不会有getter/setter。

另一方面，即便arr里面是对象，比如：

`{arr:[{testobj: true}]}`，数组元素`{testobj: true}`会被observe到，那也只是在`{testobj: true}`对象里面的属性改变的时候响应，而`{testobj: true}`对象被替换是无法感知的。

2. 调用数组的变异方法

`push(),pop(),shift(),unshift(),splice(),sort(),reverse()`，这些方法是会让数组的值发生改变的，比如：

`arr=[0,1];arr.puah(3);`此时`arr=[1,2,3]`，arr发生了改变，此时是需要更新视图的，但是arr的getter/setter拦截不到变化（只有在赋值的时候才会调用setter，比如：`arr=[6,7,8]`）。

3. 当你修改数组的长度时，例如：`vm.items.length = newLength`

对于第一种情况，和对象的增减一样，可以使用`vm.$set/Vue.set`和`vm.$delete/Vue.delete`这几个api.

对于第二种情况，可以通过改写这些变异方法完成，在调用这些方法的时候发布更新消息。下面我们来看代码

```
const arrayProto = Array.prototype
export const arrayMethods = Object.create(arrayProto)

const methodsToPatch = [
  'push',
  'pop',
  'shift',
  'unshift',
  'splice',
  'sort',
  'reverse'
]

/**
 * Intercept mutating methods and emit events
 */
methodsToPatch.forEach(function (method) {
  // cache original method
  const original = arrayProto[method]
  def(arrayMethods, method, function mutator (...args) {
    const result = original.apply(this, args) // 调用原生的数组方法
    const ob = this.__ob__ // 获取observe对象
    let inserted
    switch (method) {
      case 'push':
      case 'unshift':
        inserted = args
        break
      case 'splice':
        inserted = args.slice(2)
        break
    }
    //inserted存储的是新加到数组里的元素，需要被observe
    if (inserted) ob.observeArray(inserted) // 继续递归
    // notify change
    // 发布更新
    ob.dep.notify()
    return result
  })
})
```

回过头再看Observer类中对于数组的处理，先覆盖变异数组，再observe每个数组元素。所以每当调用数组的变异方法的时候，都会更新视图。

对于第三种情况，可以使用splice来完成，splice是变异方法，会发布更新。

至于为什么vue不使用`Object.defineProperty`通过索引属性来设置属性的访问器属性，比如下面这样？

```
  if (Array.isArray(value)) {
    value.forEach((item, index) => {
      defineReactive(value, index)
    })
  } else {
    this.walk(value) 
  }

var arr = new Array(1000); // 要劫持1000个index
```

这个主要是因为性能消耗太大，性能代价和获得的用户体验收益不成正比，vue的做法是修改原生操作数组的方法，并且跟用户约定修改数组要用这些方法去操作。

#### Proxy

Proxy 可以理解成，在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。

我们都知道，Vue 3.0 要用 Proxy 替换 Object.defineProperty，那么这么做的好处是什么呢？

好处是显而易见的，比如上述 Vue 现存的两个问题，不能响应对象属性的添加和删除以及不能直接操作数组下标的问题，都可以解决。当然也有不好的，那就是兼容性问题，而且这个兼容性问题 babel 还无法解决。

**Proxy 实现观察者模式**

我们前面分析了 Vue 的源码，也了解了观察者模式的基本原理。那用 Proxy 如何实现观察者呢？我们可以简单写一下：

```
function Observer(obj) {
    Object.keys(obj).forEach(key => { // 做深度监听
        if (typeof obj[key] === 'object') {
            obj[key] = Observer(obj[key]);
        }
    });
    let dep = new Dep();
    let handler = {
        get: function (target, key, receiver) {
            Dep.target && dep.addSub(Dep.target);
            // 存在 Dep.target，则将其添加到dep实例中
            return Reflect.get(target, key, receiver);
        },
        set: function (target, key, value, receiver) {
            let result = Reflect.set(target, key, value, receiver);
            dep.notify(); // 进行发布
            return result;
        }
    };
    return new Proxy(obj, handler)
}
```

整体思路和 Vue 的差不多，需要注意的点仍旧是 get 操作时的闭包环境，使得 `Dep.target && dep.addSub(Dep.target)` 可以保证再每个属性的 getter 触发时，是当前 Watcher 实例。

### Dep

现在看下Dep的源码：

core/observer/dep.js

```
//全局变量，每个实例中的dep实例的id都是从0开始累加的
let uid = 0

/**
 * A dep is an observable that can have multiple
 * directives subscribing to it.
 */
export default class Dep {
  static target: ?Watcher;
  id: number;
  subs: Array<Watcher>;

  constructor () {
    this.id = uid++
    this.subs = [] // 保存观察者watcher实例的数组
  }

  // 添加观察者
  addSub (sub: Watcher) {
    this.subs.push(sub)
  }

  // 移除观察者
  removeSub (sub: Watcher) {
    remove(this.subs, sub)
  }

  // 让Watcher收集依赖并添加订阅者。
  // Dep.target是一个Watcher, 可以查看Watcher的addDep方法。
  // 这个方法做的事情是：收集依赖后，调用了Dep的addSub方法，给Dep添加了一个订阅者
  depend () {
    if (Dep.target) {
      Dep.target.addDep(this)
    }
  }

  //发布数据更新：通过调用subs里面的每个Watcher的update发布更新
  notify () {
    // stabilize the subscriber list first
    const subs = this.subs.slice()
    if (process.env.NODE_ENV !== 'production' && !config.async) {
      // subs aren't sorted in scheduler if not running async
      // we need to sort them now to make sure they fire in correct
      // order
      subs.sort((a, b) => a.id - b.id)
    }
    for (let i = 0, l = subs.length; i < l; i++) {
      subs[i].update()
    }
  }
}

// The current target watcher being evaluated.
// This is globally unique because only one watcher
// can be evaluated at a time.
// 这是一个队列, 因为不允许有多个watcher的get方法同时调用
Dep.target = null
const targetStack = []

export function pushTarget (target: ?Watcher) {
  // 设置target, 把旧的放进stack
  targetStack.push(target)
  Dep.target = target
}

export function popTarget () {
  // 从stack拿一个作为当前的
  targetStack.pop()
  Dep.target = targetStack[targetStack.length - 1]
}
```

其实之前在分析`Vue.set`方法的时候就已经讲过Dep了，如果还没懂的同学可以结合这里的源码来看。

Dep类比较简单，对应方法也非常直观，这里最主要的就是维护了保存有观察者实例watcher的一个数组subs。

首先来分析变量:

* 全局Target. 这个其实是用来跟watcher交互的, 也保证了普通get的时候没有target就不设置依赖, 后面会解释.

* id. 这是用来在watcher里依赖去重的, 也要到后面解释.

* subs: 是一个watcher数组. sub应该是subscribe的意思, 也就是当前dep(依赖)的订阅者列表.

再来看方法:

* depend: 如果有`Dep.target`, 就把自己添加到Dep.target中(调用了`Dep.target.addDep(this)`).

那么什么时候有`Dep.target`呢, 就由`pushTarget()`和`popTarget()`来操作了, 这些方法在Dep中没有调用, 后面会分析是谁在操作`Dep.target`.

* notify: 这个是setter劫持以后调用的最终方法, 把当前Dep订阅中的每个watcher都调用`update()`方法.

### Watcher

我们先从构造函数看起:：

core/observer/watcher.js

```
let uid = 0

/**
 * A watcher parses an expression, collects dependencies,
 * and fires callback when the expression value changes.
 * This is used for both the $watch() api and directives.
 */
export default class Watcher {
  vm: Component;
  expression: string;
  cb: Function;
  id: number;
  deep: boolean;
  user: boolean;
  lazy: boolean;
  sync: boolean;
  dirty: boolean;
  active: boolean;
  deps: Array<Dep>;
  newDeps: Array<Dep>;
  depIds: SimpleSet;
  newDepIds: SimpleSet;
  before: ?Function;
  getter: Function;
  value: any;

  constructor (
    vm: Component,
    expOrFn: string | Function,
    cb: Function,
    options?: ?Object,
    isRenderWatcher?: boolean
  ) {
    this.vm = vm // 保存vm
    if (isRenderWatcher) {
      vm._watcher = this
    }
    vm._watchers.push(this) // 把watcher存到vm里
    // options
    // 读取配置 或 设置默认值
    if (options) {
      this.deep = !!options.deep
      this.user = !!options.user
      // 跟computed相关
      this.lazy = !!options.lazy
      this.sync = !!options.sync
      this.before = options.before
    } else {
      this.deep = this.user = this.lazy = this.sync = false
    }
    this.cb = cb // 保存传入的回调函数
    this.id = ++uid // uid for batching
    this.active = true
    this.dirty = this.lazy // for lazy watchers
    this.deps = [] // 保存观察数据当前的dep实例对象
    this.newDeps = [] // 保存观察数据最新的dep实例对象
    this.depIds = new Set()
    this.newDepIds = new Set()
    this.expression = process.env.NODE_ENV !== 'production'
      ? expOrFn.toString()
      : ''
    // parse expression for getter
    //这里的getter会有两种情况：
      一、一个函数，比如在生命周期mount的时候，需要watch模板中的值，这个时候传过来的是一个函数，后面在get函数里调用时这个函数时，这个函数会调用数据的getter函数。
      二、一个表达式，比如我们在Vue实例的watch中写的表达式，后面在get函数里获取表达式的值的时候会调用数据的getter函数。
      expOrFn参数是一个字符串，比如testObj.testObjFirstVal，此时testObj仅仅是一个字符串，而不是对象，我们无法直接获取testObjFirstVal属性的值。
      所以我们在获取值得时候不能直接拿到值，parsePath函数就是用来解决这个问题的，这个函数具体的操作，在后面的代码里。
    if (typeof expOrFn === 'function') {
      this.getter = expOrFn
    } else {
      // 通过parsePath方法获取观察对象expOrFn的get方法
      this.getter = parsePath(expOrFn)
      if (!this.getter) {
        this.getter = noop
        process.env.NODE_ENV !== 'production' && warn(
          `Failed watching path: "${expOrFn}" ` +
          'Watcher only accepts simple dot-delimited paths. ' +
          'For full control, use a function instead.',
          vm
        )
      }
    }
    //注意这个地方，在非computed调用Watch函数外，都会调用get函数（computed有自己的逻辑）
    this.value = this.lazy
      ? undefined
      : this.get()
  }

  /**
   * Evaluate the getter, and re-collect dependencies.
   */
  get () {
    // 进入队列, 把当前watcher设置为Dep.target
    // 这样下面调用getter的时候出发的dep.append() (最后调用Dep.target.addDep()) 就会调用这个watcher的addDep.
    pushTarget(this)
    let value
    const vm = this.vm
    try {
      // 调用getter的时候会走一遍表达式,
      // 如果是 this.a + this.b , 会在a和b的getter中调用Dep.target.addDep(), 最后结果就调用了当前watcher的addDep,
      // 当前watcher就有了this.a的dep和this.b的dep
      // addDep把当前watcher加入了dep的sub(subscribe)里, dep的notify()调用就会运行本watcher的run()方法.
      value = this.getter.call(vm, vm)
    } catch (e) {
      if (this.user) {
        handleError(e, vm, `getter for watcher "${this.expression}"`)
      } else {
        throw e
      }
    } finally {
      // "touch" every property so they are all tracked as
      // dependencies for deep watching
      // 走到这里已经通过了getter获得到了value, 或者失败为undefined, 这个值返回作为watcher的valule
      // 处理deep选项
      if (this.deep) {
        traverse(value)
      }
      // 此时观察数据的依赖已经收集完
      popTarget() // 移除队列
      this.cleanupDeps() // 清理依赖(addDep加到newDep数组, 这步做整理动作)
    }
    return value
  }

  /**
   * Add a dependency to this directive.
   */
  addDep (dep: Dep) {
    const id = dep.id
    if (!this.newDepIds.has(id)) {
      this.newDepIds.add(id)
      this.newDeps.push(dep)
      //这里做了一个去重，如果depIds里包含这个id，说明在之前给depIds添加这个id的时候，已经调用过 dep.addSub(this)，即添加过订阅，不需要重复添加。
      if (!this.depIds.has(id)) {
        dep.addSub(this)
      }
    }
  }

  /**
   * Clean up for dependency collection.
   */
  cleanupDeps () {
    let i = this.deps.length
    //去除多余的订阅者
    while (i--) {
      const dep = this.deps[i]
      if (!this.newDepIds.has(dep.id)) {
        dep.removeSub(this)
      }
    }
    let tmp = this.depIds
    //更新depIds
    this.depIds = this.newDepIds
    this.newDepIds = tmp
    //清空newDepIds
    this.newDepIds.clear()
    tmp = this.deps
    //更新deps
    this.deps = this.newDeps
    this.newDeps = tmp
    //清空newDeps
    this.newDeps.length = 0
  }

  /**
   * Subscriber interface.
   * Will be called when a dependency changes.
   */
  update () {
    /* istanbul ignore else */
    //下面三种情况均会调用run方法
    if (this.lazy) {
      this.dirty = true
    } else if (this.sync) {
      this.run()
    } else {
      // queueWatcher这个函数最终会调用run方法。
      queueWatcher(this)
    }
  }

  /**
   * Scheduler job interface.
   * Will be called by the scheduler.
   */
  //注意这里调用了get方法，会更新模板，且重新收集依赖
  run () {
    if (this.active) {
      const value = this.get()
      if (
        value !== this.value ||
        // Deep watchers and watchers on Object/Arrays should fire even
        // when the value is the same, because the value may
        // have mutated.
        isObject(value) ||
        this.deep
      ) {
        // set new value
        const oldValue = this.value
        this.value = value
        if (this.user) {
          try {
            this.cb.call(this.vm, value, oldValue)
          } catch (e) {
            handleError(e, this.vm, `callback for watcher "${this.expression}"`)
          }
        } else {
          this.cb.call(this.vm, value, oldValue)
        }
      }
    }
  }

  /**
   * Evaluate the value of the watcher.
   * This only gets called for lazy watchers.
   */
  evaluate () {
    this.value = this.get()
    this.dirty = false
  }

  /**
   * Depend on all deps collected by this watcher.
   */
  depend () {
    let i = this.deps.length
    while (i--) {
      this.deps[i].depend()
    }
  }

  /**
   * Remove self from all dependencies' subscriber list.
   */
  teardown () {
    if (this.active) {
      // remove self from vm's watcher list
      // this is a somewhat expensive operation so we skip it
      // if the vm is being destroyed.
      if (!this.vm._isBeingDestroyed) {
        remove(this.vm._watchers, this)
      }
      let i = this.deps.length
      while (i--) {
        this.deps[i].removeSub(this)
      }
      this.active = false
    }
  }
}
```

注释都写了, 总结一下构造器做了什么事:

1. 处理传入的参数并设置成自己的属性.

2. parse表达式. watcher表达式接受2种: 方法/字符串. 如果是方法就设为getter, 如果是字符串会进行处理:

core/util/lang.js

```
export const unicodeRegExp = /a-zA-Z\u00B7\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u037D\u037F-\u1FFF\u200C-\u200D\u203F-\u2040\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD/

/**
 * Parse simple path.
 */
const bailRE = new RegExp(`[^${unicodeRegExp.source}.$_\\d]`)
export function parsePath (path: string): any {
  // 非法字符串直接返回
  if (bailRE.test(path)) {
    return
  }
  // 这里是vue如何分析watch的, 就是接受 '.' 分隔的变量.
  // 如果键是'a.b.c', 也就等于function () {return this.a.b.c}
  return function (obj) {
    for (let i = 0; i < segments.length; i++) {
      if (!obj) return
      obj = obj[segments[i]]
    }
    return obj
  }
}
```

这里的正则匹配表达式用来匹配任何不在合法范围内的字符：

![](/img/localBlog/1572761920032.jpg)

我们先来理一理watch函数做的事情：初始化变量——>获取getter函数，这里的getter函数是用来获取数据的值，函数执行过程中会调用数据的getter函数，会收集依赖——>调用watcher的get方法，收集依赖，获取值，并将这些东西记录下来。

这个过程就完成了收集依赖的过程，而update函数是用来接收数据发布更新的消息并更新模板或表达式的。

下面我们重点来关注这几点：

1. 收集依赖指的是谁收集依赖，依赖又是指的什么？

看英文注释：Watcher的作用是分割表达式，收集依赖并且在值变化的时候调用回调函数。那么我们很明确知道是Watcher在收集依赖，依赖到底指什么呢？

我们上面说过一个Dep对应着一个数据（这个数据可能是：对象的属性、一个对象、一个数组）;一个Watcher对应可以是一个模板也可以是一个`$watch`对应的表达式、函数等，无论那种情况，他们都依赖于data里面的数据，所以这里说的依赖其实就是模板或表达式所依赖的数据，对应着相关数据的Dep。

举个例子：下面这个`$watch`对应的函数依赖的数据就是testWatcher和testVal。所以这个`$watch`对应的Watcher收集的依赖就是testWatcher和testVal对应的Dep。

```
app.$watch(function(){
  return this.testWatcher + this.testVal;
},function(newVal){
  console.log(newVal
 })
```
2. Watcher有四个使用的场景，只有在这四种场景中，Watcher才会收集依赖，更新模板或表达式，否则，数据改变后，无法通知依赖这个数据的模板或表达式：

* 第一种：观察模板中的数据

* 第二种：观察创建Vue实例时watch选项里的数据

* 第三种：观察创建Vue实例时computed选项里的数据所依赖的数据

* 第四种：调用`$watch` api观察的数据或表达式

所以在解决数据改变，模板或表达式没有改变的问题时，可以这么做：

首先仔细看一看数据是否在上述四种应用场景中，以便确认数据已经收集依赖；其次查看改变数据的方式，确定这种方式会使数据的改变被拦截。

3. `Dep.target`的作用

我们前面说过收集依赖的时机是在调用数据的getter函数的时候，但是在这个时候数据的getter函数不知道当前的Watcher是哪一个，所以这里使用了一个全局变量来记录当前的Watcher，方便添加依赖到正在执行的Watcher。关于这点官方的英文注释写的挺清楚的。

4. targetStack的作用（Watcher函数的get方法中pushTarget和popTarget方法中用到）

Vue2 中，视图被抽象为一个 render 函数，一个 render 函数只会生成一个 watcher。比如我们有如下一个模板，模板中使用了Header组件。Vue2 中组件数的结构在视图渲染时就映射为 render 函数的嵌套调用，有嵌套调用就会有调用栈。当 render模板时，遇到Header组件会调用Header组件的render函数，两个render函数依次入栈，执行完函数，依次出栈。

```
<div id="app">
  <Header></Header>
</div>
```

5.Watcher函数的get方法中调用`this.getter.call(vm, vm)`收集完依赖后，又调用`this.cleanupDeps()`清除依赖?

Watcher里面有两个属性：deps和newDeps。他们是用来记录上一次Watcher收集的依赖和新一轮Watcher收集的依赖，每一次有数据的更新都需要重新收集依赖（数据发布更新后，会调用Watcher的notify方法，notify方法会调用run方法，run方法会调用get方法，重新获取值，并重新收集依赖）。举个简单的例子：我们点击一个按钮，用`$set`给data添加了一个新属性newVal。上一轮收集的依赖中并没有newVal的依赖，所以需要重新收集依赖。

`this.cleanupDeps()`这个函数的作用就是将新收集的依赖newDeps赋值给deps，并将newDeps清空，准备在下一次数据更新时收集依赖。所以这个函数不是真正的清空Watcher的依赖，而是清除临时保存依赖的newDeps。


### initWatch

initWatch源码如下：

src/core/instance/state.js

```
function initWatch (vm: Component, watch: Object) {
  for (const key in watch) {
    // handler 是观察对象的回调函数
    const handler = watch[key]
    if (Array.isArray(handler)) {
      for (let i = 0; i < handler.length; i++) {
        createWatcher(vm, key, handler[i])
      }
    } else {
      createWatcher(vm, key, handler)
    }
  }
}
```

createWatcher(vm, key, handler)是根据入参构建Watcher实例信息，源码如下：

```
function createWatcher (
  vm: Component,
  expOrFn: string | Function,
  handler: any,
  options?: Object
) {
  // 判断是否是对象，是的话提取对象里面的handler方法
  if (isPlainObject(handler)) {
    options = handler
    handler = handler.handler
  }
  // 判断handler是否是字符串，是的话说明是vm实例上的一个方法
  // 通过vm[handler]获取该方法
  // 如 handler='sayHello', 那么handler = vm.sayHello
  if (typeof handler === 'string') {
    handler = vm[handler]
  }
  // 最后调用vm原型链上的$watch(...)方法创建Watcher实例
  return vm.$watch(expOrFn, handler, options)
}
```

`$watch`是定义在Vue原型链上的方法，源码如下：

core/instance/state.js

```
Vue.prototype.$watch = function (
  expOrFn: string | Function,
  cb: any,
  options?: Object
): Function {
  const vm: Component = this
  if (isPlainObject(cb)) {
    return createWatcher(vm, expOrFn, cb, options)
  }
  options = options || {}
  options.user = true
  const watcher = new Watcher(vm, expOrFn, cb, options)
  if (options.immediate) {
    try {
      cb.call(vm, watcher.value)
    } catch (error) {
      handleError(error, vm, `callback for immediate watcher "${watcher.expression}"`)
    }
  }
  // 该方法返回一个函数的引用，直接调用该函数就会调用watcher对象的teardown()方法，从它注册的列表中(subs)删除自己。
  return function unwatchFn () {
    watcher.teardown()
  }
}
```

经过一系列的封装，这里终于看到了创建Watcher实例对象了。

#### 实例分析

这里看一个watch属性的例子：

````
var vue = new Vue({
    el: "#app",
    data: {
        counter: 1
    },
    watch: {
        counter: function(val, oldVal) {
            console.log('counter changed...')
        }
    }
})
````

例子中Observer，Watcher类之间的关联关系图如下所示：

![](/img/localBlog/1572712672789.jpg)

* 红色箭头：Watcher类实例化，调用watcher实例的`get()`方法，并设置`Dep.target`为当前watcher实例，触发观察对象的getter方法。

* 蓝色箭头：counter对象的getter方法被触发，调用`dep.depend()`进行依赖收集并返回counter的值。依赖收集的结果：

  1. **counter闭包的dep实例的subs添加观察它的watcher实例w1；**
  
  2. **w1的deps中添加观察对象counter的闭包dep。**

* 橙色箭头：当counter的值变化后，触发subs中观察它的w1执行`update()`方法，最后实际上是调用w1的回调函数cb。

### initComputed

我们找到initComputed的定义：

```
const computedWatcherOptions = { lazy: true }

function initComputed (vm: Component, computed: Object) {
  // $flow-disable-line
  // 往组件实例上添加一个_computedWatchers属性，保存所有的computed watcher
  const watchers = vm._computedWatchers = Object.create(null)
  // computed properties are just getters during SSR
  const isSSR = isServerRendering()

  for (const key in computed) {
    // 循环每个computed
    // 格式滤错滤空
    const userDef = computed[key]
    // 我们在定义computed时可以是一个函数，也可以是一个对象{get:function(){}, set:function(){}}
    const getter = typeof userDef === 'function' ? userDef : userDef.get
    if (process.env.NODE_ENV !== 'production' && getter == null) {
      warn(
        `Getter is missing for computed property "${key}".`,
        vm
      )
    }

    if (!isSSR) {
      // create internal watcher for the computed property.
      // 数据响应过程中的watcher（注意第二个参数是我们刚才拿到的getter,记住了）
      watchers[key] = new Watcher(
        vm,
        getter || noop,
        noop, // noop是定义的一个空方法，这里没有回调函数用noop代替
        computedWatcherOptions // { lazy: true }
      )
    }

    // component-defined computed properties are already defined on the
    // component prototype. We only need to define computed properties defined
    // at instantiation here.
    // 因为没有被代理, computed属性是不能通过vm.xx获得的, 如果可以获得说明重复定义, 抛出异常.
    if (!(key in vm)) {
      defineComputed(vm, key, userDef)
    } else if (process.env.NODE_ENV !== 'production') {
      if (key in vm.$data) {
        warn(`The computed property "${key}" is already defined in data.`, vm)
      } else if (vm.$options.props && key in vm.$options.props) {
        warn(`The computed property "${key}" is already defined as a prop.`, vm)
      }
    }
  }
}
```

已注释, 总结为:

1. 遍历每个computed键值, 过滤错误语法.

2. 遍历每个computed键值, 为他们建立watcher, options为`{ lazy: true}`.

3. 遍历每个computed键值, 调用defineComputed.

那么继续看defineComputed.

```
export function defineComputed (
  target: any,
  key: string,
  userDef: Object | Function
) {
  const shouldCache = !isServerRendering()
  // 因为computed除了function还有get set 字段的语法, 下面的代码是做api的兼容
  if (typeof userDef === 'function') {
    sharedPropertyDefinition.get = shouldCache
      ? createComputedGetter(key)
      : createGetterInvoker(userDef)
    sharedPropertyDefinition.set = noop
  } else {
    sharedPropertyDefinition.get = userDef.get
      ? shouldCache && userDef.cache !== false
        ? createComputedGetter(key)
        : createGetterInvoker(userDef.get)
      : noop
    sharedPropertyDefinition.set = userDef.set || noop
  }
  // 除非设置setter, computed属性是不能被修改的, 抛出异常 (evan说改变了自由哲学, 要控制低级用户)
  if (process.env.NODE_ENV !== 'production' &&
      sharedPropertyDefinition.set === noop) {
    sharedPropertyDefinition.set = function () {
      warn(
        `Computed property "${key}" was assigned to but it has no setter.`,
        this
      )
    }
  }
  // 这个函数的主要功能是computed属性的get进行了重写
  Object.defineProperty(target, key, sharedPropertyDefinition)
}

function createComputedGetter (key) {
  // 返回一个函数，也就是我们在上一个函数中那个get函数
  return function computedGetter () {
    // 拿到我们在initComputed函数中添加到vm上面的_computedWatchers
    const watcher = this._computedWatchers && this._computedWatchers[key]
    // 如果我们有定义computed属性，watcher必定存在
    if (watcher) {
      if (watcher.dirty) { // ****标记：知识点1
        watcher.evaluate() // ****标记：知识点2
      }
      if (Dep.target) { // ****标记：知识点3
        watcher.depend() // ****标记：知识点4
      }
      return watcher.value // ****标记：知识点5
    }
  }
}
```

注意下面这行代码，`watcher.depend()`的作用是把当前computed中watch收集的dep依赖让当前Dep.target中的watch也收集一遍，也就是说在一个watch依赖另一个watch时，会将被依赖watch的dep全部收集到自己的dep内：

```
  if (watcher) {
    if (watcher.dirty) { // ****标记：知识点1
      watcher.evaluate() // ****标记：知识点2
    }
    if (Dep.target) { // ****标记：知识点3
      watcher.depend() // ****标记：知识点4
    }
    return watcher.value // ****标记：知识点5
  }

  ... 
  depend () {
    let i = this.deps.length
    while (i--) {
      this.deps[i].depend()
    }
  }
```

看到这里, computed注册核心一共做了两件事:

1. 为每个computed建立`watcher(lazy: true)`

2. 建立一个getter来depend, 并挂到vm上.

```
new Vue({
  data(){
    return {
      dataA: 'a',
      dataB: 'b'
    }
  },
  template: '<div>{{computedA}}-{{dataB}}</div>',
  computed: {
    computedA() {
      return 'computed ' + this.dataA
    }
  },
  method: {
      changeA(){
          this.dataA = 'change dataA'
      },
      changeB(){
          this.dataA = 'change dataB'
      }
  }
})
```

看在createComputedGetter函数

1，第一次页面渲染时模板中的`{{computedA}}`执行`computedA.get()` 转到函数createComputedGetter中

2，知识点1： `this.dirty = true`

3，知识点2：`watcher.evaluate()`执行，将`this.dirty = false`，watcher内部执行知识点getter：`this.getter()`

```
this.getter = computedA = function(){
    return 'computed' + this.dataA // 看这里，看这里，看这里，知识点update
}
```

得到了`wacher.value` 等于 computed a

4，**`watcher.depend()`重新收集依赖，此时渲染函数的watch将computedA中watch的dep收集到自己的dep下(此处即dataA的dep)，所以后面改变dataA会触发computedA中watch的update以及渲染函数watch的update**

5，返回`wacher.value`,渲染到页面上`<div>computed a-b</div>`

6，我们通过调用`this.changA()改`变dataA，调用dataA中的`dep.notify()`，会执行dataA的所有watcher对象`wathcer.update()`(**包括computedA中watch的update以及渲染函数watch的update**)，因为computed所属watcher的lazy永远为true，知识点1： `this.dirty = true`，这里暂时不会执行get

7，因为dataA改变了，触发页面重新渲染，重新渲染模板，模板中的`{{computedA}}`会调用`computedA.get()`，循环第1步

#### computed的属性缓存

通过上门computed的响应过程我们知道，computedA会监听dataA的改变去改变知识点1： `this.dirty = true`才最终执行了知识点getter

假设:

我们现在执行`this.changeB()`，改变了dataB值，

会执行dataB的所有watcher对象`wathcer.update()`，

因为dataB改变了，触发页面重新渲染，重新渲染模板，模板中的`{{computedA}}`再次调用`computedA.get()`转到函数createComputedGetter中。

因为computedA并没有监听dataB的改变，也就不会执行到computedA的`watcher.update()`知识点1：`this.dirty = false`，最终并不会执行到getter

直接返回上次getter的结果`return watcher.value`


#### 实例分析

这里看一个计算属性的例子：

```
var vue = new Vue({
    el: "#app",
    data: {
        counter: 1
    },
    computed: {
        result: function() {
            return 'The result is :' + this.counter + 1;
        }
    }
})
```

示意图如下所示：

![](/img/localBlog/1572713210736.jpg)

这里计算属性result因为依赖于`this.counter`，因此设置一个watcher用来观察result的值。随后通过`definedComputed(vm, key, userDef)`来定义计算属性。在计算获取result的时候，又会触发`this.counter`的getter方法，这样使得result的值依赖于`this.counter`的值。

### initProps

最后我们再简单过一下props的初始化：

```
function initProps (vm: Component, propsOptions: Object) {
  const propsData = vm.$options.propsData || {} // 父组建传进来的props数据
  const props = vm._props = {} // 子组建的pops对象
  // cache prop keys so that future props updates can iterate using Array
  // instead of dynamic object key enumeration.
  const keys = vm.$options._propKeys = []
  const isRoot = !vm.$parent
  // root instance props should be converted
  if (!isRoot) {
    toggleObserving(false)
  }
  for (const key in propsOptions) {
    keys.push(key)
    const value = validateProp(key, propsOptions, propsData, vm) // 取出该key对应的value，如果没传则会取default的值
    /* istanbul ignore else */
    if (process.env.NODE_ENV !== 'production') {
      const hyphenatedKey = hyphenate(key)
      if (isReservedAttribute(hyphenatedKey) ||
          config.isReservedAttr(hyphenatedKey)) {
        warn(
          `"${hyphenatedKey}" is a reserved attribute and cannot be used as component prop.`,
          vm
        )
      }
      defineReactive(props, key, value, () => {
        if (!isRoot && !isUpdatingChildComponent) {
          warn(
            `Avoid mutating a prop directly since the value will be ` +
            `overwritten whenever the parent component re-renders. ` +
            `Instead, use a data or computed property based on the prop's ` +
            `value. Prop being mutated: "${key}"`,
            vm
          )
        }
      })
    } else {
      defineReactive(props, key, value) // 响应式劫持
    }
    // static props are already proxied on the component's prototype
    // during Vue.extend(). We only need to proxy props defined at
    // instantiation here.
    if (!(key in vm)) {
      proxy(vm, `_props`, key) // 做代理
    }
  }
  toggleObserving(true)
}
```

接着看pros是怎么取值的：

```

export function validateProp (
  key: string,
  propOptions: Object,
  propsData: Object,
  vm?: Component
): any {
  const prop = propOptions[key]
  const absent = !hasOwn(propsData, key)
  let value = propsData[key] // 取父组建传进来的值
  // boolean casting
  const booleanIndex = getTypeIndex(Boolean, prop.type)
  if (booleanIndex > -1) { // 如果是boolean类型，且没有传值
    if (absent && !hasOwn(prop, 'default')) {
      value = false
    } else if (value === '' || value === hyphenate(key)) {
      // only cast empty string / same name to boolean if
      // boolean has higher priority
      const stringIndex = getTypeIndex(String, prop.type)
      if (stringIndex < 0 || booleanIndex < stringIndex) {
        value = true
      }
    }
  }
  // check default value
  if (value === undefined) { // 其它类型，且没有传值
    value = getPropDefaultValue(vm, prop, key) // 重点关注，取默认值的逻辑
    // since the default value is a fresh copy,
    // make sure to observe it.
    const prevShouldObserve = shouldObserve
    toggleObserving(true)
    observe(value)
    toggleObserving(prevShouldObserve)
  }
  if (
    process.env.NODE_ENV !== 'production' &&
    // skip validation for weex recycle-list child component props
    !(__WEEX__ && isObject(value) && ('@binding' in value))
  ) {
    assertProp(prop, key, value, vm, absent)
  }
  return value
}

/**
 * Use function string name to check built-in types,
 * because a simple equality check will fail when running
 * across different vms / iframes.
 */
function getType (fn) {
  const match = fn && fn.toString().match(/^\s*function (\w+)/)
  return match ? match[1] : ''
}

// 比较props的类型
function isSameType (a, b) {
  return getType(a) === getType(b)
}

// 如果有定义可以是多个类型，则需要依次比较
function getTypeIndex (type, expectedTypes): number {
  if (!Array.isArray(expectedTypes)) {
    return isSameType(expectedTypes, type) ? 0 : -1
  }
  for (let i = 0, len = expectedTypes.length; i < len; i++) {
    if (isSameType(expectedTypes[i], type)) {
      return i
    }
  }
  return -1
}
```

在没有传值，需要取默认值时：

```
/**
 * Get the default value of a prop.
 */
function getPropDefaultValue (vm: ?Component, prop: PropOptions, key: string): any {
  // no default, return undefined
  if (!hasOwn(prop, 'default')) {
    return undefined
  }
  const def = prop.default
  // warn against non-factory defaults for Object & Array
  if (process.env.NODE_ENV !== 'production' && isObject(def)) {
    warn(
      'Invalid default value for prop "' + key + '": ' +
      'Props with type Object/Array must use a factory function ' +
      'to return the default value.',
      vm
    )
  }
  // the raw prop value was also undefined from previous render,
  // return previous default value to avoid unnecessary watcher trigger
  // 如果重复声明了一个props，且之前的也是父组建没有传值进来，则不再做代理
  if (vm && vm.$options.propsData &&
    vm.$options.propsData[key] === undefined &&
    vm._props[key] !== undefined
  ) {
    return vm._props[key]
  }
  // call factory function for non-Function types
  // a value is Function if its prototype is function even across different execution context
  // 如果是函数，且类型不是函数，则会执行，否则直接取值
  return typeof def === 'function' && getType(prop.type) !== 'Function'
    ? def.call(vm)
    : def
}
```

### 数据初始化的顺序

这里我们再回到initState函数，看一下这些初始化的顺序：

```
export function initState (vm: Component) {
  vm._watchers = []
  const opts = vm.$options
  if (opts.props) initProps(vm, opts.props)
  if (opts.methods) initMethods(vm, opts.methods)
  if (opts.data) {
    initData(vm)
  } else {
    observe(vm._data = {}, true /* asRootData */)
  }
  if (opts.computed) initComputed(vm, opts.computed)
  if (opts.watch && opts.watch !== nativeWatch) {
    initWatch(vm, opts.watch)
  }
}
```

可以看到，**是按props、methods、data、computed、watch的顺序依次初始化一个新的vue对象。因为props和methods不依赖与其它项，所以优先初始化。而computed和watch都需要data先进行数据劫持才能开始观察，所以他们在data初始化之后才能初始化。**

这里的先后顺序是很重要的，如果数据初始化存在依赖关系，则会造成数据获取不到。

因为props默认值我们可以定义为函数，所以我们来看props中获取默认值的方法：

```
/**
 * Get the default value of a prop.
 */
function getPropDefaultValue (vm: ?Component, prop: PropOptions, key: string): any {
  ...
  return typeof def === 'function' && getType(prop.type) !== 'Function'
    ? def.call(vm) // 这里会把this绑定为当前vm实例，但此时其它属性都还未定义
    : def
}
```

**因为props是最先定义的，我们在props中没法调用methods中的方法，也没法获取data、computed值**

而对于initData，相关代码如下：

```
function initData (vm: Component) {
  let data = vm.$options.data
  data = vm._data = typeof data === 'function'
    ? getData(data, vm)
    : data || {}
  ...
}

export function getData (data: Function, vm: Component): any {
  pushTarget()
  try {
    return data.call(vm, vm)// 这里会把this绑定为当前vm实例，且会当作第一个参数传入，此时可以访问props和methods，但computed属性还未定义
  } catch (e) {
    handleError(e, vm, `data()`)
    return {}
  } finally {
    popTarget()
  }
}
```

**在初始化data的时候，我们可以获取到此时已经初始化完成的props和methods属性，但computed属性还不能获取到，且如果methods依赖与computed属性，那么data即使可以调用这个methods但无法获取到对应但computed。**


结合上面分析，我们来看如下代码：

```
export default {
  props: {
    propsKey: {
      type: String,
      default() {
        return 'props值';
        return this.dataKey; // undefined，获取不到，此时data尚未初始化
        return this.methodsKey1(); // 报错，获取不到，此时methods尚未初始化
      }
    },
  },
  data() {
    return {
      dataKey1: 'data值'; // 'data值'
      dataKey2: this.propsKey; // 'props值'，可以获取，此时props已经初始化
      dataKey3: this.computedKey; // undefined，获取不到，此时computed尚未初始化
      dataKey4: this.methodsKey1(); // '普通值'，可以获取，此methods不依赖computed
      dataKey5: this.methodsKey2(); // undefined，获取不到，此methods依赖computed，而此时computed尚未初始化
    };
  },
  computed: {
    computedKey() {
      return 'computed值';
    },
  },
  methods: {
    methodsKey1() {
      return '普通值';
    },
    methodsKey2() {
      return this.computedKey; // 返回一个computed属性的值
    },
  }
};
```

### 小结

最后来几个简单问题回顾一下：

Q1：Watcher，Dep，Observer这几个类之间的关系？

A1：Watcher是观察者观察经过Observer封装过的数据，Dep是Watcher和观察数据间的纽带，主要起到依赖收集和通知更新的作用。

Q2：Dep中的subs存储的是什么？

A2: subs存储的是观察者Watcher实例。

Q3：Watcher中的deps存储的是什么？

A3：deps存储的是观察数据闭包中的dep实例。

Q4：Dep.target是什么，该值是何处赋值的？

A4：Dep.target是全局变量，保存当前的watcher实例，在`new Watcher()`的时候进行赋值，赋值为当前Watcher实例。