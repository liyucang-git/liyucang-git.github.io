---
layout: post
title:  js垃圾回收机制
subtitle: 探索内存管理的奥秘
date: 2019-03-23
author: Li Yucang
catalog: true
tags:
    - 垃圾回收
---

# js垃圾回收机制

## JS内存机制

### 内存基本概念

无论高级语言，还是低级语言。内存的管理都是：

* 内存分配：申明变量、函数、对象，系统会自动分配内存
* 内存使用：读写内存，使用变量、函数等
* 内存回收：使用完毕，由垃圾回收机制自动回收不再使用的内存

像C语言这样的高级语言一般都有底层的内存管理接口，比如 malloc()和free()。另一方面，JavaScript创建变量（对象，字符串等）时分配内存，并且在不再使用它们时“自动”释放。 后一个过程称为垃圾回收。这个“自动”是混乱的根源，并让JavaScript（和其他高级语言）开发者感觉他们可以不关心内存管理。

JS内存空间分为栈(stack)、堆(heap)、池(一般也会归类为栈中)。 其中栈存放变量，堆存放复杂对象，池存放常量。

对象放在heap（堆）里，常见的基础类型和函数放在stack（栈）里，函数执行的时候在栈里执行。

### 基础数据类型与栈内存

JS中的基础数据类型，这些值都有固定的大小，往往都保存在栈内存中（闭包除外），由系统自动分配存储空间。

我们可以直接操作保存在栈内存空间的值，因此基础数据类型都是按值访问数据在栈内存中的存储与使用方式类似于数据结构中的堆栈数据结构，遵循后进先出的原则。

stack中主要存放一些基本类型的变量和对象的引用，存在栈中的数据大小与生存期必须是确定的。可以明确知道每个区块的大小，因此，stack的寻址速度要快于heap。

````
Number String Null Undefined Boolean 
(es6新引入了一种数据类型，Symbol)

var a = 1 
````

我们定义一个变量a，系统自动分配存储空间。我们可以直接操作保存在栈内存空间的值，因此基础数据类型都是按值访问。

数据在栈内存中的存储与使用方式类似于数据结构中的栈数据结构，遵循后进先出的原则。

### 引用数据类型与堆内存

与其他语言不同，JS的引用数据类型，比如数组Array，它们值的大小是不固定的。引用数据类型的值是保存在堆内存中的对象。JavaScript不允许直接访问堆内存中的位置，因此我们不能直接操作对象的堆内存空间。

在操作对象时，实际上是在操作对象的引用而不是实际的对象。因此，引用类型的值都是按引用访问的。这里的引用，我们可以粗浅地理解为保存在栈内存中的一个地址，该地址与堆内存的实际值相关联。 

heap是没有结构的，数据可以任意存放。heap用于复杂数据类型（引用类型）分配空间，例如数组对象、object对象。

````
var b = { xi : 20 }
````

### 比较

````
var a1 = 0;   // 栈 
var a2 = 'this is string'; // 栈
var a3 = null; // 栈

var b = { m: 20 }; // 变量b存在于栈中，{m: 20} 作为对象存在于堆内存中
var c = [1, 2, 3]; // 变量c存在于栈中，[1, 2, 3] 作为对象存在于堆内存中
````

![](/img/localBlog/1557803938843.jpg)

因此当我们要访问堆内存中的引用数据类型时，实际上我们首先是从栈中获取了该对象的地址引用（或者地址指针），然后再从堆内存中取得我们需要的数据。

再来看看堆和栈复制操作存在的差异：

````
var a = 20;
var b = a;
b = 30;
console.log(a)
````

![](/img/localBlog/1557804152823.jpg)

````
var m = { a: 10, b: 20 }
var n = m;
n.a = 15;
console.log(m.a)
````

![](/img/localBlog/1557804196869.jpg)

不难看出，基本数据类型的是复制的值，而引用数据类型是复制的值的引用。

内存机制我们了解了，又引出一个新的问题，栈里只能存基础数据类型吗，我们经常用的function存在哪里呢？

### 函数执行栈

对象放在heap（堆）里，常见的基础类型和函数放在stack（栈）里，函数执行的时候在栈里执行。

简单复习一下事件循环机制：

（1）所有同步任务都在主线程上执行，形成一个执行栈（execution context stack）。

（2）主线程之外，还存在一个"任务队列"（task queue）。只要异步任务有了运行结果，就在"任务队列"之中放置一个事件。

（3）一旦"执行栈"中的所有同步任务执行完毕，系统就会读取"任务队列"，看看里面有哪些事件。那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行。

（4）主线程不断重复上面的第三步。

函数调用形成了一个栈帧：

````
function foo(b) {
  var a = 10;
  return a + b + 11;
}

function bar(x) {
  var y = 3;
  return foo(x * y);
}

console.log(bar(7));
````

当调用bar时，创建了第一个帧 ，**帧中包含了bar的参数和局部变量**。

![](/img/localBlog/1557805683220.jpg)

当bar调用foo时，第二个帧就被创建，并被压到第一个帧之上，帧中包含了foo的参数和局部变量。当foo返回时，最上层的帧就被弹出栈（剩下bar函数的调用帧 ）。

![](/img/localBlog/1557805731724.jpg)

当bar返回的时候，栈就空了。

### 堆与栈的大小

程序运行时，每个线程分配一个stack，每个进程分配一个heap，也就是说，stack是线程独占的，heap是线程共用的。此外，stack创建的时候，大小是确定的，数据超过这个大小，就发生stack overflow错误，而heap的大小是不确定的，需要的话可以不断增加。所以这里只看stack的大小限制。下面是一个简单的测试：

````
var i=0;
function inc() {
    i++;
    console.log(i);
    inc();
}
inc();
````

测试环境是16G内存的电脑，需要注意的是：根据栈的定义可以知道如果 inc 函数里有变量申明的话也是会有内存占用的。

![](/img/localBlog/1557806461806.jpg)

### 内存泄漏与内存溢出

内存溢出 (out of memory)，是指程序在申请内存时，没有足够的内存空间供其使用，出现 out of memory；比如申请了一个 integer，但给它存了 long 才能存下的数，那就是内存溢出。

什么情况下会内存泄漏？可以这么理解，就是有些代码本来应该要被回收的，但是没有被回收，所以一直占用着操作系统的内存，从而越积越多。一般的内存泄漏其实无关紧要，可怕的是内存泄漏引起的堆积，导致GC一直没办法使用所占用的内存给其他程序使用。

注意： 内存泄漏(memory leak) 会最终会导致 out of memory

## 垃圾回收机制策略简介

js具有自动垃圾回收机制。虽然开发的时候不用过于关心内存，因为分配和回收都实现了自动管理。但是了解自己写的代码，在执行的过程中发生了什么，有助于我们写出更加优秀的代码。

### 引用概念

垃圾回收算法主要依赖于引用的概念。

在内存管理的环境中，一个对象如果有访问另一个对象的权限（隐式或者显式），叫做一个对象引用另一个对象。例如，一个Javascript对象具有对它原型的引用（隐式引用）和对它属性的引用（显式引用）。

**“对象”的概念不仅特指 JavaScript 对象，还包括函数作用域（或者全局词法作用域）。**

### 引用计数垃圾收集

这是最初级的垃圾收集算法。此算法把“对象是否不再需要”简化定义为“对象有没有其他对象引用到它”。

引用计数跟踪几个每个值被引用的次数，当声明一个引用类型值赋给该变量时，则这个值的引用次数就是 1，如果同一个值被赋给另外一个变量，则该值的引用次数加 1。

相反，如果包含对这个值引用的变量又取了另外一个值，则这个值的引用次数减 1。当这个值的引用次数变成 0 时，就可以将其内存空间回收。当垃圾回收器再次运行时，它就会释放哪些引用次数为 0 的值所占用的内存。

````
var o = { 
  a: {
    b:2
  }
}; 
// 两个对象被创建，一个作为另一个的属性被引用，另一个被分配给变量o
// 很显然，没有一个可以被垃圾收集


var o2 = o; // o2变量是第二个对“这个对象”的引用

o = 1;      // 现在，“这个对象”的原始引用o被o2替换了

var oa = o2.a; // 引用“这个对象”的a属性
// 现在，“这个对象”有两个引用了，一个是o2，一个是oa

o2 = "yo"; // 最初的对象现在已经是零引用了
           // 他可以被垃圾回收了
           // 然而它的属性a的对象还在被oa引用，所以还不能回收

oa = null; // a属性的那个对象现在也是零引用了
           // 它可以被垃圾回收了
````

**引用计数缺陷**

该算法有个限制：无法处理循环引用。在下面的例子中，两个对象被创建，并互相引用，形成了一个循环。它们被调用之后会离开函数作用域，所以它们已经没有用了，可以被回收了。然而，引用计数算法考虑到它们互相都有至少一次引用，所以它们不会被回收。

````
function f(){
  var o = {};
  var o2 = {};
  o.a = o2; // o 引用 o2
  o2.a = o; // o2 引用 o

  return "azerty";
}

f();
````

**IE 存在的问题**

在 IE9 之前，IE 中有一部分对象并不是原生 JavaScript 对象。例如，BOM 和 DOM 中的对象就是 C++ 实现的 COM 对象，而 COM 对象的垃圾收集机制采用的是引用计数策略。因此，即使 IE 中的 JavaScript 引擎使用标记清除策略实现，但是 JS 访问的 COM 对象依然是基于引用计数策略的。可以在 IE 中涉及到 COM 对象，就会存在循环引用的问题。

````
var ele = document.getElementById('some_element')
var obj = new Object()
obj.ele = ele
ele.someObj = obj
````

在这个例子中一个 DOM 元素与一个原生 JS 对象之间创建了循环引用，由于 COM 的引用计数的垃圾回收策略，导致例子中的 DOM 从页面删除，也不会被垃圾回收。

解决办法：

````
obj.ele = null
ele.someObj = null
````

将变量设置为 null 意味着切断变量和它此前引用值之间的连接。当垃圾回收器下次运行时，就能删除这些值并回收它们占用的内存。

IE9 之后，DOM 和 BOM 对象都被转换成立真正的 JS 对象，这样就避免了两种垃圾回收算法并存导致的问题。

### 标记-清除算法

JavaScript 中最常用的垃圾回收方式就是标记清除（mark-and-sweep），当变量进入环境时，就将这个变量标记“进入环境”，当变量离开环境时，就将其标记为“离开环境”。

至于怎么标记有很多种方式，比如翻转某个特殊位来来记录一个变量何时进入环境、使用一个“进入环境”变量列表和一个“离开环境”列表等。

此算法可以分为两个阶段，一个是标记阶段（mark），一个是清除阶段(sweep)。

1. 标记阶段，垃圾回收器会从根对象开始遍历。每一个可以从根对象访问到的对象都会被添加一个标识，于是这个对象就被标识为可到达对象。
2. 清除阶段，垃圾回收器会对堆内存从头到尾进行线性遍历，如果发现有对象没有被标识为可到达对象，那么就将此对象占用的内存回收，并且将原来标记为可到达对象的标识清除，以便进行下一次垃圾回收操作。

![](/img/localBlog/gc_mark_sweep.gif)

从2012年起，所有现代浏览器都使用了标记-清除垃圾回收算法。所有对JavaScript垃圾回收算法的改进都是基于标记-清除算法的改进，并没有改进标记-清除算法本身和它对“对象是否不再需要”的简化定义。

**JavaScript的根对象**

GC的时候，从根对象开始遍历。在浏览器，根对象是 window；在 Node.js 中，是 global（或称为root）.

![](/img/localBlog/1557820351348.jpg)

Node.js中，每个文件被当做一个模块，所以，当你用 var/let/const 在文件的全局，声明变量的时候，作用域是当前文件（模块）。因此，图中 root.a 是 undefined。

**标记-清除算法缺陷**

* 那些无法从根对象查询到的对象都将被清除
* 垃圾收集后有可能会造成大量的内存碎片，如果一个对象由于需要占用较大内存单位而无法分配，那么就会导致Mutator一直处于暂停状态，而Collector一直在尝试进行垃圾收集，直到Out of Memory。

### V8垃圾回收算法(分代回收)

#### 概念

![](/img/localBlog/1557824118913.jpg)

这个和 Java 回收策略思想是一致的。目的是通过区分「临时」与「持久」对象；多回收「临时对象区」（young generation），少回收「持久对象区」（tenured generation），减少每次需遍历的对象，从而减少每次GC的耗时。Chrome 浏览器所使用的 V8 引擎就是采用的分代回收策略。

「临时」与「持久」对象也被叫做作「新生代」与「老生代」对象。

![](/img/localBlog/1557823718976.jpg)

#### V8内存限制

在node中javascript能使用的内存是有限制的.

* 64位系统下约为1.4GB。
* 32位系统下约为0.7GB。

对应到分代内存中，默认情况下。

* 32位系统新生代内存大小为16MB，老生代内存大小为700MB。
* 64位系统下，新生代内存大小为32MB，老生代内存大小为1.4GB。

新生代平均分成两块相等的内存空间，叫做semispace，每块内存大小8MB（32位）或16MB（64位）。

在这样限制下，将会导致Node无法直接操作大内存对象，比如无法将一个2GB的文件读入内存中进行字符串分析处理，即使物理内存有32GB，这样在单个Node进程的情况下，计算机的内存资源无法得到充足的使用。

**Node提供V8内存使用量查看方式**

````
$ node
$ process.memoryUsage();
{
  rss: 18702336,
  heapTotal: 10295296,
  heapUsed:5409936
}
````

heapTotal：已申请到的堆内存；

heapUsed：当前使用的量。

V8的堆示意图如下：

![](/img/localBlog/1557824383738.jpg)

JS声明变量并赋值时，所使用对象的内存就分配在堆中。如果已申请的堆空闲内存不够分配新的对象，将继续申请堆内存，直到对的大小超过V8的限制为止。

V8提供选择来调整内存大小的配置，需要在初始化时候配置生效，遇到Node无法分配足够内存给JS对象的情况，可以用如下办法来放宽V8默认内存限制。避免执行过程内存用的过多导致崩溃

````
node --max-old-space-size=1700 app.js //单位为MB
node --max-new-space-size=1024 app.js //单位为MB
````

要知晓V8为何限制了内存的用量，则需要回归到V8在内存使用上的策略：

* 表面上的原因是V8最初是作为浏览器的JavaScript引擎而设计，不太可能遇到大量内存的场景。
* 而深层次的原因则是由于V8的垃圾回收机制的限制。由于V8需要保证JavaScript应用逻辑与垃圾回收器所看到的不一样，V8在执行垃圾回收时会阻塞JavaScript应用逻辑，直到垃圾回收结束再重新执行JavaScript应用逻辑，这种行为被称为“全停顿”（stop-the-world）。
* 若V8的堆内存为1.5GB，V8做一次小的垃圾回收需要50ms以上，做一次非增量式的垃圾回收甚至要1秒以上。
* 这样浏览器将在1s内失去对用户的响应，造成假死现象。如果有动画效果的话，动画的展现也将显著受到影响。

