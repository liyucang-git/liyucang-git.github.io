---
layout: post
title: 算法系列题
subtitle: 对常见算法了然于胸
date: 2019-12-04
author: Li Yucang
catalog: true
tags:
  - 算法
---

# 算法系列题

程序代码使用c++编写，如果对c++基本语法还不熟悉，建议先去了解，这样有助于更快的理解代码。

## 数组中重复的数字

**找出数组中重复的数字**

题目：在一个长度为n的数组里的所有数字都在`0～n-1`的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。例如，如果输入长度为7的数组{2,3,1,0,2,5,3}，那么对应的输出是重复的数字2或者3。

传统思路：

1. 先排序，再从头到尾扫描，时间复杂度O(nlogn)，空间复杂度O(1)
2. 使用哈希表，从头到尾扫描，表中不存在则加入，存在则找到该数，时间复杂度O(n)，空间复杂度O(n)

新思路：

**在数组长度(n)>=数组值的范围(`0~n-1`)时**，说明每个数组值(m)都可以放置到其值对应的数组序号(`[m] = m`)中，所以我们只需从头到尾扫描数组，将每个元素交换到其值对应的序号位置，如果对应的序号位置存在值且为m，那我们就找到了重复的数字。

```
bool duplicate(int numbers[], int length, int* duplication)
{
    if(numbers == nullptr || length <= 0)
        return false;

    for(int i = 0; i < length; ++i)
    {
        if(numbers[i] < 0 || numbers[i] > length - 1)
            return false;
    }

    for(int i = 0; i < length; ++i)
    {
        while(numbers[i] != i) // 注意：这里会一直找到当前序号对应的值
        {
            if(numbers[i] == numbers[numbers[i]])
            {
                *duplication = numbers[i];
                return true;
            }

            int temp = numbers[i];
            numbers[i] = numbers[temp];
            numbers[temp] = temp;
        }
    }

    return false;
}
```

代码中尽管有一个两重循环，但每个数字最多只要交换两次就能找到属于自己的位置，因此时间复杂度为O(n)。另外，所以的操作步骤都是在输入数组上进行的，不需要额外分配内存，因此，空间复杂度为O(1)。

**不修改数组找出重复的数字**

题目：在一个长度为n+1的数组里的所有数字都在`1～n`的范围内，所以数组中至少有一个数字是重复的。请找出数组中任意一个重复的数字，但不能修改输入的数组。例如，如果输入长度为8的数组{2,3,5,4,3,2,6,7}，那么对应的输出是重复的数字2或者3。

传统思路：

1. 使用哈希表，从头到尾扫描，表中不存在则加入，存在则找到该数，时间复杂度O(n)，空间复杂度O(n)

新思路：

假如没有重复的数字，那么在从1~n的范围里只有n个数字。由于数组里包含超过n个数字，所以一定包含里重复的数字。

我们把从`1~n`的数字从中间的数字m分为两部分，前面一半为`1~m`，后面一半为`m+1~n`。如果`1~m`的数字的数目超过m，那么这一半的区间一定包含重复的数字。否则，另一半`m+1~n`的区间里一定包含重复的数字。我们可以继续把包含重复数字的区间一分为二，直到找到一个重复的数字。这个过程和二分查找算法很类似，只是多了一步统计区间里数字的数目。

```
int countRange(const int* numbers, int length, int start, int end);

int getDuplication(const int* numbers, int length)
{
    if(numbers == nullptr || length <= 0)
        return -1;

    int start = 1;
    int end = length - 1;
    while(end >= start)
    {
        int middle = ((end - start) >> 1) + start;
        int count = countRange(numbers, length, start, middle);
        if(end == start)
        {
            if(count > 1)
                return start;
            else
                break;
        }

        if(count > (middle - start + 1))
            end = middle;
        else
            start = middle + 1;
    }
    return -1;
}

int countRange(const int* numbers, int length, int start, int end)
{
    if(numbers == nullptr)
        return 0;

    int count = 0;
    for(int i = 0; i < length; i++)
        if(numbers[i] >= start && numbers[i] <= end)
            ++count;
    return count;
}
```

时间复杂度O(nlogn)，空间复杂度O(1)，和传统思路相比，是以时间换空间。而且这种方法没法保证找出所以重复的数字，因为下面两种情况会都认为区间内不存在重复数字：

1. 在一个区间内所有数字都只出现一次
2. 在一个区间内有的数字出现多次有的数字没有出现但总个数与区间长度相同

## 二维数组中的查找

题目：在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。

传统思路：

从数组选取一个数字，分3种情况来分析查找。选取数字和查找数字相等，结束查处。如果选取数字小于查找数字，要查找的数字应该在当前选取位置的右边或者下边。同样，如果选取的数字大于要查找的数字，那么要查找的数字应该在选取位置的上边或者左边：

![](/img/localBlog/1580193684787.jpg)

在这种分析中，由于要查找的数字相对于当前选取位置有可能在两个区域中出现，而且这两个区域还有重叠，这问题看起来就复杂了。

新思路：

如果我们从数组的一个角上选取数字来和要查找的数字进行比较，那么情况是不是变简单了呢？我们以选取数组右上角的数字为例，目标数字为7：

![](/img/localBlog/1580193925413.jpg)

我们发现每一步都可以缩小查找范围，直到找到要查找的数字。

```
bool Find(int* matrix, int rows, int columns, int number)
{
    bool found = false;

    if(matrix != nullptr && rows > 0 && columns > 0)
    {
        int row = 0;
        int column = columns - 1;
        while(row < rows && column >=0)
        {
            if(matrix[row * columns + column] == number)
            {
                found = true;
                break;
            }
            else if(matrix[row * columns + column] > number)
                -- column;
            else
                ++ row;
        }
    }

    return found;
}
```

## 替换空格

题目：请实现一个函数，把字符串中的每个空格替换成"%20"。例如输入“We are happy.”，则输出“We%20are%20happy.”。

传统思路：

这里我们假设我们可以在原来的字符串上进行替换，并保证输入字符串后面有足够多的空余内存。从头到尾扫描字符串，每次碰到空格字符的时候进行替换。由于是把一个字符替换成3个字符，我们必须要把空格后的所以字符都后移2个字节。

![](/img/localBlog/1580200002126.jpg)

时间复杂度是O(n^2)。

新思路：

先遍历一次字符串，统计出空格的总数，并由此计算出替换之后的字符串的总长度。我们从字符串后面开始复制和替换，准备两个指针：P1和P2，P1指向原始字符串的末尾，而P2指向替换之后的字符串的末尾。

![](/img/localBlog/1580200238829.jpg)

```
/*length 为字符数组str的总容量，大于或等于字符串str的实际长度*/
void ReplaceBlank(char str[], int length)
{
    if(str == nullptr && length <= 0)
        return;

    /*originalLength 为字符串str的实际长度*/
    int originalLength = 0;
    int numberOfBlank = 0;
    int i = 0;
    while(str[i] != '\0')
    {
        ++ originalLength;

        if(str[i] == ' ')
            ++ numberOfBlank;

        ++ i;
    }

    /*newLength 为把空格替换成'%20'之后的长度*/
    int newLength = originalLength + numberOfBlank * 2;
    if(newLength > length)
        return;

    int indexOfOriginal = originalLength;
    int indexOfNew = newLength;
    while(indexOfOriginal >= 0 && indexOfNew > indexOfOriginal)
    {
        if(str[indexOfOriginal] == ' ')
        {
            str[indexOfNew --] = '0';
            str[indexOfNew --] = '2';
            str[indexOfNew --] = '%';
        }
        else
        {
            str[indexOfNew --] = str[indexOfOriginal];
        }

        -- indexOfOriginal;
    }
}
```

相关题目：有两个排序的数组A1和A2，内存在A1的末尾有足够多的空余空间容纳A2。请实现一个函数，把A2中的所有数字插入A1中，并且所有的数字是排序的。

和前面的例题一样，我们可以从尾到头比较A1和A2中的数字，并把较大的数字复制到A1中的合适位置。

## 从尾到头打印链表

题目：输入一个链表的头结点，从尾到头反过来打印出每个结点的值。

```
struct ListNode
{
    int       m_nValue;
    ListNode* m_pNext;
};
```

1，将链表中链接节点的指针翻转过来，改变链表的方向，就可以从头到尾输出量。但这会改变原来链表的结构。

2，假设不能改变链表结构，使用栈来实现“后进先出”的顺序：

```
#include <stack>

void PrintListReversingly_Iteratively(ListNode* pHead)
{
    std::stack<ListNode*> nodes;

    ListNode* pNode = pHead;
    while(pNode != nullptr)
    {
        nodes.push(pNode);
        pNode = pNode->m_pNext;
    }

    while(!nodes.empty())
    {
        pNode = nodes.top();
        printf("%d\t", pNode->m_nValue);
        nodes.pop();
    }
}
```

3，既然想到了用栈来实现，而递归本质上就是一个栈结构，于是很自然又想到用递归来实现。要实现反过来输出链表，我们每访问一个节点时，先递归输出它后面的节点，再输出该节点自身：

```
void PrintListReversingly_Recursively(ListNode* pHead)
{
    if(pHead != nullptr)
    {
        if (pHead->m_pNext != nullptr)
        {
            PrintListReversingly_Recursively(pHead->m_pNext);
        }
 
        printf("%d\t", pHead->m_nValue);
    }
}
```

递归代码看起来很简洁，但有一个问题：当链表非常长的时候，就会导致函数调用的层级很深，有可能导致函数调用栈溢出。显然用栈基于循环实现的代码鲁棒性要好一些。

## 重建二叉树

题目：输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2, 4, 7, 3, 5, 6, 8}和中序遍历序列{4, 7, 2, 1, 5, 3, 8, 6}，则重建出二叉树并输出它的头结点，如图所示：

![](/img/localBlog/1580284597700.jpg)

二叉树节点定义如下：

```
struct BinaryTreeNode 
{
    int                    m_nValue; 
    BinaryTreeNode*        m_pLeft;  
    BinaryTreeNode*        m_pRight; 
};
```

二叉树的前序遍历序列中，第一个数字总是树的根结点的值。但在中序遍历序列中，根结点但值在序列的中间，左子树的节点位于根结点的值的左边，而右子树的节点位于根结点的值的右边：

![](/img/localBlog/1580284386421.jpg)

我们可以找到左、右子树的前序遍历序列和中序遍历序列，接着通过递归用同样的方法分别构建左、右子树：

```

BinaryTreeNode* ConstructCore(int* startPreorder, int* endPreorder, int* startInorder, int* endInorder);

BinaryTreeNode* Construct(int* preorder, int* inorder, int length)
{
    if(preorder == nullptr || inorder == nullptr || length <= 0)
        return nullptr;

    return ConstructCore(preorder, preorder + length - 1,
        inorder, inorder + length - 1);
}

BinaryTreeNode* ConstructCore
(
    int* startPreorder, int* endPreorder, 
    int* startInorder, int* endInorder
)
{
    // 前序遍历序列的第一个数字是根结点的值
    int rootValue = startPreorder[0];
    BinaryTreeNode* root = new BinaryTreeNode();
    root->m_nValue = rootValue;
    root->m_pLeft = root->m_pRight = nullptr;

    if(startPreorder == endPreorder)
    {
        if(startInorder == endInorder && *startPreorder == *startInorder)
            return root;
        else
            throw std::exception("Invalid input.");
    }

    // 在中序遍历中找到根结点的值
    int* rootInorder = startInorder;
    while(rootInorder <= endInorder && *rootInorder != rootValue)
        ++ rootInorder;

    if(rootInorder == endInorder && *rootInorder != rootValue)
        throw std::exception("Invalid input.");

    int leftLength = rootInorder - startInorder;
    int* leftPreorderEnd = startPreorder + leftLength;
    if(leftLength > 0)
    {
        // 构建左子树
        root->m_pLeft = ConstructCore(startPreorder + 1, leftPreorderEnd, 
            startInorder, rootInorder - 1);
    }
    if(leftLength < endPreorder - startPreorder)
    {
        // 构建右子树
        root->m_pRight = ConstructCore(leftPreorderEnd + 1, endPreorder,
            rootInorder + 1, endInorder);
    }

    return root;
}
```

## 二叉树的下一个结点

题目：给定一棵二叉树和其中的一个结点，如何找出中序遍历顺序的下一个结点？树中的结点除了有两个分别指向左右子结点的指针以外，还有一个指向父结点的指针。

我们以下图这棵树（中序遍历序列是{d,b,h,e,i,a,f,c,g}）来分析如何找出二叉树的下一个节点：

![](/img/localBlog/1580287361076.jpg)

1，如果一个节点有右子树，那么它的下一个节点就是它的右子树中最左子节点。也就是说，从右子节点出发一直沿着指向左子节点的指针，我们就可以找到它的下一个节点。图中节点b的下一个节点是h，节点a的下一个节点是f。

2，接着我们分析一个节点没有右子树的情形。如果节点是它父节点的左子节点，那么它的下一个节点就是它的父节点。图中节点d的下一个节点是b，节点f的下一个节点是c。

3，如果一个节点既没有右子树，并且它还是它父节点的右子节点，那么这种情形就比较复杂。我们可以沿着指向父节点的指针一直向上遍历，直到找到一个是它父节点的左子节点的节点。如果这样的节点存在，那么这个节点就是我们要找的下一个节点。如果不存在，则没有下一个节点。

```
struct BinaryTreeNode
{
    int                    m_nValue;
    BinaryTreeNode*        m_pLeft;
    BinaryTreeNode*        m_pRight;
    BinaryTreeNode*        m_pParent;
};

BinaryTreeNode* GetNext(BinaryTreeNode* pNode)
{
    if(pNode == nullptr)
        return nullptr;

    BinaryTreeNode* pNext = nullptr;
    if(pNode->m_pRight != nullptr)
    {
        BinaryTreeNode* pRight = pNode->m_pRight;
        while(pRight->m_pLeft != nullptr)
            pRight = pRight->m_pLeft;

        pNext = pRight;
    }
    else if(pNode->m_pParent != nullptr)
    {
        BinaryTreeNode* pCurrent = pNode;
        BinaryTreeNode* pParent = pNode->m_pParent;
        while(pParent != nullptr && pCurrent == pParent->m_pRight)
        {
            pCurrent = pParent;
            pParent = pParent->m_pParent;
        }

        pNext = pParent;
    }

    return pNext;
}
```

## 用两个栈实现队列

题目：用两个栈实现一个队列。队列的声明如下，请实现它的两个函数appendTail和deleteHead，分别完成在队列尾部插入结点和在队列头部删除结点的功能。

```
template <typename T> class CQueue
{
public:
    CQueue(void);
    ~CQueue(void);
    
    // 在队列末尾添加一个结点
    void appendTail(const T& node);

    // 删除队列的头结点
    T deleteHead();

private:
    stack<T> stack1;
    stack<T> stack2;
};
```

题目意图是要求我们操作这两个“先进后出”的栈实现一个“先进先出”的队列CQueue。难度不高，如图所示：

![](/img/localBlog/1580310474145.jpg)

```
#pragma once
#include <stack>
#include <exception>

using namespace std;

template <typename T> class CQueue
{
public:
    CQueue(void);
    ~CQueue(void);
    
    // 在队列末尾添加一个结点
    void appendTail(const T& node);

    // 删除队列的头结点
    T deleteHead();

private:
    stack<T> stack1;
    stack<T> stack2;
};

template <typename T> CQueue<T>::CQueue(void)
{
}

template <typename T> CQueue<T>::~CQueue(void)
{
}

template <typename T> void CQueue<T>::appendTail(const T& element)
{
    stack1.push(element);
} 

template <typename T> T CQueue<T>::deleteHead()
{
    if(stack2.size()<= 0)
    {
        while(stack1.size()>0)
        {
            T& data = stack1.top();
            stack1.pop();
            stack2.push(data);
        }
    }

    if(stack2.size() == 0)
        throw new exception("queue is empty");

    T head = stack2.top();
    stack2.pop();

    return head;
}
```

相关题目：用两个队列实现一个栈。

![](/img/localBlog/1580312689326.jpg)

## 斐波那契数列

题目：写一个函数，输入n，求斐波那契（Fibonacci）数列的第n项。斐波那契数列定义如下：

![](/img/localBlog/1580371098947.jpg)

使用递归：

```
long long Fibonacci_Solution1(unsigned int n)
{
    if(n <= 0)
        return 0;

    if(n == 1)
        return 1;

    return Fibonacci_Solution1(n - 1) + Fibonacci_Solution1(n - 2);
}
```

但这种解法有很严重的效率问题，我们以求解f(10)为例来分析递归的求解过程。想求得f(10)，需要先求得f(9)和f(8)。同样，想求得f(9)，需要先求得f(8)和f(7)...我们可以用树形结构来表示这种依赖关系：

![](/img/localBlog/1580371285372.jpg)

不难发现，这棵树中有很多节点是重复的，而且重复的节点数会随着n的增大而急剧增加，这意味着计算量会随着n的增大而急剧增大。事实上，用递归方法计算的时间复杂度是以n的指数的方式递增的。

使用循环：

其实改进的方法并不复杂，上述递归代码之所以慢，是因为重复的计算太多，我们只要避免重复计算就行了。比如我们可以把已经得到的数列中间项保存起来，在下次需要计算的时候先查找一下，如果前面已经计算过就不再重复计算了。

更简单的办法是从下往上计算，首先根据f(0)和f(1)算出f(2)，再根据f(1)和f(2)算出f(3)...以此类推就可以算出第n项了。这种思路的时间复杂度是O(n)。代码如下：

```
long long Fibonacci_Solution2(unsigned n)
{
    int result[2] = {0, 1};
    if(n < 2)
        return result[n];

    long long  fibNMinusOne = 1;
    long long  fibNMinusTwo = 0;
    long long  fibN = 0;
    for(unsigned int i = 2; i <= n; ++ i)
    {
        fibN = fibNMinusOne + fibNMinusTwo;

        fibNMinusTwo = fibNMinusOne;
        fibNMinusOne = fibN;
    }

     return fibN;
}
```

相关题目：一只青蛙一次可以跳上1级台阶，也可也跳上2级台阶。求该青蛙跳上一个n级的台阶总共有多少种跳法。

如果只有1级台阶，只有一种跳法。如果有2级台阶，有两种跳法。我们把n级台阶时的跳法看成n的函数，记为f(n)。当n>2时，第一次跳的时候有两种选择：一是第一次跳一级，此时跳法数目等于后面剩下的n-1级台阶的跳法数目，即f(n-1)；二是第一次跳2级，此时跳法数目等于后面剩下的n-2级台阶的跳法数目，即f(n-2)。因此，n级台阶的不同跳法的总数f(n)=f(n-1)+f(n-2)。分析到这里，不难看出这实际上就是斐波那契数列了。

题目拓展：在青蛙跳台阶的问题中，如果把条件改为：一只青蛙一次可以跳上1级台阶，也可也跳上2级台阶...它也可以跳上n级，此时该青蛙跳上一个n级的台阶总共有多少种跳法？

我们用数学归纳法可以证明`f(n)=2^(n-1)`

相关题目：我们可以用`2*1`的小矩形横着或者竖着去覆盖更大的矩形。请问用8个`2*1`的小矩形无重叠地覆盖一个`2*8`的大矩形，总共有多少种方法？

![](/img/localBlog/1580373053181.jpg)

我们先把`2*8`的覆盖方法记为f(8)。用第一个`2*1`的小矩形去覆盖大矩形最左边时有两种选择：竖着放或者横着放。当竖着放时，右边还剩下`2*7`的区域，这种情形下的覆盖方法记为f(7)。接下来考虑横着放的情况。当`2*1`的小矩形横着放在左上角时，左下角必须横着放一个`2*1`的小矩形，此时右边还剩下`2*6`的区域，这种情形下的覆盖方法记为f(6)。因此f(8)=f(7)+f(6)，仍然是斐波那契数列。

## 旋转数组的最小数字

题目：把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个递增排序的数组的一个旋转，输出旋转数组的最小元素。例如数组{3, 4, 5, 1, 2}为{1, 2, 3, 4, 5}的一个旋转，该数组的最小值为1。

传统思路：

从头到尾遍历数组一次，我们就能找出最小的元素，这种思路时间复杂度是O(n)。

新思路：

注意到选择之后的数组实际上可以划分为两个排序的子数组，而且前面的子数组的元素都大于或等于后面的子数组的元素。还注意到最小的元素刚好是这两个子数组的分界线，所以可以使用二分查找来实现O(logn)。

我们用两个指针分别指向数组的第一个元素和最后一个元素，按照题目中选择的规则，第一个元素应该是大于或者等于最后一个元素的(旋转数量为0时除外)。

接着我们可以找到数组中间的元素。如果该中间元素位于前面的递增子数组，那么它应该大于或者等于第一个指针指向的元素。此时数组中最小的元素应该位于该中间元素后面。我们可以把第一个指针指向该中间元素，这样可以缩小寻找的范围。移动之后的第一个指针仍然位于前面的递增子数组。

同样，如果中间元素位于后面的递增子数组，那么它应该小于或者等于第二个指针指向的元素。此时该数组中最小的元素应该位于该中间元素的前面。我们可以把第二个指针指向该中间元素吗，这样也可以缩小寻找的范围。移动之后的第二个指针仍然位于后面的递增子数组。

不管是移动第一个指针还是第二个指针，查找范围都会缩小到原来的一半。接下来我们再用更新之后的两个指针重复做新一轮的查找。以数组{3,4,5,1,2}为例：

![](/img/localBlog/1580451674652.jpg)

此外还需注意当数组中存在相同元素的时候，如数组{1,0,1,1,1}和数组{1,1,1,0,1}都可以看成递增排序数组{0,1,1,1,1}的旋转，如图分别画出它们由最小数字分隔开的两个子数组：

![](/img/localBlog/1580452697930.jpg)

在这两个数组中，第一个数字、最后一个数字和中间数字都是1，我们无法确定中间的数字1是属于第一个递增子数组还是属于第二个递增子数组。因此，当两个指针指向的数字及它们中间的数字三者相同的时候，我们不得不采用顺序查找的方法。

```
#include <exception>

int MinInOrder(int* numbers, int index1, int index2);

int Min(int* numbers, int length)
{
    if(numbers == nullptr || length <= 0)
        throw new std::exception("Invalid parameters");
 
    int index1 = 0;
    int index2 = length - 1;
    int indexMid = index1;
    while(numbers[index1] >= numbers[index2])
    {
        // 如果index1和index2指向相邻的两个数，
        // 则index1指向第一个递增子数组的最后一个数字，
        // index2指向第二个子数组的第一个数字，也就是数组中的最小数字
        if(index2 - index1 == 1)
        {
            indexMid = index2;
            break;
        }
 
        // 如果下标为index1、index2和indexMid指向的三个数字相等，
        // 则只能顺序查找
        indexMid = (index1 + index2) / 2;
        if(numbers[index1] == numbers[index2] && numbers[indexMid] == numbers[index1])
            return MinInOrder(numbers, index1, index2);

        // 缩小查找范围
        if(numbers[indexMid] >= numbers[index1])
            index1 = indexMid;
        else if(numbers[indexMid] <= numbers[index2])
            index2 = indexMid;
    }
 
    return numbers[indexMid];
}

int MinInOrder(int* numbers, int index1, int index2)
{
    int result = numbers[index1];
    for(int i = index1 + 1; i <= index2; ++i)
    {
        if(result > numbers[i])
            result = numbers[i];
    }

    return result;
}
```

前面我们提到，在旋转数组中，有一个特例：如果把排序数组的前面0个元素搬到最后面，即排序数组本身，这仍然是数组的一个旋转。此时，数组中的第一个数字就是最小的数字，可以直接返回。这就是上面代码中，把indexMid初始化为index1的原因。

## 矩阵中的路径

题目：请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中任意一格开始，每一步可以在矩阵中向左、右、上、下移动一格。如果一条路径经过了矩阵的某一格，那么该路径不能再次进入该格子。例如在下面的3×4的矩阵中包含一条字符串“bfce”的路径（路径中的字母用下划线标出）。但矩阵中不包含字符串“abfb”的路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入这个格子。

A B T G
C F C S
J D E H

思路：

这是一个可以用回溯法解决的典型题，回溯法可以看成蛮力法的升级版。路径可以被看成一个栈。当在矩阵中定位了路径中前n个字符的位置之后，在与第n个字符对应的格子的周围都没有找到第n+1个字符，这时候只好在路径上回到第n-1个字符，重新定位第n个字符。

由于路径不能重复进入矩阵的格子，所以还需要定义和字符矩阵大小一样的布尔值矩阵，用来标志路径是否已经进入每个格子。

```
bool hasPathCore(const char* matrix, int rows, int cols, int row, int col, const char* str, int& pathLength, bool* visited);

bool hasPath(const char* matrix, int rows, int cols, const char* str)
{
    if(matrix == nullptr || rows < 1 || cols < 1 || str == nullptr)
        return false;

    bool *visited = new bool[rows * cols];
    memset(visited, 0, rows * cols);

    int pathLength = 0;
    for(int row = 0; row < rows; ++row)
    {
        for(int col = 0; col < cols; ++col)
        {
            if(hasPathCore(matrix, rows, cols, row, col, str,
                pathLength, visited))
            {
                return true;
            }
        }
    }

    delete[] visited;

    return false;
}

bool hasPathCore(const char* matrix, int rows, int cols, int row,
    int col, const char* str, int& pathLength, bool* visited)
{
    if(str[pathLength] == '\0')
        return true;

    bool hasPath = false;
    if(row >= 0 && row < rows && col >= 0 && col < cols
        && matrix[row * cols + col] == str[pathLength]
        && !visited[row * cols + col])
    {
        ++pathLength;
        visited[row * cols + col] = true;

        hasPath = hasPathCore(matrix, rows, cols, row, col - 1,
            str, pathLength, visited)
            || hasPathCore(matrix, rows, cols, row - 1, col,
                str, pathLength, visited)
            || hasPathCore(matrix, rows, cols, row, col + 1,
                str, pathLength, visited)
            || hasPathCore(matrix, rows, cols, row + 1, col,
                str, pathLength, visited);

        if(!hasPath)
        {
            --pathLength;
            visited[row * cols + col] = false;
        }
    }

    return hasPath;
}
```

## 机器人的运动范围

题目：地上有一个m行n列的方格。一个机器人从坐标(0, 0)的格子开始移动，它每一次可以向左、右、上、下移动一格，但不能进入行坐标和列坐标的数位之和大于k的格子。例如，当k为18时，机器人能够进入方格(35, 37)，因为3+5+3+7=18。但它不能进入方格(35, 38)，因为3+5+3+8=19。请问该机器人能够到达多少个格子？

思路：

和前面的题目类似，这个方格也可以看作一个`m*n`的矩阵。机器人从坐标(0,0)开始移动，当它准备进入坐标(i,j)的格子时，通过检查坐标的位数来判断机器人是否能够进入。如果机器人能够进入，则再判断它能否进入4个相邻的格子。

```
int movingCountCore(int threshold, int rows, int cols, int row, int col, bool* visited);
bool check(int threshold, int rows, int cols, int row, int col, bool* visited);
int getDigitSum(int number);

int movingCount(int threshold, int rows, int cols)
{
    if(threshold < 0 || rows <= 0 || cols <= 0)
        return 0;

    bool *visited = new bool[rows * cols];
    for(int i = 0; i < rows * cols; ++i)
        visited[i] = false;

    int count = movingCountCore(threshold, rows, cols,
        0, 0, visited);

    delete[] visited;

    return count;
}

int movingCountCore(int threshold, int rows, int cols, int row,
    int col, bool* visited)
{
    int count = 0;
    if(check(threshold, rows, cols, row, col, visited))
    {
        visited[row * cols + col] = true;

        count = 1 + movingCountCore(threshold, rows, cols,
            row - 1, col, visited)
            + movingCountCore(threshold, rows, cols,
                row, col - 1, visited)
            + movingCountCore(threshold, rows, cols,
                row + 1, col, visited)
            + movingCountCore(threshold, rows, cols,
                row, col + 1, visited);
    }

    return count;
}

bool check(int threshold, int rows, int cols, int row, int col,
    bool* visited)
{
    if(row >= 0 && row < rows && col >= 0 && col < cols
        && getDigitSum(row) + getDigitSum(col) <= threshold
        && !visited[row* cols + col])
        return true;

    return false;
}

int getDigitSum(int number)
{
    int sum = 0;
    while(number > 0)
    {
        sum += number % 10;
        number /= 10;
    }

    return sum;
}
```

## 剪绳子

题目：给你一根长度为n绳子，请把绳子剪成m段（m、n都是整数，n>1并且m≥1）。每段的绳子的长度记为`k[0]、k[1]、……、k[m]`。`k[0]*k[1]…*k[m]`可能的最大乘积是多少？例如当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到最大的乘积18。

动态规划：

定义函数f(n)为把长度为n的绳子剪成若干段后个段长度乘积的最大值。再减第一刀的时候，我们有n-1种可能的选择，也就是剪出来的第一段绳子的可能长度分别为1，2，...，n-1。因此`f(n)=max(f(i)*f(n-i))`，其中`0<i<n`。

这是一个从上至下的递归公式。由于递归会有很多重复的子问题，从而有大量不必要的重复计算。一个更好的办法是按照从下而上的顺序计算，也就是我们先得到f(2)、f(3)，再得到f(4)、f(5)，直到得到f(n)。

```
int maxProductAfterCutting_solution1(int length)
{
    if(length < 2)
        return 0;
    if(length == 2)
        return 1;
    if(length == 3)
        return 2;

    int* products = new int[length + 1];
    products[0] = 0;
    products[1] = 1;
    products[2] = 2;
    products[3] = 3;

    int max = 0;
    for(int i = 4; i <= length; ++i)
    {
        max = 0;
        for(int j = 1; j <= i / 2; ++j)
        {
            int product = products[j] * products[i - j];
            if(max < product)
                max = product;
        }
        products[i] = max;
    }

    max = products[length];
    delete[] products;

    return max;
}
```

贪婪算法：

如果我们按照如下策略来剪绳子，则得到的各段绳子的长度的乘积将最大：当n>=5时，我们尽可能多的剪长度为3的绳子；当剩下的绳子长度为4时，把绳子剪成两段长度为2的绳子。

证明：当n>=5时，我们可以证明2(n-2)>n并且3(n-3)>n。也就是说，当绳子剩下的长度大于或者等于5的时候，我们就把它剪成长度为3或者2的绳子段。另外，当n>=5时，3(n-3)>=2(n-2)，因此我们应该尽可能地多剪长度为3的绳子。

```
int maxProductAfterCutting_solution2(int length)
{
    if(length < 2)
        return 0;
    if(length == 2)
        return 1;
    if(length == 3)
        return 2;

    // 尽可能多地减去长度为3的绳子段
    int timesOf3 = length / 3;

    // 当绳子最后剩下的长度为4的时候，不能再剪去长度为3的绳子段。
    // 此时更好的方法是把绳子剪成长度为2的两段，因为2*2 > 3*1。
    if(length - timesOf3 * 3 == 1)
        timesOf3 -= 1;

    int timesOf2 = (length - timesOf3 * 3) / 2;

    return (int) (pow(3, timesOf3)) * (int) (pow(2, timesOf2));
}
```

